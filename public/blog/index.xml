<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Blog on DARKNAVY</title>
    <link>https://www.darknavy.org/blog/</link>
    <description>Recent content in Blog on DARKNAVY</description>
    <image>
      <title>DARKNAVY</title>
      <url>https://www.darknavy.org/papermod-cover.png</url>
      <link>https://www.darknavy.org/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 03 Jan 2024 16:19:13 +0800</lastBuildDate><atom:link href="https://www.darknavy.org/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Strengthening the Shield: MTE in Heap Allocators</title>
      <link>https://www.darknavy.org/blog/strengthening_the_shield_mte_in_memory_allocators/</link>
      <pubDate>Wed, 03 Jan 2024 16:19:13 +0800</pubDate>
      
      <guid>https://www.darknavy.org/blog/strengthening_the_shield_mte_in_memory_allocators/</guid>
      <description>Introduction In 2018, with the release of ARMv8.5-A, a brand new chip security feature MTE (Memory Tagging Extensions) emerged. Five years later, in 2023, the first smartphone to support this feature was released — Google Pixel 8 — marking the official entry of MTE into the consumer market. Although this feature is not yet enabled by default, developers can turn it on themselves for testing.
As a powerful defense against memory corruption, there has not yet been a comprehensive analysis of MTE&amp;rsquo;s defensive boundaries, capabilities, and its impact on performance on the internet.</description>
    </item>
    
    <item>
      <title>Exploiting the libwebp Vulnerability, Part 2: Diving into Chrome Blink</title>
      <link>https://www.darknavy.org/blog/exploiting_the_libwebp_vulnerability_part_2/</link>
      <pubDate>Fri, 03 Nov 2023 14:10:17 +0800</pubDate>
      
      <guid>https://www.darknavy.org/blog/exploiting_the_libwebp_vulnerability_part_2/</guid>
      <description>Introduction When we examine a third-party library vulnerability in a real environment, we often encounter numerous complex variables that exist within the vulnerability&amp;rsquo;s context. Exploiting such a vulnerability is not as easy as one might imagine.
Here is the information we know:
The overflowed variable huffman_tables, has a size of 0x2f28. The heap chunk is allocated in the renderer&amp;rsquo;s ThreadPool, while most objects are allocated in the main thread. We can write a partially controlled 4-byte integer with an offset that is a multiple of 8 bytes.</description>
    </item>
    
    <item>
      <title>Exploiting the libwebp Vulnerability, Part 1: Playing with Huffman Code</title>
      <link>https://www.darknavy.org/blog/exploiting_the_libwebp_vulnerability_part_1/</link>
      <pubDate>Fri, 03 Nov 2023 14:10:12 +0800</pubDate>
      
      <guid>https://www.darknavy.org/blog/exploiting_the_libwebp_vulnerability_part_1/</guid>
      <description>Vulnerability Localization In the initial phase of vulnerability analysis, due to the absence of readily available PoCs or detailed analysis reports, we first attempted to read and understand the patch code for CVE-2023-4863 in the upstream repository of webmproject/libwebp. However, the WebM Project&amp;rsquo;s official patch was relatively complex, making it difficult for us to accurately pinpoint the root cause of the vulnerability.
Thus, we turned our attention to Apple&amp;rsquo;s official patch for CVE-2023-41064, and performed a comparison of the ImageIO framework before and after the update using BinDiff.</description>
    </item>
    
  </channel>
</rss>
