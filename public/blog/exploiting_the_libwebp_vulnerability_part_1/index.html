<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Exploiting the libwebp Vulnerability, Part 1: Playing with Huffman Code | DARKNAVY</title>
<meta name=keywords content><meta name=description content="Vulnerability Localization
In the initial phase of vulnerability analysis, due to the absence of readily available PoCs or detailed analysis reports, we first attempted to read and understand the patch code for CVE-2023-4863 in the upstream repository of webmproject/libwebp. However, the WebM Project&rsquo;s official patch was relatively complex, making it difficult for us to accurately pinpoint the root cause of the vulnerability.
Thus, we turned our attention to Apple&rsquo;s official patch for CVE-2023-41064, and performed a comparison of the ImageIO framework before and after the update using BinDiff. We noticed that Apple&rsquo;s patch involved fewer code changes and was much easier to understand."><meta name=author content="DARKNAVY"><link rel=canonical href=https://www.darknavy.org/blog/exploiting_the_libwebp_vulnerability_part_1/><link crossorigin=anonymous href=/assets/css/stylesheet.38a584f0fc0f77186c8518d4117588a5b01cffe28707e993a6ae5cd5e2b0c5d0.css integrity="sha256-OKWE8PwPdxhshRjUEXWIpbAc/+KHB+mTpq5c1eKwxdA=" rel="preload stylesheet" as=style><link rel=icon href=https://www.darknavy.org/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.darknavy.org/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.darknavy.org/favicon-32x32.png><link rel=apple-touch-icon href=https://www.darknavy.org/apple-touch-icon.png><link rel=mask-icon href=https://www.darknavy.org/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.darknavy.org/blog/exploiting_the_libwebp_vulnerability_part_1/><link rel=alternate hreflang=zh href=https://www.darknavy.org/zh/blog/exploiting_the_libwebp_vulnerability_part_1/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-LR4ZN1LSPS"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LR4ZN1LSPS")}</script><meta property="og:title" content="Exploiting the libwebp Vulnerability, Part 1: Playing with Huffman Code"><meta property="og:description" content="Vulnerability Localization
In the initial phase of vulnerability analysis, due to the absence of readily available PoCs or detailed analysis reports, we first attempted to read and understand the patch code for CVE-2023-4863 in the upstream repository of webmproject/libwebp. However, the WebM Project&rsquo;s official patch was relatively complex, making it difficult for us to accurately pinpoint the root cause of the vulnerability.
Thus, we turned our attention to Apple&rsquo;s official patch for CVE-2023-41064, and performed a comparison of the ImageIO framework before and after the update using BinDiff. We noticed that Apple&rsquo;s patch involved fewer code changes and was much easier to understand."><meta property="og:type" content="article"><meta property="og:url" content="https://www.darknavy.org/blog/exploiting_the_libwebp_vulnerability_part_1/"><meta property="og:image" content="https://www.darknavy.org/images/white_logo.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-11-03T14:10:12+08:00"><meta property="article:modified_time" content="2023-11-03T14:10:12+08:00"><meta property="og:site_name" content="DARKNAVY"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.darknavy.org/images/white_logo.png"><meta name=twitter:title content="Exploiting the libwebp Vulnerability, Part 1: Playing with Huffman Code"><meta name=twitter:description content="Vulnerability Localization
In the initial phase of vulnerability analysis, due to the absence of readily available PoCs or detailed analysis reports, we first attempted to read and understand the patch code for CVE-2023-4863 in the upstream repository of webmproject/libwebp. However, the WebM Project&rsquo;s official patch was relatively complex, making it difficult for us to accurately pinpoint the root cause of the vulnerability.
Thus, we turned our attention to Apple&rsquo;s official patch for CVE-2023-41064, and performed a comparison of the ImageIO framework before and after the update using BinDiff. We noticed that Apple&rsquo;s patch involved fewer code changes and was much easier to understand."><meta name=twitter:site content="@DarkNavyOrg"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://www.darknavy.org/blog/"},{"@type":"ListItem","position":2,"name":"Exploiting the libwebp Vulnerability, Part 1: Playing with Huffman Code","item":"https://www.darknavy.org/blog/exploiting_the_libwebp_vulnerability_part_1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Exploiting the libwebp Vulnerability, Part 1: Playing with Huffman Code","name":"Exploiting the libwebp Vulnerability, Part 1: Playing with Huffman Code","description":"Vulnerability Localization In the initial phase of vulnerability analysis, due to the absence of readily available PoCs or detailed analysis reports, we first attempted to read and understand the patch code for CVE-2023-4863 in the upstream repository of webmproject/libwebp. However, the WebM Project\u0026rsquo;s official patch was relatively complex, making it difficult for us to accurately pinpoint the root cause of the vulnerability.\nThus, we turned our attention to Apple\u0026rsquo;s official patch for CVE-2023-41064, and performed a comparison of the ImageIO framework before and after the update using BinDiff. We noticed that Apple\u0026rsquo;s patch involved fewer code changes and was much easier to understand.\n","keywords":[],"articleBody":"Vulnerability Localization In the initial phase of vulnerability analysis, due to the absence of readily available PoCs or detailed analysis reports, we first attempted to read and understand the patch code for CVE-2023-4863 in the upstream repository of webmproject/libwebp. However, the WebM Project’s official patch was relatively complex, making it difficult for us to accurately pinpoint the root cause of the vulnerability.\nThus, we turned our attention to Apple’s official patch for CVE-2023-41064, and performed a comparison of the ImageIO framework before and after the update using BinDiff. We noticed that Apple’s patch involved fewer code changes and was much easier to understand.\nIn short, Apple’s fix introduces an additional check in the WebP decoder: if there is an out-of-bounds write while constructing the Huffman Table, it directly returns an error instead of continuing the decoding process.\ndiff --git a/src/dec/vp8l_dec.c b/src/dec/vp8l_dec.c index 45012162..06b142bc 100644 --- a/src/dec/vp8l_dec.c +++ b/src/dec/vp8l_dec.c @@ -438,6 +438,7 @@ static int ReadHuffmanCodes(VP8LDecoder* const dec, int xsize, int ysize, goto Error; } + bound = \u0026huffman_tables[num_htree_groups * table_size]; huffman_table = huffman_tables; for (i = 0; i \u003c num_htree_groups_max; ++i) { // If the index \"i\" is unused in the Huffman image, just make sure the diff --git a/src/utils/huffman_utils.c b/src/utils/huffman_utils.c index 90c2fbf7..13054715 100644 --- a/src/utils/huffman_utils.c +++ b/src/utils/huffman_utils.c @@ -191,6 +191,7 @@ static int BuildHuffmanTable(HuffmanCode* const root_table, int root_bits, } code.bits = (uint8_t)(len - root_bits); code.value = (uint16_t)sorted[symbol++]; + if (bound \u0026\u0026 \u0026table[key \u003e\u003e root_bits + table_size] \u003e= bound) return 0; ReplicateValue(\u0026table[key \u003e\u003e root_bits], step, table_size, code); key = GetNextKey(key, len); } Therefore, it is highly likely that the vulnerability was caused by the lack of validity checks on input data when constructing the Huffman Table, leading to an overflow of the allocated memory for the table, i.e., a buffer overflow occurred.\nVulnerability Analysis The root of the vulnerability lies within the code logic that handles WebP images. When parsing a lossless WebP image, the decoder uses the sequential data compression (LZ77), prefix coding, and a color cache to compress the image’s ARGB data. For specific details of this process, Google provides an exhaustive description in its technical documentation and offers a clear structural specification of the WebP file format.\nIn this process, the decoder first reads prefix-encoded data from the image data stream and uses this data to construct a complete Huffman coding table. Then, based on this table, the decoder decodes the compressed data in the stream, restoring the original image. As there are already many introductory articles on the algorithmic details of Huffman coding, this article will not elaborate further.\nFollowing the Canonical Huffman Coding algorithm, when constructing the Huffman coding table, a first-level table is used, which is for querying Huffman codes with lengths less than N bits (default is 8 bits); if there are codes exceeding N bits, the decoder allocates second-level tables to query these extended codes.\nWhen allocating memory for the Huffman coding tables, the decoder reserves enough space to accommodate all primary and secondary tables at once, and the memory size is fixed:\n// Memory needed for lookup tables of one Huffman tree group. Red, blue, alpha // and distance alphabets are constant (256 for red, blue and alpha, 40 for // distance) and lookup table sizes for them in worst case are 630 and 410 // respectively. Size of green alphabet depends on color cache size and is equal // to 256 (green component values) + 24 (length prefix values) // + color_cache_size (between 0 and 2048). // All values computed for 8-bit first level lookup with Mark Adler's tool: // https://github.com/madler/zlib/blob/v1.2.5/examples/enough.c #define FIXED_TABLE_SIZE (630 * 3 + 410) static const uint16_t kTableSize[12] = { FIXED_TABLE_SIZE + 654, FIXED_TABLE_SIZE + 656, FIXED_TABLE_SIZE + 658, FIXED_TABLE_SIZE + 662, FIXED_TABLE_SIZE + 670, FIXED_TABLE_SIZE + 686, FIXED_TABLE_SIZE + 718, FIXED_TABLE_SIZE + 782, FIXED_TABLE_SIZE + 912, FIXED_TABLE_SIZE + 1168, FIXED_TABLE_SIZE + 1680, FIXED_TABLE_SIZE + 2704 }; const int table_size = kTableSize[color_cache_bits]; huffman_tables = (HuffmanCode*)WebPSafeMalloc(num_htree_groups * table_size, sizeof(*huffman_tables)); From this code snippet, it can be seen that the table consists of five parts, corresponding to the lookup tables for the red, green, blue, alpha, and distance channels respectively. The size of the tables for the red, blue, and alpha channels are fixed at 630, the size of the table for the distance channel is fixed at 410, while the size of the green channel’s table depends on the size of the color cache. The sum of these sizes constitutes the total size of the entire table. Additionally, the author provides a tool from the zlib library, enough.c, which can calculate the maximum possible size of the lookup table given a specified code length and color cache size.\nThe problem is that the decoder assumes by default that the Huffman table data stored in the image is reasonable, and thus it pre-calculates the maximum memory length based on this assumption. The core premise here is that the encoded data must conform to the standards of Canonical Huffman Coding, meaning the Huffman tree should be a binary tree, with each leaf node corresponding to a prefix code and no unused hanging leaf nodes. However, since the Huffman table data comes from an untrusted source and may be arbitrarily constructed by an attacker, the decoder parses an incomplete binary tree without validating these data, which could allocate too many second-level tables, leading to the total memory usage exceeding the pre-allocated size and causing a heap buffer overflow.\nTaking the green channel as an example, when the color cache size is 0, the maximum size of its Huffman table is 654. Using the enough tool, we can obtain the possible structure of its Huffman table (referencing lifthrasiir’s expression):\nLen Code range # Root entry Overhead # --- ------------------------------------ --- ----------------- -------- --- 1 0 1 0xxxxxxx 0 128 9 10000000:0 .. 11110110:1 238 10000000-11110110 2^1 119 11110111:0 1 11110111 2^2 1 10 11110111:10 .. 11110111:11 2 11111000:00 .. 11111110:11 28 11111000-11111110 2^2 7 11111111:00 .. 11111111:10 3 11111111 2^7 1 11 11111111:110 1 12 11111111:1110 1 13 11111111:11110 1 15 11111111:1111100 .. 11111111:1111111 4 In this case, the memory size of the Huffman table is 256 (1st table) + 2*119 + 4*8 + 128 = 654, which precisely matches the maximum value hardcoded.\nHowever, if we construct an incomplete Huffman tree, containing a large number of long codes, the decoder will allocate second-level tables without bounds checking:\nLen Code range # Root entry Overhead # --- ------------------------------------ --- ----------------- -------- --- 9 00000000:0 1 00000000 2^7 1 10 00000000:10 1 11 00000000:110 1 12 00000000:1110 1 13 00000000:11110 1 14 00000000:111110 1 15 00000000:1111110 .. 00000000:1111111 2 00000001:0000000 .. 00000010:1111111 256 00000001-00000010 2^7 2 00000011:0000000 .. 00000011:0001111 1 00000011 2^7 1 Under this circumstances, the memory size of the Huffman table should be 256 (1st table) + 128*4 = 768, which undoubtedly exceeds the hardcoded maximum size.\nSubsequently, the decoder will call the BuildHuffmanTable function to build the Huffman table in the initially allocated memory space, writing the reversed prefix codes into memory through the ReplicateValue function. Since the number of allocated second-level tables exceeds expectations, out-of-bounds writing occurs, which may allow an attacker to execute arbitrary code.\n// Fill in 2nd level tables and add pointers to root table. for (len = root_bits + 1, step = 2; len \u003c= MAX_ALLOWED_CODE_LENGTH; ++len, step \u003c\u003c= 1) { // ... snip ... for (; count[len] \u003e 0; --count[len]) { // ... snip ... code.bits = (uint8_t)(len - root_bits); code.value = (uint16_t)sorted[symbol++]; ReplicateValue(\u0026table[key \u003e\u003e root_bits], step, table_size, code); // overflow here key = GetNextKey(key, len); } } Vulnerability Exploitation How to construct a PoC and bypass checks? It naturally occurred to us that, if we could directly construct a sufficiently large Huffman table, would it be possible to overflow the memory space allocated by the program?\nThe answer is no. Because the overflow length of a single Huffman table is limited and is not enough to cover the entire huffman_tables. Moreover, each time after constructing a Huffman table, the program will check the integrity of the Huffman tree, and an incomplete tree will cause the decoding process to be interrupted:\n// Check if tree is full. if (num_nodes != 2 * offset[MAX_ALLOWED_CODE_LENGTH] - 1) { return 0; } Therefore, a feasible method is to construct four normal Huffman tables corresponding to the green, red, blue and alpha channels, respectively, and ensure that they can reach their respective maximum allocation space under the condition of ensuring WebP image format compliance. Then, an incomplete Huffman tree is constructed in the distance channel, so that the cumulative size of all Huffman tables exceeds the predetermined memory capacity, resulting in memory overflow.\nHow to trigger a crash? We found that although the PoC could trigger ASAN’s error report or cause a crash of the dwebp tool with glibc, it does not affect mainstream browsers like Safari, Chrome, etc.\nAfter some debugging, we discovered that the default size of the Huffman table is 2954 table entries, and the allocated space is 2954*4=11816 (0x2e28) bytes. However, in Chromium and WebKit, malloc(0x2e28) will eventually allocate 0x3000 bytes of memory space, while the overflow length of the sample is about 0x190 bytes, which means our overflow is not sufficient to cross the allocated memory boundary, therefore not triggering a crash.\nTherefore, we need to make the size of the allocated Huffman table as close to 0x3000 as possible. How do we achieve this? In the vulnerability analysis section, we mentioned that the green channel space in kTableSize is variable-length and its size is affected by the color cache. If we set the size of the color cache to 6, the size of the Huffman table becomes (630 * 3 + 410 + 718) * 4 = 12072 = 0x2f28 bytes, allowing us to overwrite the content of the adjacent heap chunks.\nHow to build primitives? In order to achieve controllable and stable heap out-of-bounds writes, we need to construct a powerful exploitation primitive, which needs to achieve the effect that the attacker can write controllable data at any specified heap offset.\nHowever, there are some difficulties in implementing both of these points in WebP vulnerabilities. On the one hand, the unit written by the Huffman table is HuffmanCode, in which only part of the data can be controlled by the attacker; on the other hand, HuffmanCode is not written into the Huffman table sequentially, and its index is calculated according to the rules of reverse Huffman coding, so it can not directly control the position of OOB writes.\nHow to control the data to write? Let’s first focus on the deconstruction of the written data. The Huffman table is actually an array containing multiple HuffmanCode, where each HuffmanCode is structured as follows:\ntypedef struct { uint8_t bits; // number of bits used for this symbol uint16_t value; // symbol value or table offset } HuffmanCode; The memory layout of the structure is as follows:\n| bits (1 byte) | padding (1 byte) | value (2 bytes) | In this structure, the bits field represents the code length of the current HuffmanCode, and the value field represents the value. Each HuffmanCode occupies 4 bytes of memory. The range of bits is limited by the prefix code length, and its value range is [1, 15]; while value is the actual encoded data of the current HuffmanCode, which can be controlled by the attacker, and its range depends on the range of the encoded data, for example, for RGB color encoding, the range is [0, 255].\nSince we are constructing the overflow sample in the distance channel, the number of coded symbols is 40, so we can write a 4-byte object, in which the 2 bytes of the high address is controllable, and the value range is [0,39].\nHow to control the position to write? Reading the code, we find that HuffmanCode is written into memory in the ReplicateValue function, while the position of the write is calculated in the GetNextKey function:\n// Returns reverse(reverse(key, len) + 1, len), where reverse(key, len) is the // bit-wise reversal of the len least significant bits of key. static WEBP_INLINE uint32_t GetNextKey(uint32_t key, int len) { uint32_t step = 1 \u003c\u003c (len - 1); while (key \u0026 step) { step \u003e\u003e= 1; } return step ? (key \u0026 (step - 1)) + step : key; } code.bits = (uint8_t)(len - root_bits); code.value = (uint16_t)sorted[symbol++]; ReplicateValue(\u0026table[key \u003e\u003e root_bits], step, table_size, code); It can be seen that HuffmanCode is not written into the Huffman table sequentially; its index is obtained through reversed prefix code calculation. To control the index of the write, we calculated the index sequence of each HuffmanCode in the second-level Huffman table under a 15-bit prefix code length (encoding field is 2^(15-8)=128):\n0x0 0x40 0x20 0x60 0x10 0x50 0x30 0x70 0x8 0x48 0x28 0x68 0x18 0x58 0x38 0x78 0x4 0x44 0x24 0x64 0x14 0x54 0x34 0x74 0xc 0x4c 0x2c 0x6c 0x1c 0x5c 0x3c 0x7c 0x2 0x42 0x22 0x62 0x12 0x52 0x32 0x72 0xa 0x4a 0x2a 0x6a 0x1a 0x5a 0x3a 0x7a 0x6 0x46 0x26 0x66 0x16 0x56 0x36 0x76 0xe 0x4e 0x2e 0x6e 0x1e 0x5e 0x3e 0x7e 0x1 0x41 0x21 0x61 0x11 0x51 0x31 0x71 0x9 0x49 0x29 0x69 0x19 0x59 0x39 0x79 0x5 0x45 0x25 0x65 0x15 0x55 0x35 0x75 0xd 0x4d 0x2d 0x6d 0x1d 0x5d 0x3d 0x7d 0x3 0x43 0x23 0x63 0x13 0x53 0x33 0x73 0xb 0x4b 0x2b 0x6b 0x1b 0x5b 0x3b 0x7b 0x7 0x47 0x27 0x67 0x17 0x57 0x37 0x77 0xf 0x4f 0x2f 0x6f 0x1f 0x5f 0x3f 0x7f Our idea is: to construct four 15-bit encodings in the overflowed Huffman table, so that its fourth HuffmanCode is written to the index at 0x60, enabling it to cover the data of the next heap chunk. Additionally, we can construct multiple 9-bit encodings (where the size of the second-level Huffman table is 2), allowing this index to be adjusted in increments of 2, thereby achieving controllable index. As shown in the following figure:\nTherefore, we end up with the primitive effect that the attacker can write a partially controllable 4-byte data with a controllable offset in multiples of 8 bytes.\n","wordCount":"2345","inLanguage":"en","image":"https://www.darknavy.org/images/white_logo.png","datePublished":"2023-11-03T14:10:12+08:00","dateModified":"2023-11-03T14:10:12+08:00","author":{"@type":"Person","name":"DARKNAVY"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.darknavy.org/blog/exploiting_the_libwebp_vulnerability_part_1/"},"publisher":{"@type":"Organization","name":"DARKNAVY","logo":{"@type":"ImageObject","url":"https://www.darknavy.org/images/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://www.darknavy.org/ accesskey=h title="  (Alt + H)"><img src=https://www.darknavy.org/images/darknavy_shenlan_dot.png alt aria-label=logo height=20></a><div class=logo-switches><ul class=lang-switch><li>|</li><li><a href=https://www.darknavy.org/zh/ title=Chinese aria-label=Chinese>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://www.darknavy.org/ title=Home><span>Home</span></a></li><li><a href=https://www.darknavy.org/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://www.darknavy.org/darknavy_insight/ title=Insight><span>Insight</span></a></li><li><a href=https://www.darknavy.org/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.darknavy.org/>Home</a>&nbsp;»&nbsp;<a href=https://www.darknavy.org/blog/>Blog</a></div><h1 class="post-title entry-hint-parent">Exploiting the libwebp Vulnerability, Part 1: Playing with Huffman Code</h1><div class=post-meta><span title='2023-11-03 14:10:12 +0800 CST'>November 3, 2023</span>&nbsp;·&nbsp;2345 words&nbsp;·&nbsp;DARKNAVY&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://www.darknavy.org/zh/blog/exploiting_the_libwebp_vulnerability_part_1/>Zh</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#vulnerability-localization>Vulnerability Localization</a></li><li><a href=#vulnerability-analysis>Vulnerability Analysis</a></li><li><a href=#vulnerability-exploitation>Vulnerability Exploitation</a><ul><li><a href=#how-to-construct-a-poc-and-bypass-checks>How to construct a PoC and bypass checks?</a></li><li><a href=#how-to-trigger-a-crash>How to trigger a crash?</a></li><li><a href=#how-to-build-primitives>How to build primitives?</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=vulnerability-localization>Vulnerability Localization<a hidden class=anchor aria-hidden=true href=#vulnerability-localization>#</a></h2><p>In the initial phase of vulnerability analysis, due to the absence of readily available PoCs or detailed analysis reports, we first attempted to read and understand the <a href=https://github.com/webmproject/libwebp/commit/902bc9190331343b2017211debcec8d2ab87e17a>patch code</a> for CVE-2023-4863 in the upstream repository of webmproject/libwebp. However, the WebM Project&rsquo;s official patch was relatively complex, making it difficult for us to accurately pinpoint the root cause of the vulnerability.</p><p>Thus, we turned our attention to Apple&rsquo;s official patch for CVE-2023-41064, and performed a comparison of the ImageIO framework before and after the update using BinDiff. We noticed that Apple&rsquo;s patch involved fewer code changes and was much easier to understand.</p><img src=assets/1-diff.png alt="ImageIO patch in BinDiff" style=display:block;margin-left:auto;margin-right:auto;zoom:67%>
<img src=assets/2-diff.png alt="ImageIO patch in IDA Pro" style=display:block;margin-left:auto;margin-right:auto;zoom:67%><p>In short, Apple’s fix introduces an additional check in the WebP decoder: if there is an out-of-bounds write while constructing the Huffman Table, it directly returns an error instead of continuing the decoding process.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-diff data-lang=diff><span class=line><span class=cl><span class=gh>diff --git a/src/dec/vp8l_dec.c b/src/dec/vp8l_dec.c
</span></span></span><span class=line><span class=cl><span class=gh>index 45012162..06b142bc 100644
</span></span></span><span class=line><span class=cl><span class=gh></span><span class=gd>--- a/src/dec/vp8l_dec.c
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+++ b/src/dec/vp8l_dec.c
</span></span></span><span class=line><span class=cl><span class=gi></span><span class=gu>@@ -438,6 +438,7 @@ static int ReadHuffmanCodes(VP8LDecoder* const dec, int xsize, int ysize,
</span></span></span><span class=line><span class=cl><span class=gu></span>     goto Error;
</span></span><span class=line><span class=cl>   }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gi>+  bound = &amp;huffman_tables[num_htree_groups * table_size];
</span></span></span><span class=line><span class=cl><span class=gi></span>   huffman_table = huffman_tables;
</span></span><span class=line><span class=cl>   for (i = 0; i &lt; num_htree_groups_max; ++i) {
</span></span><span class=line><span class=cl>     // If the index &#34;i&#34; is unused in the Huffman image, just make sure the
</span></span><span class=line><span class=cl><span class=gh>diff --git a/src/utils/huffman_utils.c b/src/utils/huffman_utils.c
</span></span></span><span class=line><span class=cl><span class=gh>index 90c2fbf7..13054715 100644
</span></span></span><span class=line><span class=cl><span class=gh></span><span class=gd>--- a/src/utils/huffman_utils.c
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+++ b/src/utils/huffman_utils.c
</span></span></span><span class=line><span class=cl><span class=gi></span><span class=gu>@@ -191,6 +191,7 @@ static int BuildHuffmanTable(HuffmanCode* const root_table, int root_bits,
</span></span></span><span class=line><span class=cl><span class=gu></span>         }
</span></span><span class=line><span class=cl>         code.bits = (uint8_t)(len - root_bits);
</span></span><span class=line><span class=cl>         code.value = (uint16_t)sorted[symbol++];
</span></span><span class=line><span class=cl><span class=gi>+        if (bound &amp;&amp; &amp;table[key &gt;&gt; root_bits + table_size] &gt;= bound) return 0;
</span></span></span><span class=line><span class=cl><span class=gi></span>         ReplicateValue(&amp;table[key &gt;&gt; root_bits], step, table_size, code);
</span></span><span class=line><span class=cl>         key = GetNextKey(key, len);
</span></span><span class=line><span class=cl>       }
</span></span></code></pre></div><p>Therefore, it is highly likely that the vulnerability was caused by the lack of validity checks on input data when constructing the Huffman Table, leading to an overflow of the allocated memory for the table, i.e., a buffer overflow occurred.</p><h2 id=vulnerability-analysis>Vulnerability Analysis<a hidden class=anchor aria-hidden=true href=#vulnerability-analysis>#</a></h2><p>The root of the vulnerability lies within the code logic that handles WebP images. When parsing a lossless WebP image, the decoder uses the sequential data compression (LZ77), prefix coding, and a color cache to compress the image&rsquo;s ARGB data. For specific details of this process, Google provides an exhaustive description in its <a href=https://developers.google.com/speed/webp/docs/webp_lossless_bitstream_specification>technical documentation</a> and offers a clear structural specification of the WebP file format.</p><p>In this process, the decoder first reads prefix-encoded data from the image data stream and uses this data to construct a complete Huffman coding table. Then, based on this table, the decoder decodes the compressed data in the stream, restoring the original image. As there are already many introductory articles on the algorithmic details of Huffman coding, this article will not elaborate further.</p><p>Following the Canonical Huffman Coding algorithm, when constructing the Huffman coding table, a first-level table is used, which is for querying Huffman codes with lengths less than N bits (default is 8 bits); if there are codes exceeding N bits, the decoder allocates second-level tables to query these extended codes.</p><p>When allocating memory for the Huffman coding tables, the decoder reserves enough space to accommodate all primary and secondary tables at once, and <strong>the memory size is fixed</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Memory needed for lookup tables of one Huffman tree group. Red, blue, alpha
</span></span></span><span class=line><span class=cl><span class=c1>// and distance alphabets are constant (256 for red, blue and alpha, 40 for
</span></span></span><span class=line><span class=cl><span class=c1>// distance) and lookup table sizes for them in worst case are 630 and 410
</span></span></span><span class=line><span class=cl><span class=c1>// respectively. Size of green alphabet depends on color cache size and is equal
</span></span></span><span class=line><span class=cl><span class=c1>// to 256 (green component values) + 24 (length prefix values)
</span></span></span><span class=line><span class=cl><span class=c1>// + color_cache_size (between 0 and 2048).
</span></span></span><span class=line><span class=cl><span class=c1>// All values computed for 8-bit first level lookup with Mark Adler&#39;s tool:
</span></span></span><span class=line><span class=cl><span class=c1>// https://github.com/madler/zlib/blob/v1.2.5/examples/enough.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define FIXED_TABLE_SIZE (630 * 3 + 410)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>static</span> <span class=k>const</span> <span class=kt>uint16_t</span> <span class=n>kTableSize</span><span class=p>[</span><span class=mi>12</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>FIXED_TABLE_SIZE</span> <span class=o>+</span> <span class=mi>654</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>FIXED_TABLE_SIZE</span> <span class=o>+</span> <span class=mi>656</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>FIXED_TABLE_SIZE</span> <span class=o>+</span> <span class=mi>658</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>FIXED_TABLE_SIZE</span> <span class=o>+</span> <span class=mi>662</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>FIXED_TABLE_SIZE</span> <span class=o>+</span> <span class=mi>670</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>FIXED_TABLE_SIZE</span> <span class=o>+</span> <span class=mi>686</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>FIXED_TABLE_SIZE</span> <span class=o>+</span> <span class=mi>718</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>FIXED_TABLE_SIZE</span> <span class=o>+</span> <span class=mi>782</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>FIXED_TABLE_SIZE</span> <span class=o>+</span> <span class=mi>912</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>FIXED_TABLE_SIZE</span> <span class=o>+</span> <span class=mi>1168</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>FIXED_TABLE_SIZE</span> <span class=o>+</span> <span class=mi>1680</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>FIXED_TABLE_SIZE</span> <span class=o>+</span> <span class=mi>2704</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>table_size</span> <span class=o>=</span> <span class=n>kTableSize</span><span class=p>[</span><span class=n>color_cache_bits</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>huffman_tables</span> <span class=o>=</span> <span class=p>(</span><span class=n>HuffmanCode</span><span class=o>*</span><span class=p>)</span><span class=nf>WebPSafeMalloc</span><span class=p>(</span><span class=n>num_htree_groups</span> <span class=o>*</span> <span class=n>table_size</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>huffman_tables</span><span class=p>));</span>
</span></span></code></pre></div><p>From this code snippet, it can be seen that the table consists of five parts, corresponding to the lookup tables for the red, green, blue, alpha, and distance channels respectively. The size of the tables for the red, blue, and alpha channels are fixed at 630, the size of the table for the distance channel is fixed at 410, while the size of the green channel&rsquo;s table depends on the size of the color cache. The sum of these sizes constitutes the total size of the entire table. Additionally, the author provides a tool from the zlib library, enough.c, which can calculate the maximum possible size of the lookup table given a specified code length and color cache size.</p><p>The problem is that the decoder assumes by default that the Huffman table data stored in the image is reasonable, and thus it pre-calculates the maximum memory length based on this assumption. <strong>The core premise here is that the encoded data must conform to the standards of Canonical Huffman Coding, meaning the Huffman tree should be a binary tree, with each leaf node corresponding to a prefix code and no unused hanging leaf nodes.</strong> However, since the Huffman table data comes from an untrusted source and may be arbitrarily constructed by an attacker, the decoder parses an incomplete binary tree without validating these data, which could <strong>allocate too many second-level tables</strong>, leading to the total memory usage <strong>exceeding the pre-allocated size</strong> and causing a heap buffer overflow.</p><p>Taking the green channel as an example, when the color cache size is 0, the maximum size of its Huffman table is 654. Using the <code>enough</code> tool, we can obtain the possible structure of its Huffman table (referencing <a href="https://news.ycombinator.com/item?id=37483981">lifthrasiir</a>&rsquo;s expression):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    Len  Code range                            #         Root entry         Overhead  #
</span></span><span class=line><span class=cl>    ---  ------------------------------------  ---       -----------------  --------  ---
</span></span><span class=line><span class=cl>    1    0                                     1         0xxxxxxx           0         128
</span></span><span class=line><span class=cl>    9    10000000:0 .. 11110110:1              238       10000000-11110110  2^1       119
</span></span><span class=line><span class=cl>         11110111:0                            1         11110111           2^2       1
</span></span><span class=line><span class=cl>    10   11110111:10 .. 11110111:11            2
</span></span><span class=line><span class=cl>         11111000:00 .. 11111110:11            28        11111000-11111110  2^2       7
</span></span><span class=line><span class=cl>         11111111:00 .. 11111111:10            3         11111111           2^7       1
</span></span><span class=line><span class=cl>    11   11111111:110                          1
</span></span><span class=line><span class=cl>    12   11111111:1110                         1
</span></span><span class=line><span class=cl>    13   11111111:11110                        1
</span></span><span class=line><span class=cl>    15   11111111:1111100 .. 11111111:1111111  4
</span></span></code></pre></div><p>In this case, the memory size of the Huffman table is 256 (1st table) + 2*119 + 4*8 + 128 = 654, which precisely matches the maximum value hardcoded.</p><p>However, if we construct an incomplete Huffman tree, containing a large number of long codes, the decoder will allocate second-level tables without bounds checking:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    Len  Code range                            #         Root entry         Overhead  #
</span></span><span class=line><span class=cl>    ---  ------------------------------------  ---       -----------------  --------  ---
</span></span><span class=line><span class=cl>    9    00000000:0                            1         00000000           2^7       1
</span></span><span class=line><span class=cl>    10   00000000:10                           1
</span></span><span class=line><span class=cl>    11   00000000:110                          1
</span></span><span class=line><span class=cl>    12   00000000:1110                         1
</span></span><span class=line><span class=cl>    13   00000000:11110                        1
</span></span><span class=line><span class=cl>    14   00000000:111110                       1
</span></span><span class=line><span class=cl>    15   00000000:1111110 .. 00000000:1111111  2
</span></span><span class=line><span class=cl>         00000001:0000000 .. 00000010:1111111  256       00000001-00000010  2^7       2
</span></span><span class=line><span class=cl>         00000011:0000000 .. 00000011:0001111  1         00000011           2^7       1
</span></span></code></pre></div><p>Under this circumstances, the memory size of the Huffman table should be 256 (1st table) + 128*4 = 768, which undoubtedly exceeds the hardcoded maximum size.</p><p>Subsequently, the decoder will call the <code>BuildHuffmanTable</code> function to build the Huffman table in the initially allocated memory space, writing the reversed prefix codes into memory through the <code>ReplicateValue</code> function. <strong>Since the number of allocated second-level tables exceeds expectations, out-of-bounds writing occurs, which may allow an attacker to execute arbitrary code</strong>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=c1>// Fill in 2nd level tables and add pointers to root table.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>len</span> <span class=o>=</span> <span class=n>root_bits</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>step</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>len</span> <span class=o>&lt;=</span> <span class=n>MAX_ALLOWED_CODE_LENGTH</span><span class=p>;</span>
</span></span><span class=line><span class=cl>         <span class=o>++</span><span class=n>len</span><span class=p>,</span> <span class=n>step</span> <span class=o>&lt;&lt;=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// ... snip ...
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>for</span> <span class=p>(;</span> <span class=n>count</span><span class=p>[</span><span class=n>len</span><span class=p>]</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>;</span> <span class=o>--</span><span class=n>count</span><span class=p>[</span><span class=n>len</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ... snip ...
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>code</span><span class=p>.</span><span class=n>bits</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span><span class=p>)(</span><span class=n>len</span> <span class=o>-</span> <span class=n>root_bits</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>code</span><span class=p>.</span><span class=n>value</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint16_t</span><span class=p>)</span><span class=n>sorted</span><span class=p>[</span><span class=n>symbol</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=nf>ReplicateValue</span><span class=p>(</span><span class=o>&amp;</span><span class=n>table</span><span class=p>[</span><span class=n>key</span> <span class=o>&gt;&gt;</span> <span class=n>root_bits</span><span class=p>],</span> <span class=n>step</span><span class=p>,</span> <span class=n>table_size</span><span class=p>,</span> <span class=n>code</span><span class=p>);</span> <span class=c1>// overflow here
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>key</span> <span class=o>=</span> <span class=nf>GetNextKey</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><h2 id=vulnerability-exploitation>Vulnerability Exploitation<a hidden class=anchor aria-hidden=true href=#vulnerability-exploitation>#</a></h2><h3 id=how-to-construct-a-poc-and-bypass-checks>How to construct a PoC and bypass checks?<a hidden class=anchor aria-hidden=true href=#how-to-construct-a-poc-and-bypass-checks>#</a></h3><p>It naturally occurred to us that, if we could directly construct a sufficiently large Huffman table, would it be possible to overflow the memory space allocated by the program?</p><p>The answer is no. Because <strong>the overflow length of a single Huffman table is limited</strong> and is not enough to cover the entire <code>huffman_tables</code>. Moreover, each time after constructing a Huffman table, the program will check the integrity of the Huffman tree, and an incomplete tree will cause the decoding process to be interrupted:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=c1>// Check if tree is full.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>num_nodes</span> <span class=o>!=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>offset</span><span class=p>[</span><span class=n>MAX_ALLOWED_CODE_LENGTH</span><span class=p>]</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>Therefore, a feasible method is to construct four normal Huffman tables corresponding to the green, red, blue and alpha channels, respectively, and ensure that they can reach their respective maximum allocation space under the condition of ensuring WebP image format compliance. Then, an incomplete Huffman tree is constructed in the distance channel, so that the cumulative size of all Huffman tables exceeds the predetermined memory capacity, resulting in memory overflow.</p><h3 id=how-to-trigger-a-crash>How to trigger a crash?<a hidden class=anchor aria-hidden=true href=#how-to-trigger-a-crash>#</a></h3><p>We found that although the PoC could trigger ASAN&rsquo;s error report or cause a crash of the <code>dwebp</code> tool with glibc, it does not affect mainstream browsers like Safari, Chrome, etc.</p><p>After some debugging, we discovered that the default size of the Huffman table is 2954 table entries, and the allocated space is 2954*4=11816 (0x2e28) bytes. However, in Chromium and WebKit, malloc(0x2e28) will eventually allocate 0x3000 bytes of memory space, while the overflow length of the sample is about 0x190 bytes, which means our overflow is not sufficient to cross the allocated memory boundary, therefore not triggering a crash.</p><p>Therefore, we need to make the size of the allocated Huffman table as close to 0x3000 as possible. How do we achieve this? In the vulnerability analysis section, we mentioned that the green channel space in <code>kTableSize</code> is variable-length and its size is affected by the color cache. If we set the size of the color cache to 6, the size of the Huffman table becomes (630 * 3 + 410 + 718) * 4 = 12072 = 0x2f28 bytes, allowing us to overwrite the content of the adjacent heap chunks.</p><h3 id=how-to-build-primitives>How to build primitives?<a hidden class=anchor aria-hidden=true href=#how-to-build-primitives>#</a></h3><p>In order to achieve controllable and stable heap out-of-bounds writes, we need to construct a powerful exploitation primitive, which needs to achieve the effect that <strong>the attacker can write controllable data at any specified heap offset.</strong></p><p>However, there are some difficulties in implementing both of these points in WebP vulnerabilities. On the one hand, the unit written by the Huffman table is HuffmanCode, in which only part of the data can be controlled by the attacker; on the other hand, HuffmanCode is not written into the Huffman table sequentially, and its index is calculated according to the rules of reverse Huffman coding, so it can not directly control the position of OOB writes.</p><h4 id=how-to-control-the-data-to-write>How to control the data to write?<a hidden class=anchor aria-hidden=true href=#how-to-control-the-data-to-write>#</a></h4><p>Let&rsquo;s first focus on the deconstruction of the written data. The Huffman table is actually an array containing multiple HuffmanCode, where each HuffmanCode is structured as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint8_t</span> <span class=n>bits</span><span class=p>;</span>     <span class=c1>// number of bits used for this symbol
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>uint16_t</span> <span class=n>value</span><span class=p>;</span>   <span class=c1>// symbol value or table offset
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>HuffmanCode</span><span class=p>;</span>
</span></span></code></pre></div><p>The memory layout of the structure is as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>| bits (1 byte) | padding (1 byte) | value (2 bytes) |
</span></span></code></pre></div><p>In this structure, the <code>bits</code> field represents the code length of the current HuffmanCode, and the <code>value</code> field represents the value. Each HuffmanCode occupies 4 bytes of memory. The range of <code>bits</code> is limited by the prefix code length, and its value range is [1, 15]; while <code>value</code> is the actual encoded data of the current HuffmanCode, which can be controlled by the attacker, and its range depends on the range of the encoded data, for example, for RGB color encoding, the range is [0, 255].</p><p>Since we are constructing the overflow sample in the distance channel, the number of coded symbols is 40, so we can write a 4-byte object, in which the 2 bytes of the high address is controllable, and the value range is [0,39].</p><h4 id=how-to-control-the-position-to-write>How to control the position to write?<a hidden class=anchor aria-hidden=true href=#how-to-control-the-position-to-write>#</a></h4><p>Reading the code, we find that HuffmanCode is written into memory in the <code>ReplicateValue</code> function, while the position of the write is calculated in the <code>GetNextKey</code> function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Returns reverse(reverse(key, len) + 1, len), where reverse(key, len) is the
</span></span></span><span class=line><span class=cl><span class=c1>// bit-wise reversal of the len least significant bits of key.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>WEBP_INLINE</span> <span class=kt>uint32_t</span> <span class=nf>GetNextKey</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>key</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint32_t</span> <span class=n>step</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>len</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=n>key</span> <span class=o>&amp;</span> <span class=n>step</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>step</span> <span class=o>&gt;&gt;=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>step</span> <span class=o>?</span> <span class=p>(</span><span class=n>key</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>step</span> <span class=o>-</span> <span class=mi>1</span><span class=p>))</span> <span class=o>+</span> <span class=nl>step</span> <span class=p>:</span> <span class=n>key</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>code</span><span class=p>.</span><span class=n>bits</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span><span class=p>)(</span><span class=n>len</span> <span class=o>-</span> <span class=n>root_bits</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>code</span><span class=p>.</span><span class=n>value</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint16_t</span><span class=p>)</span><span class=n>sorted</span><span class=p>[</span><span class=n>symbol</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=nf>ReplicateValue</span><span class=p>(</span><span class=o>&amp;</span><span class=n>table</span><span class=p>[</span><span class=n>key</span> <span class=o>&gt;&gt;</span> <span class=n>root_bits</span><span class=p>],</span> <span class=n>step</span><span class=p>,</span> <span class=n>table_size</span><span class=p>,</span> <span class=n>code</span><span class=p>);</span>
</span></span></code></pre></div><p>It can be seen that HuffmanCode is not written into the Huffman table sequentially; its index is obtained through reversed prefix code calculation. To control the index of the write, we calculated the index sequence of each HuffmanCode in the second-level Huffman table under a 15-bit prefix code length (encoding field is <code>2^(15-8)=128</code>):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>0x0 0x40 0x20 0x60 0x10 0x50 0x30 0x70 0x8 0x48 0x28 0x68 0x18 0x58 0x38 0x78
</span></span><span class=line><span class=cl>0x4 0x44 0x24 0x64 0x14 0x54 0x34 0x74 0xc 0x4c 0x2c 0x6c 0x1c 0x5c 0x3c 0x7c
</span></span><span class=line><span class=cl>0x2 0x42 0x22 0x62 0x12 0x52 0x32 0x72 0xa 0x4a 0x2a 0x6a 0x1a 0x5a 0x3a 0x7a
</span></span><span class=line><span class=cl>0x6 0x46 0x26 0x66 0x16 0x56 0x36 0x76 0xe 0x4e 0x2e 0x6e 0x1e 0x5e 0x3e 0x7e
</span></span><span class=line><span class=cl>0x1 0x41 0x21 0x61 0x11 0x51 0x31 0x71 0x9 0x49 0x29 0x69 0x19 0x59 0x39 0x79
</span></span><span class=line><span class=cl>0x5 0x45 0x25 0x65 0x15 0x55 0x35 0x75 0xd 0x4d 0x2d 0x6d 0x1d 0x5d 0x3d 0x7d
</span></span><span class=line><span class=cl>0x3 0x43 0x23 0x63 0x13 0x53 0x33 0x73 0xb 0x4b 0x2b 0x6b 0x1b 0x5b 0x3b 0x7b
</span></span><span class=line><span class=cl>0x7 0x47 0x27 0x67 0x17 0x57 0x37 0x77 0xf 0x4f 0x2f 0x6f 0x1f 0x5f 0x3f 0x7f
</span></span></code></pre></div><p>Our idea is: <strong>to construct four 15-bit encodings in the overflowed Huffman table, so that its fourth HuffmanCode is written to the index at 0x60, enabling it to cover the data of the next heap chunk. Additionally, we can construct multiple 9-bit encodings (where the size of the second-level Huffman table is 2), allowing this index to be adjusted in increments of 2, thereby achieving controllable index</strong>. As shown in the following figure:</p><img src=assets/3-exploit.png alt="exploit overview" style=display:block;margin-left:auto;margin-right:auto;zoom:50%><p>Therefore, we end up with the primitive effect that the <strong>attacker can write a partially controllable 4-byte data with a controllable offset in multiples of 8 bytes</strong>.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.darknavy.org/blog/exploiting_the_libwebp_vulnerability_part_2/><span class=title>« Prev</span><br><span>Exploiting the libwebp Vulnerability, Part 2: Diving into Chrome Blink</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.darknavy.org/>DARKNAVY</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>