<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How And Why We Hacked Cypherock Hardware Wallet: The Full Story | DARKNAVY</title><meta name=keywords content><meta name=description content="On blockchains, whoever controls the private key to an address controls the funds in the corresponding account.
In October 2025, the U.S. government announced the seizure of 127,000 BTC from Prince Group. On‑chain tracing reports indicated that these funds were in fact the assets stolen from the LuBian mining pool in December 2020.
A Bitcoin private key is a 256‑bit random number and is, in theory, infeasible to brute‑force. How did the U.S. government obtain LuBian&rsquo;s wallet private key?"><meta name=author content="DARKNAVY"><link rel=canonical href=https://www.darknavy.org/blog/how_and_why_we_hacked_cypherock_hardware_wallet_the_full_story/><link crossorigin=anonymous href=/assets/css/stylesheet.2613b1460fae4b99a98c033e33bde5e6a3af84ddb20236b732cefe33e3c0781e.css integrity="sha256-JhOxRg+uS5mpjAM+M73l5qOvhN2yAja3Ms7+M+PAeB4=" rel="preload stylesheet" as=style><link rel=icon href=https://www.darknavy.org/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.darknavy.org/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.darknavy.org/favicon-32x32.png><link rel=apple-touch-icon href=https://www.darknavy.org/apple-touch-icon.png><link rel=mask-icon href=https://www.darknavy.org/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.darknavy.org/blog/how_and_why_we_hacked_cypherock_hardware_wallet_the_full_story/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-LR4ZN1LSPS"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LR4ZN1LSPS")}</script><meta property="og:url" content="https://www.darknavy.org/blog/how_and_why_we_hacked_cypherock_hardware_wallet_the_full_story/"><meta property="og:site_name" content="DARKNAVY"><meta property="og:title" content="How And Why We Hacked Cypherock Hardware Wallet: The Full Story"><meta property="og:description" content="On blockchains, whoever controls the private key to an address controls the funds in the corresponding account.
In October 2025, the U.S. government announced the seizure of 127,000 BTC from Prince Group. On‑chain tracing reports indicated that these funds were in fact the assets stolen from the LuBian mining pool in December 2020.
A Bitcoin private key is a 256‑bit random number and is, in theory, infeasible to brute‑force. How did the U.S. government obtain LuBian’s wallet private key?"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-11-21T15:47:08+08:00"><meta property="article:modified_time" content="2025-11-21T15:47:08+08:00"><meta property="og:image" content="https://www.darknavy.org/blog/how_and_why_we_hacked_cypherock_hardware_wallet_the_full_story/attachments/e9a95181-18af-4ea9-ac8b-14d8fe8f6833.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.darknavy.org/blog/how_and_why_we_hacked_cypherock_hardware_wallet_the_full_story/attachments/e9a95181-18af-4ea9-ac8b-14d8fe8f6833.png"><meta name=twitter:title content="How And Why We Hacked Cypherock Hardware Wallet: The Full Story"><meta name=twitter:description content="On blockchains, whoever controls the private key to an address controls the funds in the corresponding account.
In October 2025, the U.S. government announced the seizure of 127,000 BTC from Prince Group. On‑chain tracing reports indicated that these funds were in fact the assets stolen from the LuBian mining pool in December 2020.
A Bitcoin private key is a 256‑bit random number and is, in theory, infeasible to brute‑force. How did the U.S. government obtain LuBian&rsquo;s wallet private key?"><meta name=twitter:site content="@DarkNavyOrg"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://www.darknavy.org/blog/"},{"@type":"ListItem","position":2,"name":"How And Why We Hacked Cypherock Hardware Wallet: The Full Story","item":"https://www.darknavy.org/blog/how_and_why_we_hacked_cypherock_hardware_wallet_the_full_story/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How And Why We Hacked Cypherock Hardware Wallet: The Full Story","name":"How And Why We Hacked Cypherock Hardware Wallet: The Full Story","description":"On blockchains, whoever controls the private key to an address controls the funds in the corresponding account.\nIn October 2025, the U.S. government announced the seizure of 127,000 BTC from Prince Group. On‑chain tracing reports indicated that these funds were in fact the assets stolen from the LuBian mining pool in December 2020.\nA Bitcoin private key is a 256‑bit random number and is, in theory, infeasible to brute‑force. How did the U.S. government obtain LuBian\u0026rsquo;s wallet private key?\n","keywords":[],"articleBody":"On blockchains, whoever controls the private key to an address controls the funds in the corresponding account.\nIn October 2025, the U.S. government announced the seizure of 127,000 BTC from Prince Group. On‑chain tracing reports indicated that these funds were in fact the assets stolen from the LuBian mining pool in December 2020.\nA Bitcoin private key is a 256‑bit random number and is, in theory, infeasible to brute‑force. How did the U.S. government obtain LuBian’s wallet private key?\nIn 2023, the Milk Sad research team discovered and disclosed a pseudo‑random number vulnerability in Libbitcoin Explorer (bx): bx used only a 32‑bit random number as a seed, and from this seed deterministically generated a 256‑bit “random” number. Such insecure randomness can be brute‑forced within hours, and LuBian’s wallet key generation suffered from the same issue.\nThe security threats to private keys do not end there. Beyond algorithmic flaws in software wallets themselves, the devices storing private keys are often online: system vulnerabilities, malicious plugins, phishing sites, remote‑control trojans, and other attack vectors can steal keys or signing authority without the user noticing.\nTo better protect private keys, hardware wallets emerged. By isolating private keys within a dedicated chip on an offline device, preventing direct exposure to the network, they are regarded as the “safe box” of digital assets.\nBut are hardware wallets truly absolutely secure?\nIn the March article If the Person Who Finds a Web3 Hardware Wallet is a Hacker, DARKNAVY already demonstrated an attack displaying “Hacked” on a Cypherock hardware wallet. However, merely displaying this text does not cause any real harm. Therefore, on stage at GEEKCON 2025, DARKNAVY showcased real‑world attacks on two hardware wallets. For Cypherock, we simulated a supply‑chain attack, tampering with the firmware, bypassing secure boot and device authenticity verification, and ultimately gaining control over newly generated mnemonic phrases.\nThis article outlines how DARKNAVY discovered multiple vulnerabilities and weaknesses in Cypherock and chained them together for exploitation.\nThe Unique Architecture The PIN code and mnemonic are the two most critical pieces of information in a hardware wallet; leakage of either may result in stolen funds. Therefore, many hardware wallets utilise a Secure Element (SE) to protect these secrets. Although the Cypherock X1 Vault has an ATECC608A secure element built in, this SE is only used for device authenticity checks.\nIn X1’s unique architecture, the mnemonic is split into 5 shares using Shamir’s Secret Sharing algorithm and stored across the wallet itself (X1 Vault) and 4 NFC cards. When a signature is needed, the private key can be reconstructed in the Vault using the Vault and any one of the NFC cards. PIN verification is also performed by the NFC cards.\nAll of the exploitation chain described here takes place on the X1 Vault MCU, and does not involve the SE or the cards.\nControl Flow Hijacking Whether via manual auditing or LLM‑based automated bug hunting, one can find numerous vulnerabilities in the open‑source firmware repository of the X1 Vault. For example, when the wallet selects an applet based on the applet_id in a USB packet, there is an out‑of‑bounds access which makes a function pointer controllable.\nconst cy_app_desc_t *registry_get_app_desc(uint32_t app_id) { return descriptors[app_id]; // OOB } void main_menu_host_interface(engine_ctx_t *ctx, usb_event_t usb_evt, const void *data) { uint32_t applet_id = get_applet_id(); const cy_app_desc_t *desc = registry_get_app_desc(applet_id); if (NULL != desc) { desc-\u003eapp(usb_evt, desc-\u003eapp_config); // ...... } Fixed firmware loading addresses, disabled Canary, and the absence of Execute‑Never protection allow any vulnerability to be easily converted into ROP or shellcode execution.\nThe Truth About Being “Open‑source” To research further exploitation methods, we turned to the logic of firmware upgrade and boot verification.\nAlthough Cypherock claims to be “fully open source”, only the “Application Firmware” is open source. The Bootloader and the Firewall Code Area, mentioned in the documentation, are not open source. They are designed to be non-upgradeable, so we cannot extract them from firmware update packages either. Crucially, the firmware verification logic resides within these two sections.\nWith a simple attempt we discovered that after hijacking the control flow, the Bootloader code segment can be directly read and sent to the computer via USB. However the Firewall Code (and Firewall Data Storage) cannot be read. By reverse‑engineering the Firewall initialisation logic within the Bootloader, we confirmed that the unreadable memory segment is indeed protected.\nFirewall is a hardware security feature provided by the STM32L4 series, implementing memory access isolation.\nSTM32L4 allows the user to define one protected region each for Code, Non‑Volatile Data, and Volatile Data; only instructions in the Firewall Code region may access the protected areas.\nIn addition, Firewall Code can only be called via a Call Gate; directly jumping into an address inside the protected region is treated as an illegal access.\nAs only the Firewall Code can read itself, we turned our attention to analysing the Firewall’s functionality in order to discover vulnerabilities.\nTearing Through The Firewall Protection The Firewall Call Gate entry is implemented as a function; the parameter task distinguishes functionality, along with two address pointers and their size.\nstatic uint32_t firewall_func(const uint32_t task, const uint8_t *data, const uint32_t size, const uint32_t address) The Application Firmware mostly uses the Firewall to read and write the Firewall‑protected NVDATA region. This region contains 4 pages:\nPrimary Bootloader Data: stores firmware version, firmware hash, device state, etc. Backup Bootloader Data: backup of the above information Permanent Key Storage: stores various device keys Secure Data Storage: stores wallet information, etc. For the first two pages, the Firewall exposes only limited, restricted read/write interfaces. For the last two pages, multiple tasks are provided for read/write, analogous to **memcpy**: the address parameter points into the protected region, while data points to external data. The Firewall code should have validated the ranges of both pointers and the read/write length, but testing showed that the WRITE functionality allows data to be any address. By setting **data** to point to the Firewall Code, we can copy (WRITE) the protected code into NVDATA, and then READ the NVDATA out.\nThere is one last small obstacle: WRITE is not a simple memory copy but a Flash write. Before repeatedly writing to the same address, the entire page must first be erased. To avoid corrupting valid NVDATA and bricking the device, we located a function that erases Secure Data Storage and then rewrites the latest full data. At this point, the remaining free space in this page can be safely used to dump Firewall Code.\nFragmented Upgrade Logic Having obtained full codes within the MCU, we can now truly analyse the firmware verification logic. Skipping the reverse‑engineering process, here is a summary of the firmware (Application Firmware) upgrade flow:\nThe Application Firmware sets BOOTSTATE to “upgrading” via the Firewall and then reboots the device.\nThe Bootloader enters the upgrade process, receives the firmware header from USB, then calls multiple Firewall tasks to:\na. Set BOOTSTATE to “in upgrade”.\nb. Verify the signature on the firmware header, then store the firmware version and size in Bootloader RAM.\nc. Store the firmware’s signature in Bootloader RAM.\nThe Bootloader receives the full firmware from USB page by page, erasing and writing the corresponding Flash regions.\nThe Bootloader again calls multiple Firewall tasks to:\nd. Hashing the current (newly-written) firmware, and verify it against the signature saved in step 1c.\ne. Hashing the current firmware again, and together with the firmware version and size saved in step 1b, write them into Primary Bootloader Data, and restore BOOTSTATE to the normal state.\nIf at any point the USB connection is interrupted or any verification fails, the device reboots immediately and re‑enters the upgrade process.\nNote that the upgrade flow has serious flaws: each Firewall task is independent and can be executed out of order (in particular, the two signature verifications in 1b and 1c); the firmware signature is never written to Flash, and on boot only integrity is checked, not authenticity.\nThus, after hijacking MCU control flow, we can directly erase and rewrite the firmware code and then call the Firewall task from 3e to calculate and store the current (malicious) firmware hash, achieving firmware tampering. As for the parameters saved after verification in step 1b that 3e relies on, we can simply modify them—attentive readers may have noticed that the Bootloader and Firewall Code share the same RAM, and the Firewall initialization code does not set any protection for the Volatile Data region.\nIllusory Authenticity Verification At GEEKCON, we simulated what an ordinary user might do when first receiving a newly purchased Cypherock wallet for “inspection”: the judge connected the wallet already compromised by the contestant to a computer and used Cypherock’s CySync software to perform a device authenticity check. Seconds later, this backdoored wallet passed the vendor’s check, with “verification passed” shown both on the computer and on the wallet screen.\nAccording to the vendor’s design, the first boot after flashing the wallet firmware should trigger a mandatory device authenticity check, and tampered firmware should not be able to pass this check. So how did we achieve the last step in the supply‑chain attack?\nCypherock’s authenticity verification process is shown in the diagram; the Vault’s SE finally comes into play: it uses a built‑in private key to sign twice—first over the device serial number, then over the XOR of a cloud‑generated nonce and the firmware hash. Once the cloud returns the verification result, the device saves the status.\nSince the second signature incorporates the firmware hash, and the client PC also submits the device’s firmware version, the cloud can determine whether the firmware hash is correct. However, the SE cannot directly read the firmware; what authenticity is there in a hash provided by malicious firmware?\nIn addition, this check is only unidirectional: the cloud verifies the device, but the device does not verify the cloud. If the goal is merely to bypass the device‑side check, the client can simply return “success” locally.\nThe Vendor’s Attitude Although Cypherock loudly boasts itself as the “Safest Hardware Wallet” and offers a public bug bounty program on its website, its attitude toward both users and security researchers can be summarised as silence is golden.\nIn March, DARKNAVY reported two vulnerabilities to Cypherock by email. They silently pushed patches to GitHub but did not even bother to send an acknowledgment. Coincidentally, at this year’s Hexacon, the session titled “Breaking the Vault: USB Bugs and Bug Bounty Failures” explicitly highlighted the experiences of peers reporting vulnerabilities to Cypherock.\nVulnerability fixes also lack transparency, leaving users entirely in the dark about the security state of their devices; when people ask about sessions on conferences, the vendor brushes them off with a perfunctory “already resolved long ago”.\nTherefore, for the Bootloader and Firewall vulnerabilities involved this time, we chained them to flash a custom firmware, replacing the boot logo and mnemonic display, just for amusement.\nVideo\nReferences [1] http://milksad.info/\n[2] https://github.com/Cypherock/x1_wallet_firmware\n","wordCount":"1808","inLanguage":"en","image":"https://www.darknavy.org/blog/how_and_why_we_hacked_cypherock_hardware_wallet_the_full_story/attachments/e9a95181-18af-4ea9-ac8b-14d8fe8f6833.png","datePublished":"2025-11-21T15:47:08+08:00","dateModified":"2025-11-21T15:47:08+08:00","author":{"@type":"Person","name":"DARKNAVY"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.darknavy.org/blog/how_and_why_we_hacked_cypherock_hardware_wallet_the_full_story/"},"publisher":{"@type":"Organization","name":"DARKNAVY","logo":{"@type":"ImageObject","url":"https://www.darknavy.org/images/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://www.darknavy.org/ accesskey=h title="  (Alt + H)"><img src=https://www.darknavy.org/images/darknavy_shenlan_dot.png alt aria-label=logo height=20></a><div class=logo-switches><ul class=lang-switch><li>|</li><li><a href=https://www.darknavy.org/zh/ title=Chinese aria-label=Chinese>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://www.darknavy.org/ title=Home><span>Home</span></a></li><li><a href=https://www.darknavy.org/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://www.darknavy.org/darknavy_insight/ title=Insight><span>Insight</span></a></li><li><a href=https://www.darknavy.org/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.darknavy.org/>Home</a>&nbsp;»&nbsp;<a href=https://www.darknavy.org/blog/>Blog</a></div><h1 class="post-title entry-hint-parent">How And Why We Hacked Cypherock Hardware Wallet: The Full Story</h1><div class=post-meta><span title='2025-11-21 15:47:08 +0800 CST'>November 21, 2025</span>&nbsp;·&nbsp;1808 words&nbsp;·&nbsp;DARKNAVY</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#the-unique-architecture>The Unique Architecture</a></li><li><a href=#control-flow-hijacking><strong>Control Flow Hijacking</strong></a></li><li><a href=#the-truth-about-being-opensource>The Truth About Being &ldquo;Open‑source&rdquo;</a></li><li><a href=#tearing-through-the-firewall-protection>Tearing Through The Firewall Protection</a></li><li><a href=#fragmented-upgrade-logic>Fragmented Upgrade Logic</a></li><li><a href=#illusory-authenticity-verification><strong>Illusory Authenticity Verification</strong></a></li><li><a href=#the-vendors-attitude>The Vendor&rsquo;s Attitude</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><p>On blockchains, whoever controls the private key to an address controls the funds in the corresponding account.</p><p>In October 2025, the U.S. government announced the seizure of <strong>127,000 BTC</strong> from Prince Group. On‑chain tracing reports indicated that these funds were in fact the assets stolen from the <em>LuBian</em> mining pool in December 2020.</p><p>A Bitcoin private key is a 256‑bit random number and is, in theory, infeasible to brute‑force. How did the U.S. government obtain <em>LuBian</em>&rsquo;s wallet private key?</p><p>In 2023, the Milk Sad research team discovered and disclosed a pseudo‑random number vulnerability in <strong>Libbitcoin Explorer (bx)</strong>: bx used only a <strong>32‑bit</strong> random number as a seed, and from this seed deterministically generated a 256‑bit &ldquo;random&rdquo; number. Such insecure randomness can be brute‑forced within hours, and LuBian&rsquo;s wallet key generation suffered from the same issue.</p><p>The security threats to private keys do not end there. Beyond algorithmic flaws in software wallets themselves, the devices storing private keys are often online: system vulnerabilities, malicious plugins, phishing sites, remote‑control trojans, and other attack vectors can steal keys or signing authority without the user noticing.</p><p>To better protect private keys, hardware wallets emerged. By isolating private keys within a dedicated chip on an offline device, preventing direct exposure to the network, they are regarded as the &ldquo;safe box&rdquo; of digital assets.</p><p>But are hardware wallets truly absolutely secure?</p><p>In the March article <em><a href=https://www.darknavy.org/blog/if_the_person_who_finds_a_web3_hardware_wallet_is_a_hacker/>If the Person Who Finds a Web3 Hardware Wallet is a Hacker</a></em>, DARKNAVY already demonstrated an attack displaying &ldquo;Hacked&rdquo; on a Cypherock hardware wallet. However, merely displaying this text does not cause any real harm. Therefore, on stage at <strong>GEEKCON 2025</strong>, DARKNAVY showcased real‑world attacks on two hardware wallets. For Cypherock, we simulated a supply‑chain attack, tampering with the firmware, bypassing secure boot and device authenticity verification, and ultimately gaining control over newly generated mnemonic phrases.</p><img src=attachments/e9a95181-18af-4ea9-ac8b-14d8fe8f6833.png style=display:block;margin-left:auto;margin-right:auto;zoom:100%><p>This article outlines how DARKNAVY discovered multiple vulnerabilities and weaknesses in Cypherock and chained them together for exploitation.</p><hr><h2 id=the-unique-architecture>The Unique Architecture<a hidden class=anchor aria-hidden=true href=#the-unique-architecture>#</a></h2><p>The PIN code and mnemonic are the two most critical pieces of information in a hardware wallet; leakage of either may result in stolen funds. Therefore, many hardware wallets utilise a Secure Element <em>(SE)</em> to protect these secrets. Although the Cypherock X1 Vault has an ATECC608A secure element built in, this SE is <strong>only used for device authenticity checks</strong>.</p><p>In X1&rsquo;s unique architecture, the mnemonic is split into 5 shares using <strong>Shamir&rsquo;s Secret Sharing</strong> algorithm and stored across the wallet itself <em>(X1 Vault)</em> and 4 NFC cards. When a signature is needed, the private key can be reconstructed in the Vault using the Vault and any one of the NFC cards. PIN verification is also performed by the NFC cards.</p><img src=attachments/faf96d44-402a-4386-910d-e687decc6b18.png style=display:block;margin-left:auto;margin-right:auto;zoom:100%><p>All of the exploitation chain described here takes place on the X1 Vault MCU, and does not involve the SE or the cards.</p><h2 id=control-flow-hijacking><strong>Control Flow Hijacking</strong><a hidden class=anchor aria-hidden=true href=#control-flow-hijacking>#</a></h2><p>Whether via manual auditing or <a href=https://www.darknavy.org/blog/argusee_a_multi_agent_collaborative_architecture_for_automated_vulnerability_discovery/>LLM‑based automated bug hunting</a>, one can find numerous vulnerabilities in the open‑source firmware repository of the X1 Vault. For example, when the wallet selects an applet based on the <code>applet_id</code> in a USB packet, there is an out‑of‑bounds access which makes a function pointer controllable.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=n>cy_app_desc_t</span> <span class=o>*</span><span class=nf>registry_get_app_desc</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>app_id</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>descriptors</span><span class=p>[</span><span class=n>app_id</span><span class=p>];</span>    <span class=c1>// OOB
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>main_menu_host_interface</span><span class=p>(</span><span class=n>engine_ctx_t</span> <span class=o>*</span><span class=n>ctx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                              <span class=n>usb_event_t</span> <span class=n>usb_evt</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                              <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint32_t</span> <span class=n>applet_id</span> <span class=o>=</span> <span class=n>get_applet_id</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>cy_app_desc_t</span> <span class=o>*</span><span class=n>desc</span> <span class=o>=</span> <span class=n>registry_get_app_desc</span><span class=p>(</span><span class=n>applet_id</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nb>NULL</span> <span class=o>!=</span> <span class=n>desc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>desc</span><span class=o>-&gt;</span><span class=n>app</span><span class=p>(</span><span class=n>usb_evt</span><span class=p>,</span> <span class=n>desc</span><span class=o>-&gt;</span><span class=n>app_config</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// ......
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>Fixed firmware loading addresses, disabled <strong>Canary</strong>, and the absence of <strong>Execute‑Never</strong> protection allow any vulnerability to be easily converted into <strong>ROP</strong> or <strong>shellcode execution</strong>.</p><h2 id=the-truth-about-being-opensource>The Truth About Being &ldquo;Open‑source&rdquo;<a hidden class=anchor aria-hidden=true href=#the-truth-about-being-opensource>#</a></h2><p>To research further exploitation methods, we turned to the logic of firmware upgrade and boot verification.</p><p>Although Cypherock claims to be &ldquo;fully open source&rdquo;, only the <strong>&ldquo;Application Firmware&rdquo;</strong> is open source. The <strong>Bootloader</strong> and the <strong>Firewall Code Area</strong>, mentioned in the documentation, are not open source. They are designed to be non-upgradeable, so we cannot extract them from firmware update packages either. Crucially, the firmware verification logic resides within these two sections.</p><img src=attachments/367a69af-b945-42c6-8a0f-3a7420e9bbac.png style=display:block;margin-left:auto;margin-right:auto;zoom:100%><p>With a simple attempt we discovered that after hijacking the control flow, the <strong>Bootloader code segment</strong> can be directly read and sent to the computer via USB. However the <strong>Firewall Code</strong> <em>(and Firewall Data Storage)</em> cannot be read. By reverse‑engineering the Firewall initialisation logic within the Bootloader, we confirmed that the unreadable memory segment is indeed protected.</p><blockquote><p>Firewall is a hardware security feature provided by the STM32L4 series, implementing memory access isolation.</p><p>STM32L4 allows the user to define one protected region each for Code, Non‑Volatile Data, and Volatile Data; only instructions in the Firewall Code region may access the protected areas.</p><p>In addition, Firewall Code can only be called via a Call Gate; directly jumping into an address inside the protected region is treated as an illegal access.</p></blockquote><img src=attachments/ca1a8b96-e766-4d9a-bdaf-7bc014e35bbe.png style=display:block;margin-left:auto;margin-right:auto;zoom:100%><p>As only the Firewall Code can read itself, we turned our attention to analysing the Firewall&rsquo;s functionality in order to discover vulnerabilities.</p><h2 id=tearing-through-the-firewall-protection>Tearing Through The Firewall Protection<a hidden class=anchor aria-hidden=true href=#tearing-through-the-firewall-protection>#</a></h2><p>The Firewall Call Gate entry is implemented as a function; the parameter <code>task</code> distinguishes functionality, along with two address pointers and their size.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=kt>uint32_t</span> <span class=n>firewall_func</span><span class=p>(</span><span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>task</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                              <span class=k>const</span> <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>data</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                              <span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>size</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                              <span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>address</span><span class=p>)</span>
</span></span></code></pre></div><p>The Application Firmware mostly uses the Firewall to read and write the Firewall‑protected <strong>NVDATA</strong> region. This region contains 4 pages:</p><ol><li>Primary Bootloader Data: stores firmware version, firmware hash, device state, etc.</li><li>Backup Bootloader Data: backup of the above information</li><li>Permanent Key Storage: stores various device keys</li><li>Secure Data Storage: stores wallet information, etc.</li></ol><p>For the first two pages, the Firewall exposes only limited, restricted read/write interfaces. For the last two pages, multiple tasks are provided for read/write, analogous to <code>**memcpy**</code>: the <code>address</code> parameter points into the protected region, while <code>data</code> points to external data. The Firewall code should have validated the ranges of both pointers and the read/write length, but testing showed that the <strong>WRITE</strong> functionality allows <code>data</code> to be any address. By setting <code>**data**</code> to point to the Firewall Code, we can copy (<strong>WRITE</strong>) the protected code into <strong>NVDATA</strong>, and then <strong>READ</strong> the <strong>NVDATA</strong> out.</p><p>There is one last small obstacle: <strong>WRITE</strong> is not a simple memory copy but a Flash write. Before repeatedly writing to the same address, the entire page must first be erased. To avoid corrupting valid NVDATA and bricking the device, we located a function that erases <strong>Secure Data Storage</strong> and then rewrites the latest full data. At this point, the remaining free space in this page can be safely used to dump Firewall Code.</p><h2 id=fragmented-upgrade-logic>Fragmented Upgrade Logic<a hidden class=anchor aria-hidden=true href=#fragmented-upgrade-logic>#</a></h2><p>Having obtained full codes within the MCU, we can now truly analyse the firmware verification logic. Skipping the reverse‑engineering process, here is a summary of the firmware (<em>Application Firmware</em>) upgrade flow:</p><ol start=0><li><p>The Application Firmware sets <code>BOOTSTATE</code> to &ldquo;upgrading&rdquo; via the Firewall and then reboots the device.</p></li><li><p>The Bootloader enters the upgrade process, receives the firmware header from USB, then calls multiple Firewall tasks to:</p><p>a. Set <code>BOOTSTATE</code> to &ldquo;in upgrade&rdquo;.</p><p>b. Verify the signature on the firmware header, then store the firmware version and size in Bootloader RAM.</p><p>c. Store the firmware&rsquo;s signature in Bootloader RAM.</p></li><li><p>The Bootloader receives the full firmware from USB page by page, erasing and writing the corresponding Flash regions.</p></li><li><p>The Bootloader again calls multiple Firewall tasks to:</p><p>d. Hashing the current (newly-written) firmware, and verify it against the signature saved in step 1c.</p><p>e. Hashing the current firmware again, and together with the firmware version and size saved in step 1b, write them into <strong>Primary Bootloader Data</strong>, and restore <code>BOOTSTATE</code> to the normal state.</p></li></ol><p>If at any point the USB connection is interrupted or any verification fails, the device reboots immediately and re‑enters the upgrade process.</p><p>Note that the upgrade flow has serious flaws: each Firewall task is independent and <strong>can be executed out of order</strong> (in particular, the two signature verifications in <strong>1b</strong> and <strong>1c</strong>); the firmware signature is never written to Flash, and on boot <strong>only integrity is checked, not authenticity</strong>.</p><p>Thus, after hijacking MCU control flow, we can directly erase and rewrite the firmware code and then call the Firewall task from <strong>3e</strong> to calculate and store the current (malicious) firmware hash, achieving firmware tampering. As for the parameters saved after verification in step <strong>1b</strong> that <strong>3e</strong> relies on, we can simply modify them—attentive readers may have noticed that the Bootloader and Firewall Code share the same RAM, and the Firewall initialization code does not set any protection for the Volatile Data region.</p><h2 id=illusory-authenticity-verification><strong>Illusory Authenticity Verification</strong><a hidden class=anchor aria-hidden=true href=#illusory-authenticity-verification>#</a></h2><p>At GEEKCON, we simulated what an ordinary user might do when first receiving a newly purchased Cypherock wallet for &ldquo;inspection&rdquo;: the judge connected the <strong>wallet already compromised by the contestant</strong> to a computer and used Cypherock&rsquo;s CySync software to perform a device authenticity check. Seconds later, this backdoored wallet passed the vendor&rsquo;s check, with &ldquo;verification passed&rdquo; shown both on the computer and on the wallet screen.</p><p>According to the vendor&rsquo;s design, the first boot after flashing the wallet firmware should trigger a mandatory device authenticity check, and tampered firmware should not be able to pass this check. So how did we achieve the last step in the supply‑chain attack?</p><p>Cypherock&rsquo;s authenticity verification process is shown in the diagram; the Vault&rsquo;s SE finally comes into play: it uses a built‑in private key to sign twice—first over the device serial number, then over the XOR of a cloud‑generated nonce and the firmware hash. Once the cloud returns the verification result, the device saves the status.</p><img src=attachments/83384a98-96c6-44c9-a2c5-c6db72b7b931.png style=display:block;margin-left:auto;margin-right:auto;zoom:100%><p>Since the second signature incorporates the firmware hash, and the client PC also submits the device&rsquo;s firmware version, the cloud can determine whether the firmware hash is correct. However, the SE cannot directly read the firmware; what authenticity is there in a hash provided by malicious firmware?</p><p>In addition, this check is only <strong>unidirectional</strong>: the cloud verifies the device, but the device does not verify the cloud. If the goal is merely to bypass the device‑side check, the client can simply return &ldquo;success&rdquo; locally.</p><h2 id=the-vendors-attitude>The Vendor&rsquo;s Attitude<a hidden class=anchor aria-hidden=true href=#the-vendors-attitude>#</a></h2><p>Although Cypherock loudly boasts itself as the &ldquo;Safest Hardware Wallet&rdquo; and offers a public bug bounty program on its website, its attitude toward both users and security researchers can be summarised as <strong>silence is golden</strong>.</p><p>In March, DARKNAVY reported two vulnerabilities to Cypherock by email. They silently pushed patches to GitHub but did not even bother to send an acknowledgment. Coincidentally, at this year&rsquo;s Hexacon, the session titled &ldquo;<strong>Breaking the Vault: USB Bugs and Bug Bounty Failures</strong>&rdquo; explicitly highlighted the experiences of peers reporting vulnerabilities to Cypherock.</p><p>Vulnerability fixes also lack transparency, leaving users entirely in the dark about the security state of their devices; when people ask about sessions on conferences, the vendor brushes them off with a perfunctory &ldquo;already resolved long ago&rdquo;.</p><p>Therefore, for the Bootloader and Firewall vulnerabilities involved this time, we chained them to flash a custom firmware, replacing the boot logo and mnemonic display, just for amusement.</p><p><a href=https://x.com/DarkNavyOrg/status/1967884894815854898>Video</a></p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p>[1] <a href=http://milksad.info/>http://milksad.info/</a></p><p>[2] <a href=https://github.com/Cypherock/x1_wallet_firmware>https://github.com/Cypherock/x1_wallet_firmware</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://www.darknavy.org/blog/argusee_a_multi_agent_collaborative_architecture_for_automated_vulnerability_discovery/><span class=title>Next »</span><br><span>Argusee: A Multi-Agent Collaborative Architecture for Automated Vulnerability Discovery</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.darknavy.org/>DARKNAVY</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>