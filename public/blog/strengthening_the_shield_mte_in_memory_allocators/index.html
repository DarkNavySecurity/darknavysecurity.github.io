<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Strengthening the Shield: MTE in Heap Allocators | DARKNAVY</title>
<meta name=keywords content><meta name=description content="Introduction In 2018, with the release of ARMv8.5-A, a brand new chip security feature MTE (Memory Tagging Extensions) emerged. Five years later, in 2023, the first smartphone to support this feature was released — Google Pixel 8 — marking the official entry of MTE into the consumer market. Although this feature is not yet enabled by default, developers can turn it on themselves for testing.
As a powerful defense against memory corruption, there has not yet been a comprehensive analysis of MTE&rsquo;s defensive boundaries, capabilities, and its impact on performance on the internet."><meta name=author content="DARKNAVY"><link rel=canonical href=https://www.darknavy.org/blog/strengthening_the_shield_mte_in_memory_allocators/><link crossorigin=anonymous href=/assets/css/stylesheet.38a584f0fc0f77186c8518d4117588a5b01cffe28707e993a6ae5cd5e2b0c5d0.css integrity="sha256-OKWE8PwPdxhshRjUEXWIpbAc/+KHB+mTpq5c1eKwxdA=" rel="preload stylesheet" as=style><link rel=icon href=https://www.darknavy.org/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.darknavy.org/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.darknavy.org/favicon-32x32.png><link rel=apple-touch-icon href=https://www.darknavy.org/apple-touch-icon.png><link rel=mask-icon href=https://www.darknavy.org/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.darknavy.org/blog/strengthening_the_shield_mte_in_memory_allocators/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-LR4ZN1LSPS"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LR4ZN1LSPS")}</script><meta property="og:title" content="Strengthening the Shield: MTE in Heap Allocators"><meta property="og:description" content="Introduction In 2018, with the release of ARMv8.5-A, a brand new chip security feature MTE (Memory Tagging Extensions) emerged. Five years later, in 2023, the first smartphone to support this feature was released — Google Pixel 8 — marking the official entry of MTE into the consumer market. Although this feature is not yet enabled by default, developers can turn it on themselves for testing.
As a powerful defense against memory corruption, there has not yet been a comprehensive analysis of MTE&rsquo;s defensive boundaries, capabilities, and its impact on performance on the internet."><meta property="og:type" content="article"><meta property="og:url" content="https://www.darknavy.org/blog/strengthening_the_shield_mte_in_memory_allocators/"><meta property="og:image" content="https://www.darknavy.org/images/white_logo.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-01-03T16:19:13+08:00"><meta property="article:modified_time" content="2024-01-03T16:19:13+08:00"><meta property="og:site_name" content="DARKNAVY"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.darknavy.org/images/white_logo.png"><meta name=twitter:title content="Strengthening the Shield: MTE in Heap Allocators"><meta name=twitter:description content="Introduction In 2018, with the release of ARMv8.5-A, a brand new chip security feature MTE (Memory Tagging Extensions) emerged. Five years later, in 2023, the first smartphone to support this feature was released — Google Pixel 8 — marking the official entry of MTE into the consumer market. Although this feature is not yet enabled by default, developers can turn it on themselves for testing.
As a powerful defense against memory corruption, there has not yet been a comprehensive analysis of MTE&rsquo;s defensive boundaries, capabilities, and its impact on performance on the internet."><meta name=twitter:site content="@DarkNavyOrg"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://www.darknavy.org/blog/"},{"@type":"ListItem","position":2,"name":"Strengthening the Shield: MTE in Heap Allocators","item":"https://www.darknavy.org/blog/strengthening_the_shield_mte_in_memory_allocators/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Strengthening the Shield: MTE in Heap Allocators","name":"Strengthening the Shield: MTE in Heap Allocators","description":"Introduction In 2018, with the release of ARMv8.5-A, a brand new chip security feature MTE (Memory Tagging Extensions) emerged. Five years later, in 2023, the first smartphone to support this feature was released — Google Pixel 8 — marking the official entry of MTE into the consumer market. Although this feature is not yet enabled by default, developers can turn it on themselves for testing.\nAs a powerful defense against memory corruption, there has not yet been a comprehensive analysis of MTE\u0026rsquo;s defensive boundaries, capabilities, and its impact on performance on the internet.","keywords":[],"articleBody":"Introduction In 2018, with the release of ARMv8.5-A, a brand new chip security feature MTE (Memory Tagging Extensions) emerged. Five years later, in 2023, the first smartphone to support this feature was released — Google Pixel 8 — marking the official entry of MTE into the consumer market. Although this feature is not yet enabled by default, developers can turn it on themselves for testing.\nAs a powerful defense against memory corruption, there has not yet been a comprehensive analysis of MTE’s defensive boundaries, capabilities, and its impact on performance on the internet. Previously, Google Project Zero published a series of articles about MTE, focusing on the more low-level security aspects of MTE. However, the actual impact of MTE on real software security remains a mystery. To discuss this topic, heap allocators provide an excellent starting point. Heap memory corruption issues have gradually become the mainstream type of binary vulnerabilities. For reference, see the presentation by MSRC at CppCon 2019:\nOrdinary developers usually do not directly use MTE-related assembly instructions, but instead rely on the MTE support provided indirectly by heap allocators. Heap allocators act like shields, taking on the task of protecting the software. MTE provides fundamental support for fine-grained memory control. The responsibility of implementing advanced security features based on hardware MTE capabilities is left to software developers. The mainstream heap allocators in the open-source community have responded actively, implementing security enhancements based on MTE features, thereby improving the memory safety of heap space.\nThis article will target the three main players of MTE: PartitionAlloc in Chrome, Ptmalloc in Glibc, and Scudo in Android, to discuss and compare their respective MTE implementations. In our research, we found issues with the implementation in PartitionAlloc and reported them to Google, which were confirmed by the Chrome team.\nMTE Overview Readers who are already familiar with the principles of MTE may skip this section.\nMTE utilizes the TBI (Top-Byte Ignore) feature of ARMv8, using the high 4 bits of a pointer to store a tag. In each process, there is a dedicated map of memory for storing these tags. Once a specific tag is assigned to a memory, the program must access the memory with the correct tag; if the tag is incorrect, the program throws the error signal SIGSEGV, as shown below:\nThe instruction set provides a series of instructions for tag manipulation. Here is an example demonstrating the basic usage of MTE:\n; x0 is a pointer irg x1, x0 stg x1, [x1] ldr x0, [x1] The IRG (Insert Random Tag) instruction generates a random tag for the pointer x0 and stores the result in x1. The STG (Store Allocation Tag) instruction applies the tag to the memory, with the effective length depending on the granularity, which is generally 16 bytes. The LDR (Load Register) instruction reads memory using the pointer with right tag. The instruction set provides underlying support, but there is a great deal of freedom in the use of each instruction. How MTE is specifically utilized still largely depends on software developers.\nAllocator Chrome - PartitionAlloc Allocation Allocations in PartitionAlloc can be roughly divided into three cases:\nAllocation from ThreadCache, return directly without changing the tag. Allocation from a free SlotSpan, return directly without changing the tag. If neither of the above two conditions is met, allocate a new SlotSpan and tag all the free heap slots within it with random tags. if (PA_LIKELY(use_tagging)) { // Ensure the MTE-tag of the memory pointed by other provisioned slot is // unguessable. They will be returned to the app as is, and the MTE-tag // will only change upon calling Free(). next_slot_ptr = TagMemoryRangeRandomly(next_slot, TagSizeForSlot(root, slot_size)); Release Increment the tag of the slot to be freed.\nvoid* retagged_slot_start = internal::TagMemoryRangeIncrement( ObjectToTaggedSlotStart(object), tag_size); // Incrementing the MTE-tag in the memory range invalidates the |object|'s // tag, so it must be retagged. object = TaggedSlotStartToObject(retagged_slot_start); (Past) Potential Risks We have noticed that the operation of incrementing the tag upon release is a deterministic behavior, and it‘s very likely that the tag will not be changed during allocation. These two points make the tag management in PartitionAlloc quite fragile, providing attackers with chances to abuse.\nSuppose an attacker now has a UAF vulnerability and can freely control the timing of triggering this UAF (which is common in actual exploits). Then the attacker can bypass the MTE check by the following means:\nTrigger the vulnerability to obtain a UAF object victim, but do not trigger the UAF at this time. Continuously allocate and free an object of the victim’s size 15 times, so that the tag of the object controlled by the attacker is the same as the victim’s tag. Trigger the UAF. In actual attack scenarios, it is easy for an attacker to have the two exploitation primitives required for the above attack:\nAllocate heap slots of a certain size any number of times and control their contents. Be able to free the heap slots they have allocated. For example, in the browser process, using the Blob object can achieve the above two points. In the renderer process, using AudioArray can also do it.\nMore detailed report and example PoC are available at Issue 1512538.\nAnalysis The MTE support in PartitionAlloc is not as powerful as we imagined. It manages tags to a lesser extent, prioritizing efficiency to the greatest degree. Detailed comparisons are provided in the following section.\nGlibc - Ptmalloc The implementation in Ptmalloc is the most straightforward and rudimentary. Its strategy is so simple that it can be summarized in just a few sentences.\nAllocation For all allocations, after obtaining the allocation address, a random non-zero tag is generated to mark the entire allocated chunk (the actual logic in the code is to generate a tag value that is different from the chunk header. In the version 2.38 we analyzed, the memory managed by libc such as chunk headers has a fixed tag value of 0. This particular point will not be further specified in the rest of this article).\nvictim = tcache_get (tc_idx); return tag_new_usable (victim); // ... victim = _int_malloc (ar_ptr, bytes); // ... victim = tag_new_usable (victim); Release Set the tag of the chunk to 0.\n/* Mark the chunk as belonging to the library again. */ (void)tag_region (chunk2mem (p), memsize (p)); ar_ptr = arena_for_chunk (p); _int_free (ar_ptr, p, 0); Analysis For such an allocation strategy, there is a sense of overwhelming force with a single move. In the balance between performance and security, Glibc has chosen security: no matter the size of the allocation or the source of the allocation (tcache, fastbin, smallbin…), it will be re-tagged with a random tag.\nThe memory managed by libc itself, such as chunk headers, freed chunks, and the top chunk, all use 0 as the tag. At first glance, a fixed tag of 0 seems very insecure, as it is information known to the attacker. However, upon closer examination, it is apparent that this is not the case. This mechanism ensures at least the following two points:\nThere is definitely a chunk header or a free chunk (tag 0) acting as a barrier between every two chunks (tag non-zero), playing a role similar to a Guard Page, which can effectively mitigate linear overflows. The tag of a freed chunk (tag 0) is always different from that of a chunk in use (tag non-zero), which can effectively mitigate UAF vulnerabilities. Android - Scudo In comparison, the implementation in Scudo is the most complex.\nAllocation Scudo only tags chunks of the Primary type (size \u003c 0x10000). For the larger Secondary type, it allocates space through memory mapping, and currently does not support tagging such spaces. When Scudo reuses a freed chunk, it directly retains and uses the UAF tag assigned to it at the time of release. Otherwise, it will allocate a random tag. Release Assign a random tag different from the previous one to the chunk to prevent UAF reusing it.\nif (Header-\u003eClassId) { if (!TSDRegistry.getDisableMemInit()) { uptr TaggedBegin, TaggedEnd; const uptr OddEvenMask = computeOddEvenMaskForPointerMaybe( Options, reinterpret_cast\u003cuptr\u003e(getBlockBegin(Ptr, Header)), Header-\u003eClassId); // Exclude the previous tag so that immediate use after free is // detected 100% of the time. setRandomTag(Ptr, Size, OddEvenMask | (1UL \u003c\u003c PrevTag), \u0026TaggedBegin, \u0026TaggedEnd); } } Analysis In Scudo’s implementation, there is a unique configuration option: UseOddEvenTags. When this option is activated, Scudo takes into special consideration the parity of the tags for each chunk during the memory allocation process. This means that it ensures that the parities of the tags for adjacent heap chunks are different.\nTo achieve this functionality, computeOddEvenMaskForPointerMaybe is used to calculate the odd-even tag mask:\nuptr computeOddEvenMaskForPointerMaybe(const Options \u0026Options, uptr Ptr, uptr ClassId) { if (!Options.get(OptionBit::UseOddEvenTags)) return 0; // If a chunk's tag is odd, we want the tags of the surrounding blocks to be // even, and vice versa. Blocks are laid out Size bytes apart, and adding // Size to Ptr will flip the least significant set bit of Size in Ptr, so // that bit will have the pattern 010101... for consecutive blocks, which we // can use to determine which tag mask to use. return 0x5555U \u003c\u003c ((Ptr \u003e\u003e SizeClassMap::getSizeLSBByClassId(ClassId)) \u0026 1); } This configuration involves a trade-off between UAF detection and buffer overflow detection. When UseOddEvenTags is enabled, the parity of the tags for adjacent chunks is different, which eliminates the possibility that randomly allocated tags happen to be the same, thereby increasing the likelihood of detecting buffer overflows. However, on the other hand, in this case, the parity of every randomly allocated tag is fixed, which leads to a halving of the tag space, making UAF more difficult to detect.\nThis design highlights a key consideration in Scudo’s implementation: how to balance mitigation strategies for different types of memory vulnerabilities while minimizing performance impact. It demonstrates the preferences and trade-offs that a heap allocator makes when dealing with memory safety.\nComparison Disclaimer: This table only compares the implementation of MTE in various heap allocators and does not represent the overall security of the heap allocators.\nMax Chunk Size with Tags\nPtmalloc applies tags to heap chunks of any size. However, for performance reasons, Scudo and PartitionAlloc only protect heap chunks smaller than 0x10000 and 0x400, respectively.\nMemory Corruption Defense Capabilities\nLinear Overflow\nBoth Ptmalloc and Scudo use 0 as the tag for chunk headers, ensuring there is always a red zone between two heap chunks that can effectively mitigate linear overflows; Whereas PartitionAlloc’s metadata is not at the start of the heap chunk, thus there is a certain probability that adjacent heap chunks may coincidentally have the same tag.\nNon-linear OOB\nFor non-linear out-of-bounds access, the parity of Scudo’s tags ensures that adjacent heap chunks will definitely have different tags, thereby increasing the size of the red zone around the heap chunk, making small-scale OOB more likely to be detected.\nUAF\nThe potential risks of UAF vulnerabilities in PartitionAlloc have been detailed in the above sections. It should be additionally noted that PartitionAlloc does not rely solely on MTE to defend against UAF vulnerabilities. It also has very strong UAF defense capabilities thanks to MiraclePtr; When Scudo enables tag parity, the tag space is halved, increasing the probability of tag collisions.\nUninitialized Memory\nMTE does not significantly improve issues with uninitialized memory. Allocators like PartitionAlloc and Ptmalloc do not perform memory initialization.\nTag Management Strategy\nThe allocation and release of heap chunks are evaluated as a whole here. PartitionAlloc does not regenerate a new tag when reusing a heap chunk from the cache but continues to use the old tag, and only increments the tag upon release; The other two allocators regenerate tags.\nProtection of Metadata\nNeither Ptmalloc nor Scudo use tags to protect metadata such as chunk headers, with the default tag being 0, which can serve as a gap between adjacent heap chunks but at the same time may be at risk of malicious tampering. Notably, PartitionAlloc’s metadata is not stored at the start of the heap chunk, making it less susceptible to corruption.\nFree an Address with Incorrect Tag\nWhen releasing a heap chunk, PartitionAlloc and Scudo do not check the correctness of the tag but perform an untag operation directly, thus allowing the release of an address with an incorrect tag. However, the attack scenarios resulting from this flaw are limited and would need to be combined with other attack methods to be exploited, so we do not classify this as a high-risk issue; Ptmalloc, on the other hand, checks if the tag is correct and will raise an exception if it is not.\n/* Quickly check that the freed pointer matches the tag for the memory. This gives a useful double-free detection. */ if (__glibc_unlikely (mtag_enabled)) *(volatile char *)mem; Conclusions This article provides a detailed analysis of the implementation of MTE in the three major heap allocators, giving readers an intuitive understanding of their security. MTE is undoubtedly a significant leap forward for memory safety on the ARM platform. It is evident that with MTE enabled, traditional heap memory corruption issues are effectively mitigated, with some even becoming infeasible to exploit. However, memory safety has evolved over many years and is fraught with complex issues, with many open questions still to be resolved:\nDefense against uninitialized memory still relies on software implementation. Whether stack variables will be fortified with MTE and whether performance considerations might hinder its implementation. Tagging mmapped memory lacks support at the kernel level. Large memory buffers, such as ring buffers and shared memory, are difficult to effectively protect with MTE. The data segment of programs is not protected by MTE. The evolution of offense and defense has led attackers from being able to compromise systems with a single stack overflow years ago to now needing a chain of vulnerabilities to break through the layered defenses of systems, reversing the offensive and defensive situation. But we also see that even advanced technologies like MTE have blind spots, and the road to memory safety is still long and challenging. We look forward to more exciting developments in the future.\n","wordCount":"2341","inLanguage":"en","image":"https://www.darknavy.org/images/white_logo.png","datePublished":"2024-01-03T16:19:13+08:00","dateModified":"2024-01-03T16:19:13+08:00","author":{"@type":"Person","name":"DARKNAVY"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.darknavy.org/blog/strengthening_the_shield_mte_in_memory_allocators/"},"publisher":{"@type":"Organization","name":"DARKNAVY","logo":{"@type":"ImageObject","url":"https://www.darknavy.org/images/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://www.darknavy.org/ accesskey=h title="  (Alt + H)"><img src=https://www.darknavy.org/images/darknavy_shenlan_dot.png alt aria-label=logo height=20></a><div class=logo-switches></div></div><ul id=menu><li><a href=https://www.darknavy.org/ title=Home><span>Home</span></a></li><li><a href=https://www.darknavy.org/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://www.darknavy.org/blog_cn/ title=BlogCN><span>BlogCN</span></a></li><li><a href=https://www.darknavy.org/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.darknavy.org/>Home</a>&nbsp;»&nbsp;<a href=https://www.darknavy.org/blog/>Blog</a></div><h1 class="post-title entry-hint-parent">Strengthening the Shield: MTE in Heap Allocators</h1><div class=post-meta><span title='2024-01-03 16:19:13 +0800 CST'>January 3, 2024</span>&nbsp;·&nbsp;2341 words&nbsp;·&nbsp;DARKNAVY</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#chrome---partitionalloc>Chrome - PartitionAlloc</a><ul><li><a href=#allocation>Allocation</a></li><li><a href=#release>Release</a></li><li><a href=#past-potential-risks>(Past) Potential Risks</a></li><li><a href=#analysis>Analysis</a></li></ul></li><li><a href=#glibc---ptmalloc>Glibc - Ptmalloc</a><ul><li><a href=#allocation-1>Allocation</a></li><li><a href=#release-1>Release</a></li><li><a href=#analysis-1>Analysis</a></li></ul></li><li><a href=#android---scudo>Android - Scudo</a><ul><li><a href=#allocation-2>Allocation</a></li><li><a href=#release-2>Release</a></li><li><a href=#analysis-2>Analysis</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h1><p>In 2018, with the release of ARMv8.5-A, a brand new chip security feature <a href=https://developer.arm.com/-/media/Arm%20Developer%20Community/PDF/Arm_Memory_Tagging_Extension_Whitepaper.pdf>MTE</a> (Memory Tagging Extensions) emerged. Five years later, in 2023, the first smartphone to support this feature was released — <a href=https://blog.google/products/pixel/google-pixel-8-pro/>Google Pixel 8</a> — marking the official entry of MTE into the consumer market. Although this feature is not yet enabled by default, developers can <a href=https://googleprojectzero.blogspot.com/2023/11/first-handset-with-mte-on-market.html>turn it on</a> themselves for testing.</p><p>As a powerful defense against memory corruption, there has not yet been a comprehensive analysis of MTE&rsquo;s defensive boundaries, capabilities, and its impact on performance on the internet. Previously, Google Project Zero published a series of <a href=https://googleprojectzero.blogspot.com/2023/08/mte-as-implemented-part-1.html>articles about MTE</a>, focusing on the more low-level security aspects of MTE. However, the actual impact of MTE on real software security remains a mystery. To discuss this topic, heap allocators provide an excellent starting point. Heap memory corruption issues have gradually become the mainstream type of binary vulnerabilities. For reference, see the <a href=https://github.com/microsoft/MSRC-Security-Research/blob/master/presentations/2019_09_CppCon/CppCon2019%20-%20Killing%20Uninitialized%20Memory.pdf>presentation</a> by MSRC at CppCon 2019:</p><p><img loading=lazy src=assets/3.png alt=3></p><p>Ordinary developers usually do not directly use MTE-related assembly instructions, but instead rely on the MTE support provided indirectly by heap allocators. Heap allocators act like shields, taking on the task of protecting the software. MTE provides fundamental support for fine-grained memory control. The responsibility of implementing advanced security features based on hardware MTE capabilities is left to software developers. The mainstream heap allocators in the open-source community have responded actively, implementing security enhancements based on MTE features, thereby improving the memory safety of heap space.</p><p>This article will target the three main players of MTE: PartitionAlloc in Chrome, Ptmalloc in Glibc, and Scudo in Android, to discuss and compare their respective MTE implementations. In our research, we found issues with the implementation in PartitionAlloc and reported them to Google, which were confirmed by the Chrome team.</p><h1 id=mte-overview>MTE Overview<a hidden class=anchor aria-hidden=true href=#mte-overview>#</a></h1><blockquote><p>Readers who are already familiar with the principles of MTE may skip this section.</p></blockquote><p>MTE utilizes the TBI (Top-Byte Ignore) feature of ARMv8, using the high 4 bits of a pointer to store a tag. In each process, there is a dedicated map of memory for storing these tags. Once a specific tag is assigned to a memory, the program must access the memory with the correct tag; if the tag is incorrect, the program throws the error signal SIGSEGV, as shown below:</p><img src=assets/2.png style=display:block;margin-left:auto;margin-right:auto;zoom:50%><p>The instruction set provides a series of instructions for tag manipulation. Here is an example demonstrating the basic usage of MTE:</p><pre tabindex=0><code class=language-assembly data-lang=assembly>; x0 is a pointer
irg  x1, x0
stg  x1, [x1]
ldr  x0, [x1]
</code></pre><ol><li>The IRG (Insert Random Tag) instruction generates a random tag for the pointer x0 and stores the result in x1.</li><li>The STG (Store Allocation Tag) instruction applies the tag to the memory, with the effective length depending on the granularity, which is generally 16 bytes.</li><li>The LDR (Load Register) instruction reads memory using the pointer with right tag.</li></ol><p>The instruction set provides underlying support, but there is a great deal of freedom in the use of each instruction. How MTE is specifically utilized still largely depends on software developers.</p><h1 id=allocator>Allocator<a hidden class=anchor aria-hidden=true href=#allocator>#</a></h1><h2 id=chrome---partitionalloc>Chrome - PartitionAlloc<a hidden class=anchor aria-hidden=true href=#chrome---partitionalloc>#</a></h2><h3 id=allocation>Allocation<a hidden class=anchor aria-hidden=true href=#allocation>#</a></h3><p>Allocations in PartitionAlloc can be roughly divided into three cases:</p><ol><li>Allocation from ThreadCache, return directly without changing the tag.</li><li>Allocation from a free SlotSpan, return directly without changing the tag.</li><li>If neither of the above two conditions is met, allocate a new SlotSpan and tag all the free heap slots within it with random tags.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>PA_LIKELY</span><span class=p>(</span><span class=n>use_tagging</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Ensure the MTE-tag of the memory pointed by other provisioned slot is
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// unguessable. They will be returned to the app as is, and the MTE-tag
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// will only change upon calling Free().
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>next_slot_ptr</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>          <span class=n>TagMemoryRangeRandomly</span><span class=p>(</span><span class=n>next_slot</span><span class=p>,</span> <span class=n>TagSizeForSlot</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>slot_size</span><span class=p>));</span>
</span></span></code></pre></div><h3 id=release>Release<a hidden class=anchor aria-hidden=true href=#release>#</a></h3><p>Increment the tag of the slot to be freed.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>      <span class=kt>void</span><span class=o>*</span> <span class=n>retagged_slot_start</span> <span class=o>=</span> <span class=n>internal</span><span class=o>::</span><span class=n>TagMemoryRangeIncrement</span><span class=p>(</span>
</span></span><span class=line><span class=cl>          <span class=n>ObjectToTaggedSlotStart</span><span class=p>(</span><span class=n>object</span><span class=p>),</span> <span class=n>tag_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Incrementing the MTE-tag in the memory range invalidates the |object|&#39;s
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// tag, so it must be retagged.
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>object</span> <span class=o>=</span> <span class=n>TaggedSlotStartToObject</span><span class=p>(</span><span class=n>retagged_slot_start</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=past-potential-risks>(Past) Potential Risks<a hidden class=anchor aria-hidden=true href=#past-potential-risks>#</a></h3><p>We have noticed that the operation of incrementing the tag upon release is a deterministic behavior, and it‘s very likely that the tag will not be changed during allocation. These two points make the tag management in PartitionAlloc quite fragile, providing attackers with chances to abuse.</p><p>Suppose an attacker now has a UAF vulnerability and can freely control the timing of triggering this UAF (which is common in actual exploits). Then the attacker can bypass the MTE check by the following means:</p><ol><li>Trigger the vulnerability to obtain a UAF object victim, but do not trigger the UAF at this time.</li><li>Continuously allocate and free an object of the victim&rsquo;s size 15 times, so that the tag of the object controlled by the attacker is the same as the victim&rsquo;s tag.</li><li>Trigger the UAF.</li></ol><p>In actual attack scenarios, it is easy for an attacker to have the two exploitation primitives required for the above attack:</p><ol><li>Allocate heap slots of a certain size any number of times and control their contents.</li><li>Be able to free the heap slots they have allocated.</li></ol><p>For example, in the browser process, using the <a href=https://googleprojectzero.blogspot.com/2019/04/virtually-unlimited-memory-escaping.html>Blob</a> object can achieve the above two points. In the renderer process, using <a href=https://securitylab.github.com/research/one_day_short_of_a_fullchain_renderer/>AudioArray</a> can also do it.</p><p>More detailed report and example PoC are available at <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1512538">Issue 1512538</a>.</p><h3 id=analysis>Analysis<a hidden class=anchor aria-hidden=true href=#analysis>#</a></h3><p>The MTE support in PartitionAlloc is not as powerful as we imagined. It manages tags to a lesser extent, prioritizing efficiency to the greatest degree. Detailed comparisons are provided in the following section.</p><h2 id=glibc---ptmalloc>Glibc - Ptmalloc<a hidden class=anchor aria-hidden=true href=#glibc---ptmalloc>#</a></h2><p>The implementation in Ptmalloc is the most straightforward and rudimentary. Its strategy is so simple that it can be summarized in just a few sentences.</p><h3 id=allocation-1>Allocation<a hidden class=anchor aria-hidden=true href=#allocation-1>#</a></h3><p>For all allocations, after obtaining the allocation address, a random non-zero tag is generated to mark the entire allocated chunk (the actual logic in the code is to generate a tag value that is different from the chunk header. In the version 2.38 we analyzed, the memory managed by libc such as chunk headers has a fixed tag value of 0. This particular point will not be further specified in the rest of this article).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>      <span class=n>victim</span> <span class=o>=</span> <span class=nf>tcache_get</span> <span class=p>(</span><span class=n>tc_idx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nf>tag_new_usable</span> <span class=p>(</span><span class=n>victim</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>victim</span> <span class=o>=</span> <span class=nf>_int_malloc</span> <span class=p>(</span><span class=n>ar_ptr</span><span class=p>,</span> <span class=n>bytes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>victim</span> <span class=o>=</span> <span class=nf>tag_new_usable</span> <span class=p>(</span><span class=n>victim</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=release-1>Release<a hidden class=anchor aria-hidden=true href=#release-1>#</a></h3><p>Set the tag of the chunk to 0.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>      <span class=cm>/* Mark the chunk as belonging to the library again.  */</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>tag_region</span> <span class=p>(</span><span class=nf>chunk2mem</span> <span class=p>(</span><span class=n>p</span><span class=p>),</span> <span class=nf>memsize</span> <span class=p>(</span><span class=n>p</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=n>ar_ptr</span> <span class=o>=</span> <span class=nf>arena_for_chunk</span> <span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=nf>_int_free</span> <span class=p>(</span><span class=n>ar_ptr</span><span class=p>,</span> <span class=n>p</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=analysis-1>Analysis<a hidden class=anchor aria-hidden=true href=#analysis-1>#</a></h3><p>For such an allocation strategy, there is a sense of overwhelming force with a single move. In the balance between performance and security, Glibc has chosen security: no matter the size of the allocation or the source of the allocation (tcache, fastbin, smallbin&mldr;), it will be re-tagged with a random tag.</p><p>The memory managed by libc itself, such as chunk headers, freed chunks, and the top chunk, all use 0 as the tag. At first glance, a fixed tag of 0 seems very insecure, as it is information known to the attacker. However, upon closer examination, it is apparent that this is not the case. This mechanism ensures at least the following two points:</p><ol><li>There is definitely a chunk header or a free chunk (tag 0) acting as a barrier between every two chunks (tag non-zero), playing a role similar to a Guard Page, which can effectively mitigate linear overflows.</li><li>The tag of a freed chunk (tag 0) is always different from that of a chunk in use (tag non-zero), which can effectively mitigate UAF vulnerabilities.</li></ol><h2 id=android---scudo>Android - Scudo<a hidden class=anchor aria-hidden=true href=#android---scudo>#</a></h2><p>In comparison, the implementation in Scudo is the most complex.</p><h3 id=allocation-2>Allocation<a hidden class=anchor aria-hidden=true href=#allocation-2>#</a></h3><ol><li>Scudo only tags chunks of the Primary type (size &lt; 0x10000). For the larger Secondary type, it allocates space through memory mapping, and currently does not support tagging such spaces.</li><li>When Scudo reuses a freed chunk, it directly retains and uses the UAF tag assigned to it at the time of release. Otherwise, it will allocate a random tag.</li></ol><h3 id=release-2>Release<a hidden class=anchor aria-hidden=true href=#release-2>#</a></h3><p>Assign a random tag different from the previous one to the chunk to prevent UAF reusing it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>Header</span><span class=o>-&gt;</span><span class=n>ClassId</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>TSDRegistry</span><span class=p>.</span><span class=n>getDisableMemInit</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>uptr</span> <span class=n>TaggedBegin</span><span class=p>,</span> <span class=n>TaggedEnd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=k>const</span> <span class=n>uptr</span> <span class=n>OddEvenMask</span> <span class=o>=</span> <span class=n>computeOddEvenMaskForPointerMaybe</span><span class=p>(</span>
</span></span><span class=line><span class=cl>              <span class=n>Options</span><span class=p>,</span> <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>uptr</span><span class=o>&gt;</span><span class=p>(</span><span class=n>getBlockBegin</span><span class=p>(</span><span class=n>Ptr</span><span class=p>,</span> <span class=n>Header</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>              <span class=n>Header</span><span class=o>-&gt;</span><span class=n>ClassId</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=c1>// Exclude the previous tag so that immediate use after free is
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=c1>// detected 100% of the time.
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=n>setRandomTag</span><span class=p>(</span><span class=n>Ptr</span><span class=p>,</span> <span class=n>Size</span><span class=p>,</span> <span class=n>OddEvenMask</span> <span class=o>|</span> <span class=p>(</span><span class=mi>1UL</span> <span class=o>&lt;&lt;</span> <span class=n>PrevTag</span><span class=p>),</span> <span class=o>&amp;</span><span class=n>TaggedBegin</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                       <span class=o>&amp;</span><span class=n>TaggedEnd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span></code></pre></div><h3 id=analysis-2>Analysis<a hidden class=anchor aria-hidden=true href=#analysis-2>#</a></h3><p>In Scudo&rsquo;s implementation, there is a unique configuration option: UseOddEvenTags. When this option is activated, Scudo takes into special consideration the parity of the tags for each chunk during the memory allocation process. This means that it ensures that the parities of the tags for adjacent heap chunks are different.</p><p>To achieve this functionality, <code>computeOddEvenMaskForPointerMaybe</code> is used to calculate the odd-even tag mask:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>  <span class=n>uptr</span> <span class=nf>computeOddEvenMaskForPointerMaybe</span><span class=p>(</span><span class=k>const</span> <span class=n>Options</span> <span class=o>&amp;</span><span class=n>Options</span><span class=p>,</span> <span class=n>uptr</span> <span class=n>Ptr</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                         <span class=n>uptr</span> <span class=n>ClassId</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>Options</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=n>OptionBit</span><span class=o>::</span><span class=n>UseOddEvenTags</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// If a chunk&#39;s tag is odd, we want the tags of the surrounding blocks to be
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// even, and vice versa. Blocks are laid out Size bytes apart, and adding
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Size to Ptr will flip the least significant set bit of Size in Ptr, so
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// that bit will have the pattern 010101... for consecutive blocks, which we
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// can use to determine which tag mask to use.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mh>0x5555U</span> <span class=o>&lt;&lt;</span> <span class=p>((</span><span class=n>Ptr</span> <span class=o>&gt;&gt;</span> <span class=n>SizeClassMap</span><span class=o>::</span><span class=n>getSizeLSBByClassId</span><span class=p>(</span><span class=n>ClassId</span><span class=p>))</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></div><p>This configuration involves a trade-off between UAF detection and buffer overflow detection. When UseOddEvenTags is enabled, the parity of the tags for adjacent chunks is different, which eliminates the possibility that randomly allocated tags happen to be the same, thereby increasing the likelihood of detecting buffer overflows. However, on the other hand, in this case, the parity of every randomly allocated tag is fixed, which leads to a halving of the tag space, making UAF more difficult to detect.</p><p>This design highlights a key consideration in Scudo&rsquo;s implementation: how to balance mitigation strategies for different types of memory vulnerabilities while minimizing performance impact. It demonstrates the preferences and trade-offs that a heap allocator makes when dealing with memory safety.</p><h1 id=comparison>Comparison<a hidden class=anchor aria-hidden=true href=#comparison>#</a></h1><p>Disclaimer: This table only compares the implementation of MTE in various heap allocators and <strong>does not</strong> represent the overall security of the heap allocators.</p><p><img loading=lazy src=assets/1.png alt></p><ul><li><p><strong>Max Chunk Size with Tags</strong></p><p>Ptmalloc applies tags to heap chunks of any size. However, for performance reasons, Scudo and PartitionAlloc only protect heap chunks smaller than 0x10000 and 0x400, respectively.</p></li><li><p><strong>Memory Corruption Defense Capabilities</strong></p><ul><li><p>Linear Overflow</p><p>Both Ptmalloc and Scudo use 0 as the tag for chunk headers, ensuring there is always a red zone between two heap chunks that can effectively mitigate linear overflows; Whereas PartitionAlloc&rsquo;s metadata is not at the start of the heap chunk, thus there is a certain probability that adjacent heap chunks may coincidentally have the same tag.</p></li><li><p>Non-linear OOB</p><p>For non-linear out-of-bounds access, the parity of Scudo&rsquo;s tags ensures that adjacent heap chunks will definitely have different tags, thereby increasing the size of the red zone around the heap chunk, making small-scale OOB more likely to be detected.</p></li><li><p>UAF</p><p>The potential risks of UAF vulnerabilities in PartitionAlloc have been detailed in the above sections. It should be additionally noted that PartitionAlloc does not rely solely on MTE to defend against UAF vulnerabilities. It also has very strong UAF defense capabilities thanks to <a href=https://chromium.googlesource.com/chromium/src/+/main/base/memory/raw_ptr.md>MiraclePtr;</a> When Scudo enables tag parity, the tag space is halved, increasing the probability of tag collisions.</p></li><li><p>Uninitialized Memory</p><p>MTE does not significantly improve issues with uninitialized memory. Allocators like PartitionAlloc and Ptmalloc do not perform memory initialization.</p></li></ul></li><li><p><strong>Tag Management Strategy</strong></p><p>The allocation and release of heap chunks are evaluated as a whole here. PartitionAlloc does not regenerate a new tag when reusing a heap chunk from the cache but continues to use the old tag, and only increments the tag upon release; The other two allocators regenerate tags.</p></li><li><p><strong>Protection of Metadata</strong></p><p>Neither Ptmalloc nor Scudo use tags to protect metadata such as chunk headers, with the default tag being 0, which can serve as a gap between adjacent heap chunks but at the same time may be at risk of malicious tampering. Notably, PartitionAlloc&rsquo;s metadata is not stored at the start of the heap chunk, making it less susceptible to corruption.</p></li><li><p><strong>Free an Address with Incorrect Tag</strong></p><p>When releasing a heap chunk, PartitionAlloc and Scudo do not check the correctness of the tag but perform an untag operation directly, thus allowing the release of an address with an incorrect tag. However, the attack scenarios resulting from this flaw are limited and would need to be combined with other attack methods to be exploited, so we do not classify this as a high-risk issue; Ptmalloc, on the other hand, checks if the tag is correct and will raise an exception if it is not.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>  <span class=cm>/* Quickly check that the freed pointer matches the tag for the memory.
</span></span></span><span class=line><span class=cl><span class=cm>     This gives a useful double-free detection.  */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nf>__glibc_unlikely</span> <span class=p>(</span><span class=n>mtag_enabled</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=k>volatile</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>mem</span><span class=p>;</span>
</span></span></code></pre></div></li></ul><h1 id=conclusions>Conclusions<a hidden class=anchor aria-hidden=true href=#conclusions>#</a></h1><p>This article provides a detailed analysis of the implementation of MTE in the three major heap allocators, giving readers an intuitive understanding of their security. MTE is undoubtedly a significant leap forward for memory safety on the ARM platform. It is evident that with MTE enabled, traditional heap memory corruption issues are effectively mitigated, with some even becoming infeasible to exploit. However, memory safety has evolved over many years and is fraught with complex issues, with many open questions still to be resolved:</p><ul><li>Defense against uninitialized memory still relies on software implementation.</li><li>Whether stack variables will be fortified with MTE and whether performance considerations might hinder its implementation.</li><li>Tagging mmapped memory lacks support at the kernel level.</li><li>Large memory buffers, such as ring buffers and shared memory, are difficult to effectively protect with MTE.</li><li>The data segment of programs is not protected by MTE.</li></ul><p>The evolution of offense and defense has led attackers from being able to compromise systems with a single stack overflow years ago to now needing a chain of vulnerabilities to break through the layered defenses of systems, reversing the offensive and defensive situation. But we also see that even advanced technologies like MTE have blind spots, and the road to memory safety is still long and challenging. We look forward to more exciting developments in the future.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.darknavy.org/blog/avss_report_kernel/><span class=title>« Prev</span><br><span>AVSS Report: System Security Adversarial Capability Preliminary Evaluation of iOS, Android, and HarmonyOS - Kernel</span>
</a><a class=next href=https://www.darknavy.org/blog/exploiting_the_libwebp_vulnerability_part_2/><span class=title>Next »</span><br><span>Exploiting the libwebp Vulnerability, Part 2: Diving into Chrome Blink</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.darknavy.org/>DARKNAVY</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>