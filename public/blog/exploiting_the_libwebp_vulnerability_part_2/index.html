<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Exploiting the libwebp Vulnerability, Part 2: Diving into Chrome Blink | DARKNAVY</title>
<meta name="keywords" content="">
<meta name="description" content="Introduction When we examine a third-party library vulnerability in a real environment, we often encounter numerous complex variables that exist within the vulnerability&rsquo;s context. Exploiting such a vulnerability is not as easy as one might imagine.
Here is the information we know:
The overflowed variable huffman_tables, has a size of 0x2f28. The heap chunk is allocated in the renderer&rsquo;s ThreadPool, while most objects are allocated in the main thread. We can write a partially controlled 4-byte integer with an offset that is a multiple of 8 bytes.">
<meta name="author" content="DARKNAVY">
<link rel="canonical" href="https://blog.darknavy.com/blog/exploiting_the_libwebp_vulnerability_part_2/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7682668db170d001d3d5036aa16940b24ffb03817d064b8419a6340ce6dd4878.css" integrity="sha256-doJmjbFw0AHT1QNqoWlAsk/7A4F9BkuEGaY0DObdSHg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://blog.darknavy.com/images/favicon.ico">

<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Exploiting the libwebp Vulnerability, Part 2: Diving into Chrome Blink" />
<meta property="og:description" content="Introduction When we examine a third-party library vulnerability in a real environment, we often encounter numerous complex variables that exist within the vulnerability&rsquo;s context. Exploiting such a vulnerability is not as easy as one might imagine.
Here is the information we know:
The overflowed variable huffman_tables, has a size of 0x2f28. The heap chunk is allocated in the renderer&rsquo;s ThreadPool, while most objects are allocated in the main thread. We can write a partially controlled 4-byte integer with an offset that is a multiple of 8 bytes." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.darknavy.com/blog/exploiting_the_libwebp_vulnerability_part_2/" /><meta property="og:image" content="https://blog.darknavy.com/papermod-cover.png"/><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2023-11-03T14:10:17+08:00" />
<meta property="article:modified_time" content="2023-11-03T14:10:17+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://blog.darknavy.com/papermod-cover.png"/>

<meta name="twitter:title" content="Exploiting the libwebp Vulnerability, Part 2: Diving into Chrome Blink"/>
<meta name="twitter:description" content="Introduction When we examine a third-party library vulnerability in a real environment, we often encounter numerous complex variables that exist within the vulnerability&rsquo;s context. Exploiting such a vulnerability is not as easy as one might imagine.
Here is the information we know:
The overflowed variable huffman_tables, has a size of 0x2f28. The heap chunk is allocated in the renderer&rsquo;s ThreadPool, while most objects are allocated in the main thread. We can write a partially controlled 4-byte integer with an offset that is a multiple of 8 bytes."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Blog",
      "item": "https://blog.darknavy.com/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Exploiting the libwebp Vulnerability, Part 2: Diving into Chrome Blink",
      "item": "https://blog.darknavy.com/blog/exploiting_the_libwebp_vulnerability_part_2/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Exploiting the libwebp Vulnerability, Part 2: Diving into Chrome Blink",
  "name": "Exploiting the libwebp Vulnerability, Part 2: Diving into Chrome Blink",
  "description": "Introduction When we examine a third-party library vulnerability in a real environment, we often encounter numerous complex variables that exist within the vulnerability\u0026rsquo;s context. Exploiting such a vulnerability is not as easy as one might imagine.\nHere is the information we know:\nThe overflowed variable huffman_tables, has a size of 0x2f28. The heap chunk is allocated in the renderer\u0026rsquo;s ThreadPool, while most objects are allocated in the main thread. We can write a partially controlled 4-byte integer with an offset that is a multiple of 8 bytes.",
  "keywords": [
    
  ],
  "articleBody": "Introduction When we examine a third-party library vulnerability in a real environment, we often encounter numerous complex variables that exist within the vulnerability’s context. Exploiting such a vulnerability is not as easy as one might imagine.\nHere is the information we know:\nThe overflowed variable huffman_tables, has a size of 0x2f28. The heap chunk is allocated in the renderer’s ThreadPool, while most objects are allocated in the main thread. We can write a partially controlled 4-byte integer with an offset that is a multiple of 8 bytes. In Chrome, different-sized heap chunks are stored in separate buckets, isolating objects of different sizes to ensure security. Typically, achieving heap exploitation in Chrome requires identifying objects of the same size for layout purposes and then utilizing Use-After-Free (UAF) or Out-of-Bounds (OOB) techniques to manipulate other objects, leading to information disclosure or control-flow hijacking. In the following, we will share the objects we have discovered, as well as attempting to bypass this mechanism.\nInfoleak Looking for an object What we are first looking for is a suitable object that can be overwritten by OOB. Since our OOB write cannot control the value very well, writing pointers is basically excluded. The best scenario is to change fields like “length”, which has no precise requirement for the value, but it should trigger further memory issues that can be better utilized.\nIn libwebp, HuffmanCode is allocated using malloc, while in Chrome it is actually allocated by PartitionAlloc. There are four partitions in the renderer: LayoutObject partition, Buffer partition, ArrayBuffer partition, and FastMalloc partition. FastMalloc actually calls malloc in the end, so the object we are looking for can be allocated using FastMalloc.\nWe first used the codeql query mentioned by Man Yue Mo in his blogpost. Since the overflow is in the 0x3000 bucket, the available object size range is 0x2800-0x3000. Unfortunately, the query result is empty, and objects of this size almost do not exist. Another idea is to use the overflow object itself, but changing this object does not produce any special effect, and there are no other good candidate objects in libwebp. At this point, it seems to be somewhat hopeless, as the first step of exploitation has been blocked.\nSo what other ideas do we have? One idea is to use variable-length objects, such as AudioArray mentioned by Man Yue Mo, but this object is pure data and changing it is useless. After examining all the FastMalloc calls, we finally found this object.\nclass CORE_EXPORT CSSVariableData : public RefCounted\u003cCSSVariableData\u003e { USING_FAST_MALLOC(CSSVariableData); The size of this object is dynamic\nwtf_size_t bytes_needed = sizeof(CSSVariableData) + (original_text.Is8Bit() ? original_text.length() : 2 * original_text.length()); // ... snip ... void* buf = WTF::Partitions::FastMalloc( bytes_needed, WTF::GetStringWithTypeName\u003cCSSVariableData\u003e()); This object represents a variable in CSS. It can be defined in the following ways:\nelement { foo: var(--my-var, bar); } Blink will dynamically allocate the memory of CSSVariableData based on the string content of CSS variables. Another good news is that CSS variables can also be easily manipulated in JavaScript.\n// add a CSS variable element.style.setProperty('foo', 'bar'); // remove a CSS variable element.style.removeProperty('foo'); // get the value of a CSS variable getComputedStyle(element).getPropertyValue('foo'); Cross-Thread Heap Occupation We can control the size of CSSVariableData so that it is allocated in the same size bucket as HuffmanCode. A natural plan is to allocate a bunch of CSSVariableData, then free one of them, and allocate HuffmanCode to occupy the hole, as shown in the diagram below.\nThe idea is promising, but in reality, PartitionAlloc uses ThreadCache. Object allocation and deallocation are preferentially handled within the ThreadCache. Since the two objects are not allocated in the same thread, we need to find a way to remove CSSVariableData from the ThreadCache. By reading the source code of ThreadCache, we found a way.\nuint8_t limit = bucket.limit.load(std::memory_order_relaxed); // Batched deallocation, amortizing lock acquisitions. if (PA_UNLIKELY(bucket.count \u003e limit)) { ClearBucket(bucket, limit / 2); } When the bucket is full, half of the slots will be moved out to the original SlotSpan. For a bucket size of 0x3000, the limit is 16. Therefore, we can occupy the space of CSSVariableData by releasing 16 CSSVariableData to trigger ClearBucket, and then allocating HuffmanCode. In order to ensure that the CSSVariableData we want to change are located behind HuffmanCode, we need to release them every few times. The diagram below illustrates this (in actual exploit, it is released every 7).\nFrom OOB to UAF Now we have successfully allocated HuffmanCode to the freed CSSVariableData. We need to investigate which fields of this object are worth modifying.\nMemory layout of CSSVariableData:\nRecalling the primitive of our vulnerability - writing 4 bytes at an offset that is a multiple of 8 bytes. Modifying the string within the object doesn’t make any profit, so the only thing we can change is the ref_count_ field. What can we do with ref_count_? A natural idea is to transform this primitive into UAF for further exploitation. By reducing the value of ref_count_ through an OOB write, and then triggering an operation that decreases ref_count_, we can get a UAF object.\nHowever, the value written by OOB write is not entirely controllable. We need to find a way to increase the ref_count_ of CSSVariableData to a specific value first.\nlet rs = getComputedStyle(div0); // add ref_count with kOverwriteRef for (let i = 0; i \u003c kOverwriteRef; i++) { rs.getPropertyValue(kTargetCSSVar); } Testing revealed that calling getPropertyValue temporarily increases the ref_count_ of CSSVariableData. However, after GC, the temporarily increased ref_count_ is restored. Therefore, the following steps are needed to create a UAF object:\nAllocate CSSVariableData with an initial ref_count_ of 2. Call getPropertyValue kOverwriteRef times, which will increase the ref_count_ to kOverwriteRef + 2. Trigger the webp vulnerability to overwrite ref_count_ to kOverwriteRef. Trigger GC, and CSSVariableData will be freed. Calling getPropertyValue again will trigger the UAF. In getPropertyValue, blink constructs a string based on length_ and returns it to JavaScript. Therefore, we only need to allocate an object with fully controllable data, such as AudioArray, and forge the length_ field of CSSVariableData to achieve OOB read on the heap.\nCross-Bucket Allocation We have turned OOB into UAF, but the UAF object can only cause OOB read on heap. Assuming this can solve the problem of information leakage (which is not actually solved at this point), further exploitation is still not possible.\nIn previous blink heap exploits, attention was often focused on objects of the same size because they were naturally allocated together. However, at this moment, there are no better objects to exploit within the 0x3000 bucket. Can we attack objects of other sizes? Based on our investigation, the answer is yes.\nPartitionAlloc places metadata (SlotSpanMetadata) of the heap on isolated pages, and the only remaining management information on user-allocated heap slots is the freelist pointer. If we can change this pointer, we achieve arbitrary address allocation. There are double free checks in the regular free operation in SlotSpan.\nPA_ALWAYS_INLINE void SlotSpanMetadata::Free(uintptr_t slot_start, PartitionRoot* root) // ... snip ... auto* entry = static_cast\u003cinternal::EncodedNextFreelistEntry*\u003e( SlotStartAddr2Ptr(slot_start)); // Catches an immediate double free. PA_CHECK(entry != freelist_head); In ThreadCache, there is no double-free check, and we can free the same address multiple times. However, during allocation, there are checks in place, as stated clearly in the comments.\nPA_ALWAYS_INLINE static bool IsSane(const EncodedNextFreelistEntry* here, const EncodedNextFreelistEntry* next, bool for_thread_cache) { // Don't allow the freelist to be blindly followed to any location. // Checks two constraints: // - here and next must belong to the same superpage, unless this is in the // thread cache (they even always belong to the same slot span). // - next cannot point inside the metadata area. // // Also, the lightweight UaF detection (pointer shadow) is checked. The places where we want to achieve arbitrary allocation cannot belong to metadata (Previously this method was used to obtain arbitrary memory r/w, Reference) and must be within the same superpage as the original slot, both of which can be easily satisfied.\nTherefore, assuming CSSVariableData is A and the occupied AudioArray is B (where A and B actually represents the same address), we can perform a classic fastbin attack to achieve arbitrary address allocation.\nfree(A) free(B) malloc(C), and modify the freelist to address 0xdeadbeef malloc(D) malloc(E), and the allocated address for E will be 0xdeadbeef But where do we want to allocate?\nPartitionAlloc manages objects of different sizes through buckets, which manages SlotSpans consisting of slots of the same size. The basic unit of SlotSpan is Partition Page. For more details on the concepts and strategies, please refer to the official documentation. For example, a SlotSpan with a slot size 0x3000 consists of three Partition Pages, with a total size of 0xc000, allowing for the allocation of four slots.\nSlotSpans of different slot sizes may be adjacent in memory. Therefore, we just need to allocate the SlotSpan containing our interested objects near the SlotSpan with slot size 0x3000 to achieve information disclosure and object hijacking. Taking inspiration from Man Yue Mo’s blogpost, we ultimately selected HRTFPanner (with slot size 0x500) as the object we want to attack.\nWe spray objects in memory in the following way, modifying the freelist pointer to achieve allocation from a 0x3000 slot to a 0x500 slot.\nRCE Combining all of our previous knowledge, we can summarize the final steps:\nSpray a large number of SlotSpans with sizes 0x3000 and 0x500 in the heap. Trigger the webp vulnerability and convert it into CSSVariableData UAF. Occupy the freed CSSVariableData using AudioArray, and exploit the UAF to achieve infoleak. Perform a Cross-Bucket allocation to HRTFPanner and forge an HRTFPanner object. Trigger the destruction of HRTFPanner to achieve arbitrary code execution. Conclusions In this blog post, we have discussed in detail how to exploit an OOB write vulnerability in Chrome, even though the quality of this vulnerability may not be ideal. This testing was conducted solely to demonstrate the exploitability of the vulnerability and did not prioritize optimizing the success rate. The full exploit code can be found here, and the testing environment was based on Chromium compiled on Ubuntu 22.04 using this commit.\nIt’s still an open question that how to exploit this vulnerability under the mitigation mechanisms such as PAC in iOS environment. It is evident from this case that with the introduction of various mitigation mechanisms, the assessment of vulnerability severity has become increasingly complex, highlighting the limitations of a single-scale rating. DARKNAVY has publicly shared the closed-loop research on vulnerability localization, analysis, early warning, and exploit reproduction for the libwebp vulnerability, with the aim of promoting the development of scientific vulnerability assessment through adversarial assessment research that takes into account attacker perspectives and environmental characteristics.\n",
  "wordCount" : "1768",
  "inLanguage": "en",
  "datePublished": "2023-11-03T14:10:17+08:00",
  "dateModified": "2023-11-03T14:10:17+08:00",
  "author":{
    "@type": "Person",
    "name": "DARKNAVY"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.darknavy.com/blog/exploiting_the_libwebp_vulnerability_part_2/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "DARKNAVY",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blog.darknavy.com/images/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.darknavy.com" accesskey="h" title="DARKNAVY (Alt + H)">
                <img src="https://blog.darknavy.com/images/darknavy_shenlan_dot.png" alt="" aria-label="logo"
                    height="20">
            </a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://blog.darknavy.com/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://blog.darknavy.com/blog/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://blog.darknavy.com/blog_cn/" title="Blog CN">
                    <span>Blog CN</span>
                </a>
            </li>
            <li>
                <a href="https://blog.darknavy.com/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://blog.darknavy.com">Home</a>&nbsp;»&nbsp;<a href="https://blog.darknavy.com/blog/">Blog</a></div>
    <h1 class="post-title">
      Exploiting the libwebp Vulnerability, Part 2: Diving into Chrome Blink
    </h1>
    <div class="post-meta"><span title='2023-11-03 14:10:17 +0800 CST'>November 3, 2023</span>&nbsp;·&nbsp;1768 words&nbsp;·&nbsp;DARKNAVY

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a></li>
                <li>
                    <a href="#infoleak" aria-label="Infoleak">Infoleak</a><ul>
                        
                <li>
                    <a href="#looking-for-an-object" aria-label="Looking for an object">Looking for an object</a></li>
                <li>
                    <a href="#cross-thread-heap-occupation" aria-label="Cross-Thread Heap Occupation">Cross-Thread Heap Occupation</a></li>
                <li>
                    <a href="#from-oob-to-uaf" aria-label="From OOB to UAF">From OOB to UAF</a></li></ul>
                </li>
                <li>
                    <a href="#cross-bucket-allocation" aria-label="Cross-Bucket Allocation">Cross-Bucket Allocation</a></li>
                <li>
                    <a href="#rce" aria-label="RCE">RCE</a></li>
                <li>
                    <a href="#conclusions" aria-label="Conclusions">Conclusions</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h1>
<p>When we examine a third-party library vulnerability in a real environment, we often encounter numerous complex variables that exist within the vulnerability&rsquo;s context. Exploiting such a vulnerability is not as easy as one might imagine.</p>
<p>Here is the information we know:</p>
<ul>
<li>The overflowed variable <a href="https://source.chromium.org/chromium/chromium/src/+/d53886d694334f194b267db3af165e5cd61ef489:third_party/libwebp/src/src/dec/vp8l_dec.c;l=437">huffman_tables</a>, has a size of 0x2f28.</li>
<li>The heap chunk is allocated in the renderer&rsquo;s ThreadPool, while most objects are allocated in the main thread.</li>
<li>We can write a partially controlled 4-byte integer with an offset that is a multiple of 8 bytes.</li>
</ul>
<p>In Chrome, different-sized heap chunks are stored in separate buckets, isolating objects of different sizes to ensure <strong>security</strong>. Typically, achieving heap exploitation in Chrome requires identifying objects of the same size for layout purposes and then utilizing Use-After-Free (UAF) or Out-of-Bounds (OOB) techniques to manipulate other objects, leading to information disclosure or control-flow hijacking. In the following, we will share the objects we have discovered, as well as attempting to bypass this mechanism.</p>
<h1 id="infoleak">Infoleak<a hidden class="anchor" aria-hidden="true" href="#infoleak">#</a></h1>
<h2 id="looking-for-an-object">Looking for an object<a hidden class="anchor" aria-hidden="true" href="#looking-for-an-object">#</a></h2>
<p>What we are first looking for is a suitable object that can be overwritten by OOB. Since our OOB write cannot control the value very well, writing pointers is basically excluded. The best scenario is to change fields like &ldquo;length&rdquo;, which has no precise requirement for the value, but it should trigger further memory issues that can be better utilized.</p>
<p>In libwebp, <code>HuffmanCode</code> is allocated using <code>malloc</code>, while in Chrome it is actually allocated by PartitionAlloc. There are <a href="https://source.chromium.org/chromium/chromium/src/+/d53886d694334f194b267db3af165e5cd61ef489:third_party/blink/renderer/platform/wtf/allocator/Allocator.md">four partitions</a> in the renderer: <code>LayoutObject partition</code>, <code>Buffer partition</code>, <code>ArrayBuffer partition</code>, and <code>FastMalloc partition</code>. FastMalloc actually calls <code>malloc</code> in the end, so the object we are looking for can be allocated using FastMalloc.</p>
<p>We first used the codeql query mentioned by Man Yue Mo in his <a href="https://securitylab.github.com/research/one_day_short_of_a_fullchain_renderer/">blogpost</a>. Since the overflow is in the 0x3000 bucket, the available object size range is 0x2800-0x3000. Unfortunately, the query result is empty, and objects of this size almost do not exist. Another idea is to use the overflow object itself, but changing this object does not produce any special effect, and there are no other good candidate objects in libwebp. At this point, it seems to be somewhat hopeless, as the first step of exploitation has been blocked.</p>
<p>So what other ideas do we have? One idea is to use variable-length objects, such as <code>AudioArray</code> mentioned by Man Yue Mo, but this object is pure data and changing it is useless. After examining all the FastMalloc calls, we finally found this <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/css/css_variable_data.h;drc=d53886d694334f194b267db3af165e5cd61ef489;l=22">object</a>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CORE_EXPORT</span> <span class="nl">CSSVariableData</span> <span class="p">:</span> <span class="k">public</span> <span class="n">RefCounted</span><span class="o">&lt;</span><span class="n">CSSVariableData</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">USING_FAST_MALLOC</span><span class="p">(</span><span class="n">CSSVariableData</span><span class="p">);</span>
</span></span></code></pre></div><p>The size of this object is dynamic</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">    <span class="n">wtf_size_t</span> <span class="n">bytes_needed</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="k">sizeof</span><span class="p">(</span><span class="n">CSSVariableData</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">original_text</span><span class="p">.</span><span class="n">Is8Bit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                                       <span class="o">?</span> <span class="n">original_text</span><span class="p">.</span><span class="n">length</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                                       <span class="o">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">original_text</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... snip ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">WTF</span><span class="o">::</span><span class="n">Partitions</span><span class="o">::</span><span class="n">FastMalloc</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">bytes_needed</span><span class="p">,</span> <span class="n">WTF</span><span class="o">::</span><span class="n">GetStringWithTypeName</span><span class="o">&lt;</span><span class="n">CSSVariableData</span><span class="o">&gt;</span><span class="p">());</span>
</span></span></code></pre></div><p>This object represents a <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties">variable in CSS</a>. It can be defined in the following ways:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-css" data-lang="css"><span class="line"><span class="cl"><span class="nt">element</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">foo</span><span class="p">:</span> <span class="nf">var</span><span class="p">(</span><span class="o">--</span><span class="n">my</span><span class="o">-</span><span class="n">var</span><span class="p">,</span> <span class="n">bar</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Blink will dynamically allocate the memory of <code>CSSVariableData</code> based on the string content of CSS variables. Another good news is that CSS variables can also be easily manipulated in JavaScript.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// add a CSS variable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">element</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">setProperty</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// remove a CSS variable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">element</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">removeProperty</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// get the value of a CSS variable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">getComputedStyle</span><span class="p">(</span><span class="nx">element</span><span class="p">).</span><span class="nx">getPropertyValue</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
</span></span></code></pre></div><h2 id="cross-thread-heap-occupation">Cross-Thread Heap Occupation<a hidden class="anchor" aria-hidden="true" href="#cross-thread-heap-occupation">#</a></h2>
<p>We can control the size of <code>CSSVariableData</code> so that it is allocated in the same size bucket as <code>HuffmanCode</code>. A natural plan is to allocate a bunch of <code>CSSVariableData</code>, then free one of them, and allocate <code>HuffmanCode</code> to occupy the hole, as shown in the diagram below.</p>
<img src="webp.assets/image-20231101172352708.png" alt="image-20231101172352708" style="display: block; margin-left: auto; margin-right: auto; zoom: 50%;" />
<p>The idea is promising, but in reality, PartitionAlloc uses <a href="https://source.chromium.org/chromium/chromium/src/+/main:base/allocator/partition_allocator/src/partition_alloc/thread_cache.h;drc=9fc872d7a2507b4685051bd6a0d93349f668e6f8;l=241">ThreadCache</a>. Object allocation and deallocation are preferentially handled within the ThreadCache. Since the two objects are not allocated in the same thread, we need to find a way to remove <code>CSSVariableData</code> from the ThreadCache. By reading the <a href="https://source.chromium.org/chromium/chromium/src/+/main:base/allocator/partition_allocator/src/partition_alloc/thread_cache.h;drc=9fc872d7a2507b4685051bd6a0d93349f668e6f8;l=519">source code</a> of ThreadCache, we found a way.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl">  <span class="kt">uint8_t</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">.</span><span class="n">limit</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Batched deallocation, amortizing lock acquisitions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">PA_UNLIKELY</span><span class="p">(</span><span class="n">bucket</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ClearBucket</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="n">limit</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><p>When the bucket is full, half of the slots will be moved out to the original SlotSpan. For a bucket size of 0x3000, the limit is 16. Therefore, we can occupy the space of <code>CSSVariableData</code> by releasing 16 <code>CSSVariableData</code> to trigger <code>ClearBucket</code>, and then allocating <code>HuffmanCode</code>. In order to ensure that the <code>CSSVariableData</code> we want to change are located behind <code>HuffmanCode</code>, we need to release them every few times. The diagram below illustrates this (in actual exploit, it is released every 7).</p>
<img src="webp.assets/image-20231101175402808.png" alt="image-20231101175402808" style="display: block; margin-left: auto; margin-right: auto; zoom: 50%;" />
<h2 id="from-oob-to-uaf">From OOB to UAF<a hidden class="anchor" aria-hidden="true" href="#from-oob-to-uaf">#</a></h2>
<p>Now we have successfully allocated <code>HuffmanCode</code> to the freed <code>CSSVariableData</code>. We need to investigate which fields of this object are worth modifying.</p>
<p>Memory layout of <code>CSSVariableData</code>:</p>
<img src="webp.assets/image-20231102171043651.png" alt="image-20231102171043651" style="display: block; margin-left: auto; margin-right: auto; zoom: 50%;" />
<p>Recalling the primitive of our vulnerability - writing 4 bytes at an offset that is a multiple of 8 bytes. Modifying the string within the object doesn&rsquo;t make any profit, so the only thing we can change is the <code>ref_count_</code> field. What can we do with <code>ref_count_</code>? A natural idea is to transform this primitive into UAF for further exploitation. By reducing the value of <code>ref_count_</code> through an OOB write, and then triggering an operation that decreases <code>ref_count_</code>, we can get a UAF object.</p>
<p>However, the value written by OOB write is not entirely controllable. We need to find a way to increase the <code>ref_count_</code> of <code>CSSVariableData</code> to a specific value first.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">rs</span> <span class="o">=</span> <span class="nx">getComputedStyle</span><span class="p">(</span><span class="nx">div0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// add ref_count with kOverwriteRef
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">kOverwriteRef</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">rs</span><span class="p">.</span><span class="nx">getPropertyValue</span><span class="p">(</span><span class="nx">kTargetCSSVar</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><p>Testing revealed that calling <code>getPropertyValue</code> temporarily increases the <code>ref_count_</code> of <code>CSSVariableData</code>. However, after GC, the temporarily increased <code>ref_count_</code> is restored. Therefore, the following steps are needed to create a UAF object:</p>
<ol>
<li>Allocate <code>CSSVariableData</code> with an initial <code>ref_count_</code> of 2.</li>
<li>Call <code>getPropertyValue</code> kOverwriteRef times, which will increase the <code>ref_count_</code> to <code>kOverwriteRef + 2</code>.</li>
<li>Trigger the webp vulnerability to overwrite <code>ref_count_</code> to kOverwriteRef.</li>
<li>Trigger GC, and <code>CSSVariableData</code> will be freed.</li>
<li>Calling <code>getPropertyValue</code> again will trigger the UAF.</li>
</ol>
<p>In <code>getPropertyValue</code>, blink constructs a string based on <code>length_</code> and returns it to JavaScript. Therefore, we only need to allocate an object with fully controllable data, such as <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/platform/audio/audio_array.h;drc=9fc872d7a2507b4685051bd6a0d93349f668e6f8;l=45">AudioArray</a>, and forge the <code>length_</code> field of <code>CSSVariableData</code> to achieve OOB read on the heap.</p>
<h1 id="cross-bucket-allocation">Cross-Bucket Allocation<a hidden class="anchor" aria-hidden="true" href="#cross-bucket-allocation">#</a></h1>
<p>We have turned OOB into UAF, but the UAF object can only cause OOB read on heap. Assuming this can solve the problem of information leakage (which is not actually solved at this point), further exploitation is still not possible.</p>
<p>In previous blink heap exploits, attention was often focused on objects of the same size because they were naturally allocated together. However, at this moment, there are no better objects to exploit within the 0x3000 bucket. Can we attack objects of other sizes? Based on our investigation, the answer is yes.</p>
<p>PartitionAlloc places metadata (<code>SlotSpanMetadata</code>) of the heap on isolated pages, and the only remaining management information on user-allocated heap slots is the freelist pointer. If we can change this pointer, we achieve arbitrary address allocation. There are double free checks in the regular free operation in SlotSpan.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">PA_ALWAYS_INLINE</span> <span class="kt">void</span> <span class="n">SlotSpanMetadata</span><span class="o">::</span><span class="n">Free</span><span class="p">(</span><span class="n">uintptr_t</span> <span class="n">slot_start</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                             <span class="n">PartitionRoot</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ... snip ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span><span class="o">*</span> <span class="n">entry</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">internal</span><span class="o">::</span><span class="n">EncodedNextFreelistEntry</span><span class="o">*&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">SlotStartAddr2Ptr</span><span class="p">(</span><span class="n">slot_start</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Catches an immediate double free.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">PA_CHECK</span><span class="p">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="n">freelist_head</span><span class="p">);</span>
</span></span></code></pre></div><p>In ThreadCache, there is no double-free check, and we can free the same address multiple times. However, during allocation, there are checks in place, as stated clearly in the comments.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl">  <span class="n">PA_ALWAYS_INLINE</span> <span class="k">static</span> <span class="kt">bool</span> <span class="nf">IsSane</span><span class="p">(</span><span class="k">const</span> <span class="n">EncodedNextFreelistEntry</span><span class="o">*</span> <span class="n">here</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                      <span class="k">const</span> <span class="n">EncodedNextFreelistEntry</span><span class="o">*</span> <span class="n">next</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                      <span class="kt">bool</span> <span class="n">for_thread_cache</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Don&#39;t allow the freelist to be blindly followed to any location.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Checks two constraints:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// - here and next must belong to the same superpage, unless this is in the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//   thread cache (they even always belong to the same slot span).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// - next cannot point inside the metadata area.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Also, the lightweight UaF detection (pointer shadow) is checked.
</span></span></span></code></pre></div><p>The places where we want to achieve arbitrary allocation cannot belong to metadata (Previously this method was used to obtain arbitrary memory r/w, <a href="https://securelist.com/the-zero-day-exploits-of-operation-wizardopium/97086/">Reference</a>) and must be within the same superpage as the original slot, both of which can be easily satisfied.</p>
<p>Therefore, assuming <code>CSSVariableData</code> is A and the occupied <code>AudioArray</code> is B (where A and B actually represents the same address), we can perform a classic fastbin attack to achieve arbitrary address allocation.</p>
<ol>
<li>free(A)</li>
<li>free(B)</li>
<li>malloc(C), and modify the freelist to address 0xdeadbeef</li>
<li>malloc(D)</li>
<li>malloc(E), and the allocated address for E will be 0xdeadbeef</li>
</ol>
<p>But where do we want to allocate?</p>
<p>PartitionAlloc manages objects of different sizes through buckets, which manages SlotSpans consisting of slots of the same size. The basic unit of SlotSpan is Partition Page. For more details on the concepts and strategies, please refer to the <a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/base/allocator/partition_allocator/glossary.md#slots-and-spans">official documentation</a>. For example, a SlotSpan with a slot size 0x3000 consists of three Partition Pages, with a total size of 0xc000, allowing for the allocation of four slots.</p>
<p>SlotSpans of different slot sizes may be adjacent in memory. Therefore, we just need to allocate the SlotSpan containing our interested objects near the SlotSpan with slot size 0x3000 to achieve information disclosure and object hijacking. Taking inspiration from Man Yue Mo&rsquo;s blogpost, we ultimately selected <code>HRTFPanner</code> (with slot size 0x500) as the object we want to attack.</p>
<p>We spray objects in memory in the following way, modifying the freelist pointer to achieve allocation from a 0x3000 slot to a 0x500 slot.</p>
<img src="webp.assets/image-20231102153716445.png" alt="image-20231102153716445" style="display: block; margin-left: auto; margin-right: auto; zoom: 50%;" />
<h1 id="rce">RCE<a hidden class="anchor" aria-hidden="true" href="#rce">#</a></h1>
<p>Combining all of our previous knowledge, we can summarize the final steps:</p>
<ol>
<li>Spray a large number of SlotSpans with sizes 0x3000 and 0x500 in the heap.</li>
<li>Trigger the webp vulnerability and convert it into <code>CSSVariableData</code> UAF.</li>
<li>Occupy the freed <code>CSSVariableData</code> using <code>AudioArray</code>, and exploit the UAF to achieve infoleak.</li>
<li>Perform a Cross-Bucket allocation to <code>HRTFPanner</code> and forge an <code>HRTFPanner</code> object.</li>
<li>Trigger the destruction of <code>HRTFPanner</code> to achieve arbitrary code execution.</li>
</ol>
<h1 id="conclusions">Conclusions<a hidden class="anchor" aria-hidden="true" href="#conclusions">#</a></h1>
<p>In this blog post, we have discussed in detail how to exploit an OOB write vulnerability in Chrome, even though the quality of this vulnerability may not be ideal. This testing was conducted solely to demonstrate the exploitability of the vulnerability and did not prioritize optimizing the success rate. The full exploit code can be found <a href="https://github.com/DarkNavySecurity/PoC/tree/main/CVE-2023-4863">here</a>, and the testing environment was based on Chromium compiled on Ubuntu 22.04 using <a href="https://chromium.googlesource.com/chromium/src/+/b8b9a859ec2117b015d4ca440ab3483f99355f88">this commit</a>.</p>
<p>It&rsquo;s still an open question that how to exploit this vulnerability under the mitigation mechanisms such as PAC in iOS environment. It is evident from this case that with the introduction of various mitigation mechanisms, the assessment of vulnerability severity has become increasingly complex, highlighting the limitations of a single-scale rating. DARKNAVY has publicly shared the closed-loop research on vulnerability localization, analysis, early warning, and exploit reproduction for the libwebp vulnerability, with the aim of promoting the development of scientific vulnerability assessment through adversarial assessment research that takes into account attacker perspectives and environmental characteristics.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="next" href="https://blog.darknavy.com/blog/exploiting_the_libwebp_vulnerability_part_1/">
    <span class="title">Next »</span>
    <br>
    <span>Exploiting the libwebp Vulnerability, Part 1: Playing with Huffman Code</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://blog.darknavy.com">DARKNAVY</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
