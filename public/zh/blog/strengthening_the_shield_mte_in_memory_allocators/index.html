<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>填补盾牌的裂缝：堆分配器中的MTE | DARKNAVY</title><meta name=keywords content><meta name=description content="前言
2018年，随着ARMv8.5-A的发布，一个全新的芯片安全特性MTE(Memory Tagging Extensions) 横空出世。时隔五年后的2023年，市场上第一款支持此特性的手机发布 —— Google Pixel 8，宣告着MTE正式走入了消费者群体。虽然该特性在手机上还未默认启用，但开发者可以自行开启体验。
MTE作为一个强大的内存破坏防御手段，对于它的防御边界、防御能力，和它对性能的影响，目前网上还未有对其全面的分析。此前，Google Project Zero发表了一系列关于MTE的文章，其聚焦于较为底层的MTE安全性。然而MTE对于真实的软件安全性究竟有多大的影响仍是个未解之谜。想要讨论这个话题，各大堆分配器是一个很好的切入点。堆上的内存破坏问题已经逐渐成为二进制漏洞中的主流类型，参考MSRC于CppCon2019的议题内容：

通常普通开发者并不会直接使用MTE相关的汇编指令，而是依靠堆分配器自带的MTE支持间接使用，堆分配器就像盾牌一样，扛起了保护软件的任务。MTE提供了细颗粒管控内存的基础支持，如何基于硬件MTE能力实现高级安全功能的重任，留给了软件开发者。开源社区主流堆分配器积极响应，实现了基于MTE特性的安全增强，提高了堆空间的内存安全性。
本文将以MTE的三个主要玩家：Chrome中的PartitionAlloc、Glibc中的Ptmalloc、Android中的Scudo为目标，对其中MTE相关的实现分别进行讨论，并对它们进行对比。我们在研究中发现了PartitionAlloc中实现的问题，并将此问题报告给了Google，得到了Chrome团队的确认。
MTE概述

已了解MTE原理的读者可跳过此章节。
MTE利用ARMv8的TBI (Top-Byte Ignore) 特性，使用指针的高4 bits存储tag，在每个进程中有一段专用的内存用于存储tag。当为内存指定了某个tag后，程序必须带上正确的tag访问内存，若tag错误，程序抛出错误信号SIGSEGV，如下图所示：

指令集提供了系列指令来操作tag，此处举例说明MTE的基本用法：
; x0 is a pointer
irg  x1, x0
stg  x1, [x1]
ldr  x0, [x1]

IRG (Insert Random Tag) 指令为指针x0生成一个随机tag，将结果保存至x1中。
STG (Store Allocation Tag) 指令将tag应用至内存中，生效的长度取决于颗粒度，一般为16字节。
LDR (Load Register) 使用带有tag的指针读取内存。

可以看到指令集中提供了底层的支持，但各个指令的使用有很大的自由度，MTE具体如何使用，很大程度上仍然取决于软件开发者。
Allocator
Chrome - PartitionAlloc
分配
PartitionAlloc中的分配可以大致分为三种情况：

从ThreadCache中分配，不变动tag直接返回。
从空闲的SlotSpan中分配，不变动tag直接返回。
若以上两种情况均不满足，分配一个新的SlotSpan，对其中所有空闲的堆块打上随机的tag

    if (PA_LIKELY(use_tagging)) {
      // Ensure the MTE-tag of the memory pointed by other provisioned slot is
      // unguessable. They will be returned to the app as is, and the MTE-tag
      // will only change upon calling Free().
      next_slot_ptr =
          TagMemoryRangeRandomly(next_slot, TagSizeForSlot(root, slot_size));
释放
将堆块的tag加一。"><meta name=author content="DARKNAVY"><link rel=canonical href=https://www.darknavy.org/zh/blog/strengthening_the_shield_mte_in_memory_allocators/><link crossorigin=anonymous href=/assets/css/stylesheet.dc70557db50709d4e62a748e3431ee3a493e2bb592a0de8cae0eea492fbee8cb.css integrity="sha256-3HBVfbUHCdTmKnSONDHuOkk+K7WSoN6Mrg7qSS++6Ms=" rel="preload stylesheet" as=style><link rel=icon href=https://www.darknavy.org/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.darknavy.org/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.darknavy.org/favicon-32x32.png><link rel=apple-touch-icon href=https://www.darknavy.org/apple-touch-icon.png><link rel=mask-icon href=https://www.darknavy.org/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.darknavy.org/blog/strengthening_the_shield_mte_in_memory_allocators/><link rel=alternate hreflang=zh href=https://www.darknavy.org/zh/blog/strengthening_the_shield_mte_in_memory_allocators/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-LR4ZN1LSPS"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LR4ZN1LSPS")}</script><meta property="og:url" content="https://www.darknavy.org/zh/blog/strengthening_the_shield_mte_in_memory_allocators/"><meta property="og:site_name" content="DARKNAVY"><meta property="og:title" content="填补盾牌的裂缝：堆分配器中的MTE"><meta property="og:description" content="前言 2018年，随着ARMv8.5-A的发布，一个全新的芯片安全特性MTE(Memory Tagging Extensions) 横空出世。时隔五年后的2023年，市场上第一款支持此特性的手机发布 —— Google Pixel 8，宣告着MTE正式走入了消费者群体。虽然该特性在手机上还未默认启用，但开发者可以自行开启体验。
MTE作为一个强大的内存破坏防御手段，对于它的防御边界、防御能力，和它对性能的影响，目前网上还未有对其全面的分析。此前，Google Project Zero发表了一系列关于MTE的文章，其聚焦于较为底层的MTE安全性。然而MTE对于真实的软件安全性究竟有多大的影响仍是个未解之谜。想要讨论这个话题，各大堆分配器是一个很好的切入点。堆上的内存破坏问题已经逐渐成为二进制漏洞中的主流类型，参考MSRC于CppCon2019的议题内容：
通常普通开发者并不会直接使用MTE相关的汇编指令，而是依靠堆分配器自带的MTE支持间接使用，堆分配器就像盾牌一样，扛起了保护软件的任务。MTE提供了细颗粒管控内存的基础支持，如何基于硬件MTE能力实现高级安全功能的重任，留给了软件开发者。开源社区主流堆分配器积极响应，实现了基于MTE特性的安全增强，提高了堆空间的内存安全性。
本文将以MTE的三个主要玩家：Chrome中的PartitionAlloc、Glibc中的Ptmalloc、Android中的Scudo为目标，对其中MTE相关的实现分别进行讨论，并对它们进行对比。我们在研究中发现了PartitionAlloc中实现的问题，并将此问题报告给了Google，得到了Chrome团队的确认。
MTE概述 已了解MTE原理的读者可跳过此章节。
MTE利用ARMv8的TBI (Top-Byte Ignore) 特性，使用指针的高4 bits存储tag，在每个进程中有一段专用的内存用于存储tag。当为内存指定了某个tag后，程序必须带上正确的tag访问内存，若tag错误，程序抛出错误信号SIGSEGV，如下图所示：
指令集提供了系列指令来操作tag，此处举例说明MTE的基本用法：
; x0 is a pointer irg x1, x0 stg x1, [x1] ldr x0, [x1] IRG (Insert Random Tag) 指令为指针x0生成一个随机tag，将结果保存至x1中。 STG (Store Allocation Tag) 指令将tag应用至内存中，生效的长度取决于颗粒度，一般为16字节。 LDR (Load Register) 使用带有tag的指针读取内存。 可以看到指令集中提供了底层的支持，但各个指令的使用有很大的自由度，MTE具体如何使用，很大程度上仍然取决于软件开发者。
Allocator Chrome - PartitionAlloc 分配 PartitionAlloc中的分配可以大致分为三种情况：
从ThreadCache中分配，不变动tag直接返回。 从空闲的SlotSpan中分配，不变动tag直接返回。 若以上两种情况均不满足，分配一个新的SlotSpan，对其中所有空闲的堆块打上随机的tag if (PA_LIKELY(use_tagging)) { // Ensure the MTE-tag of the memory pointed by other provisioned slot is // unguessable. They will be returned to the app as is, and the MTE-tag // will only change upon calling Free(). next_slot_ptr = TagMemoryRangeRandomly(next_slot, TagSizeForSlot(root, slot_size)); 释放 将堆块的tag加一。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-01-03T16:14:27+08:00"><meta property="article:modified_time" content="2024-01-03T16:14:27+08:00"><meta property="og:image" content="https://www.darknavy.org/images/white_logo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.darknavy.org/images/white_logo.png"><meta name=twitter:title content="填补盾牌的裂缝：堆分配器中的MTE"><meta name=twitter:description content="前言
2018年，随着ARMv8.5-A的发布，一个全新的芯片安全特性MTE(Memory Tagging Extensions) 横空出世。时隔五年后的2023年，市场上第一款支持此特性的手机发布 —— Google Pixel 8，宣告着MTE正式走入了消费者群体。虽然该特性在手机上还未默认启用，但开发者可以自行开启体验。
MTE作为一个强大的内存破坏防御手段，对于它的防御边界、防御能力，和它对性能的影响，目前网上还未有对其全面的分析。此前，Google Project Zero发表了一系列关于MTE的文章，其聚焦于较为底层的MTE安全性。然而MTE对于真实的软件安全性究竟有多大的影响仍是个未解之谜。想要讨论这个话题，各大堆分配器是一个很好的切入点。堆上的内存破坏问题已经逐渐成为二进制漏洞中的主流类型，参考MSRC于CppCon2019的议题内容：

通常普通开发者并不会直接使用MTE相关的汇编指令，而是依靠堆分配器自带的MTE支持间接使用，堆分配器就像盾牌一样，扛起了保护软件的任务。MTE提供了细颗粒管控内存的基础支持，如何基于硬件MTE能力实现高级安全功能的重任，留给了软件开发者。开源社区主流堆分配器积极响应，实现了基于MTE特性的安全增强，提高了堆空间的内存安全性。
本文将以MTE的三个主要玩家：Chrome中的PartitionAlloc、Glibc中的Ptmalloc、Android中的Scudo为目标，对其中MTE相关的实现分别进行讨论，并对它们进行对比。我们在研究中发现了PartitionAlloc中实现的问题，并将此问题报告给了Google，得到了Chrome团队的确认。
MTE概述

已了解MTE原理的读者可跳过此章节。
MTE利用ARMv8的TBI (Top-Byte Ignore) 特性，使用指针的高4 bits存储tag，在每个进程中有一段专用的内存用于存储tag。当为内存指定了某个tag后，程序必须带上正确的tag访问内存，若tag错误，程序抛出错误信号SIGSEGV，如下图所示：

指令集提供了系列指令来操作tag，此处举例说明MTE的基本用法：
; x0 is a pointer
irg  x1, x0
stg  x1, [x1]
ldr  x0, [x1]

IRG (Insert Random Tag) 指令为指针x0生成一个随机tag，将结果保存至x1中。
STG (Store Allocation Tag) 指令将tag应用至内存中，生效的长度取决于颗粒度，一般为16字节。
LDR (Load Register) 使用带有tag的指针读取内存。

可以看到指令集中提供了底层的支持，但各个指令的使用有很大的自由度，MTE具体如何使用，很大程度上仍然取决于软件开发者。
Allocator
Chrome - PartitionAlloc
分配
PartitionAlloc中的分配可以大致分为三种情况：

从ThreadCache中分配，不变动tag直接返回。
从空闲的SlotSpan中分配，不变动tag直接返回。
若以上两种情况均不满足，分配一个新的SlotSpan，对其中所有空闲的堆块打上随机的tag

    if (PA_LIKELY(use_tagging)) {
      // Ensure the MTE-tag of the memory pointed by other provisioned slot is
      // unguessable. They will be returned to the app as is, and the MTE-tag
      // will only change upon calling Free().
      next_slot_ptr =
          TagMemoryRangeRandomly(next_slot, TagSizeForSlot(root, slot_size));
释放
将堆块的tag加一。"><meta name=twitter:site content="@DarkNavyOrg"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"博客","item":"https://www.darknavy.org/zh/blog/"},{"@type":"ListItem","position":2,"name":"填补盾牌的裂缝：堆分配器中的MTE","item":"https://www.darknavy.org/zh/blog/strengthening_the_shield_mte_in_memory_allocators/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"填补盾牌的裂缝：堆分配器中的MTE","name":"填补盾牌的裂缝：堆分配器中的MTE","description":"前言 2018年，随着ARMv8.5-A的发布，一个全新的芯片安全特性MTE(Memory Tagging Extensions) 横空出世。时隔五年后的2023年，市场上第一款支持此特性的手机发布 —— Google Pixel 8，宣告着MTE正式走入了消费者群体。虽然该特性在手机上还未默认启用，但开发者可以自行开启体验。\nMTE作为一个强大的内存破坏防御手段，对于它的防御边界、防御能力，和它对性能的影响，目前网上还未有对其全面的分析。此前，Google Project Zero发表了一系列关于MTE的文章，其聚焦于较为底层的MTE安全性。然而MTE对于真实的软件安全性究竟有多大的影响仍是个未解之谜。想要讨论这个话题，各大堆分配器是一个很好的切入点。堆上的内存破坏问题已经逐渐成为二进制漏洞中的主流类型，参考MSRC于CppCon2019的议题内容：\n通常普通开发者并不会直接使用MTE相关的汇编指令，而是依靠堆分配器自带的MTE支持间接使用，堆分配器就像盾牌一样，扛起了保护软件的任务。MTE提供了细颗粒管控内存的基础支持，如何基于硬件MTE能力实现高级安全功能的重任，留给了软件开发者。开源社区主流堆分配器积极响应，实现了基于MTE特性的安全增强，提高了堆空间的内存安全性。\n本文将以MTE的三个主要玩家：Chrome中的PartitionAlloc、Glibc中的Ptmalloc、Android中的Scudo为目标，对其中MTE相关的实现分别进行讨论，并对它们进行对比。我们在研究中发现了PartitionAlloc中实现的问题，并将此问题报告给了Google，得到了Chrome团队的确认。\nMTE概述 已了解MTE原理的读者可跳过此章节。\nMTE利用ARMv8的TBI (Top-Byte Ignore) 特性，使用指针的高4 bits存储tag，在每个进程中有一段专用的内存用于存储tag。当为内存指定了某个tag后，程序必须带上正确的tag访问内存，若tag错误，程序抛出错误信号SIGSEGV，如下图所示：\n指令集提供了系列指令来操作tag，此处举例说明MTE的基本用法：\n; x0 is a pointer irg x1, x0 stg x1, [x1] ldr x0, [x1] IRG (Insert Random Tag) 指令为指针x0生成一个随机tag，将结果保存至x1中。 STG (Store Allocation Tag) 指令将tag应用至内存中，生效的长度取决于颗粒度，一般为16字节。 LDR (Load Register) 使用带有tag的指针读取内存。 可以看到指令集中提供了底层的支持，但各个指令的使用有很大的自由度，MTE具体如何使用，很大程度上仍然取决于软件开发者。\nAllocator Chrome - PartitionAlloc 分配 PartitionAlloc中的分配可以大致分为三种情况：\n从ThreadCache中分配，不变动tag直接返回。 从空闲的SlotSpan中分配，不变动tag直接返回。 若以上两种情况均不满足，分配一个新的SlotSpan，对其中所有空闲的堆块打上随机的tag if (PA_LIKELY(use_tagging)) { // Ensure the MTE-tag of the memory pointed by other provisioned slot is // unguessable. They will be returned to the app as is, and the MTE-tag // will only change upon calling Free(). next_slot_ptr = TagMemoryRangeRandomly(next_slot, TagSizeForSlot(root, slot_size)); 释放 将堆块的tag加一。\n","keywords":[],"articleBody":"前言 2018年，随着ARMv8.5-A的发布，一个全新的芯片安全特性MTE(Memory Tagging Extensions) 横空出世。时隔五年后的2023年，市场上第一款支持此特性的手机发布 —— Google Pixel 8，宣告着MTE正式走入了消费者群体。虽然该特性在手机上还未默认启用，但开发者可以自行开启体验。\nMTE作为一个强大的内存破坏防御手段，对于它的防御边界、防御能力，和它对性能的影响，目前网上还未有对其全面的分析。此前，Google Project Zero发表了一系列关于MTE的文章，其聚焦于较为底层的MTE安全性。然而MTE对于真实的软件安全性究竟有多大的影响仍是个未解之谜。想要讨论这个话题，各大堆分配器是一个很好的切入点。堆上的内存破坏问题已经逐渐成为二进制漏洞中的主流类型，参考MSRC于CppCon2019的议题内容：\n通常普通开发者并不会直接使用MTE相关的汇编指令，而是依靠堆分配器自带的MTE支持间接使用，堆分配器就像盾牌一样，扛起了保护软件的任务。MTE提供了细颗粒管控内存的基础支持，如何基于硬件MTE能力实现高级安全功能的重任，留给了软件开发者。开源社区主流堆分配器积极响应，实现了基于MTE特性的安全增强，提高了堆空间的内存安全性。\n本文将以MTE的三个主要玩家：Chrome中的PartitionAlloc、Glibc中的Ptmalloc、Android中的Scudo为目标，对其中MTE相关的实现分别进行讨论，并对它们进行对比。我们在研究中发现了PartitionAlloc中实现的问题，并将此问题报告给了Google，得到了Chrome团队的确认。\nMTE概述 已了解MTE原理的读者可跳过此章节。\nMTE利用ARMv8的TBI (Top-Byte Ignore) 特性，使用指针的高4 bits存储tag，在每个进程中有一段专用的内存用于存储tag。当为内存指定了某个tag后，程序必须带上正确的tag访问内存，若tag错误，程序抛出错误信号SIGSEGV，如下图所示：\n指令集提供了系列指令来操作tag，此处举例说明MTE的基本用法：\n; x0 is a pointer irg x1, x0 stg x1, [x1] ldr x0, [x1] IRG (Insert Random Tag) 指令为指针x0生成一个随机tag，将结果保存至x1中。 STG (Store Allocation Tag) 指令将tag应用至内存中，生效的长度取决于颗粒度，一般为16字节。 LDR (Load Register) 使用带有tag的指针读取内存。 可以看到指令集中提供了底层的支持，但各个指令的使用有很大的自由度，MTE具体如何使用，很大程度上仍然取决于软件开发者。\nAllocator Chrome - PartitionAlloc 分配 PartitionAlloc中的分配可以大致分为三种情况：\n从ThreadCache中分配，不变动tag直接返回。 从空闲的SlotSpan中分配，不变动tag直接返回。 若以上两种情况均不满足，分配一个新的SlotSpan，对其中所有空闲的堆块打上随机的tag if (PA_LIKELY(use_tagging)) { // Ensure the MTE-tag of the memory pointed by other provisioned slot is // unguessable. They will be returned to the app as is, and the MTE-tag // will only change upon calling Free(). next_slot_ptr = TagMemoryRangeRandomly(next_slot, TagSizeForSlot(root, slot_size)); 释放 将堆块的tag加一。\nvoid* retagged_slot_start = internal::TagMemoryRangeIncrement( ObjectToTaggedSlotStart(object), tag_size); // Incrementing the MTE-tag in the memory range invalidates the |object|'s // tag, so it must be retagged. object = TaggedSlotStartToObject(retagged_slot_start); (过去的) 潜在威胁 我们注意到释放时对tag加一的操作是个确定性的行为，而分配时很有可能不会改动tag，这两点使得PartitionAlloc中的tag管理相当脆弱，给了攻击者可乘之机。\n设想攻击者有一个经典的UAF漏洞，并可以自由地控制触发UAF的时机，那么只需以下流程即可绕过MTE的检查：\n触发漏洞得到一个UAF的对象victim，但此时不触发UAF。 连续分配并释放一个与victim大小相同的对象15次，此时攻击者控制的对象的tag与victim的tag相同。 触发UAF。 在实际的攻击场景中，攻击者很容易获得以下两个漏洞利用原语：\n任意次数地分配任意大小的堆块。 自由地释放自己分配的对象。 例如，browser进程中的Blob对象和renderer进程中的AudioArray对象均满足上述两点。\n更为详细的报告内容及示例PoC可于Issue 1512538查看。\n分析 PartitionAlloc中的MTE支持并未如同想象般强大，其对tag的管理相对较少，最大程度地兼顾了效率，具体细节性的对比见下一章节。\nGlibc - Ptmalloc Ptmalloc中的实现最为简单粗暴，其策略简单得用几句话即可概括。\n分配 对于所有的分配，在获取到分配地址后，随机生成一个不为0的tag来标记整个分配出的chunk (代码中的实际逻辑为生成与chunk头不一样的tag值，而在我们所分析的版本2.38中，libc所管理的内存如chunk头tag为固定值0。本文后续不再对此特殊说明)。\nvictim = tcache_get (tc_idx); return tag_new_usable (victim); // ... victim = _int_malloc (ar_ptr, bytes); // ... victim = tag_new_usable (victim); 释放 将堆块的tag置为0。\n/* Mark the chunk as belonging to the library again. */ (void)tag_region (chunk2mem (p), memsize (p)); ar_ptr = arena_for_chunk (p); _int_free (ar_ptr, p, 0); 分析 对于这样的分配策略，大有一种一力降十会的感觉。在性能和安全的权衡之间Glibc选择了安全：无论是任何的分配大小、任何分配的来源 (tcache、fastbin、smallbin…)，都会被重新打上随机的tag。\nlibc中自己所管理的内存，如chunk头、被free的chunk、top chunk等，都使用了0作为tag。固定的tag 0乍一看令人觉得十分不安全，这是攻击者已知的信息，但是仔细重新审视，会发现其实不然，这一机制至少保证了以下两点：\n每两个chunk (tag非0) 之间一定存在着chunk头或free chunk (tag 0) 作为隔阂，扮演了类似Guard Page的存在，可以有效缓解线性溢出。 free后的chunk (tag 0) 和正在使用的chunk (tag非0) 拥有的tag一定不一样，可以有效缓解UAF。 Android - Scudo 相较而言，Scudo中的实现最为复杂。\n分配 Scudo只会给Primary类型 (大小 \u003c 0x10000) 的堆块打上tag，对于更大的Secondary类型，其通过内存映射的方式分配空间，目前暂不支持给这类空间分配tag。 Scudo在重用被释放的堆块时，会直接保存并使用其在释放时打上的tag；否则将分配一个随机tag。 释放 给堆块打上一个与之前不同的随机tag，防止UAF重用。\nif (Header-\u003eClassId) { if (!TSDRegistry.getDisableMemInit()) { uptr TaggedBegin, TaggedEnd; const uptr OddEvenMask = computeOddEvenMaskForPointerMaybe( Options, reinterpret_cast\u003cuptr\u003e(getBlockBegin(Ptr, Header)), Header-\u003eClassId); // Exclude the previous tag so that immediate use after free is // detected 100% of the time. setRandomTag(Ptr, Size, OddEvenMask | (1UL \u003c\u003c PrevTag), \u0026TaggedBegin, \u0026TaggedEnd); } } 分析 在Scudo的实现中，存在一个独特的配置选项：UseOddEvenTags。当此选项激活时，Scudo在内存分配过程中会特别考虑每个堆块的tag的奇偶性。这意味着，它确保每个相邻的堆块的tag奇偶性是不同的。\n为了实现这一功能，Scudo中的以下函数computeOddEvenMaskForPointerMaybe被用于计算奇偶标签掩码：\nuptr computeOddEvenMaskForPointerMaybe(const Options \u0026Options, uptr Ptr, uptr ClassId) { if (!Options.get(OptionBit::UseOddEvenTags)) return 0; // If a chunk's tag is odd, we want the tags of the surrounding blocks to be // even, and vice versa. Blocks are laid out Size bytes apart, and adding // Size to Ptr will flip the least significant set bit of Size in Ptr, so // that bit will have the pattern 010101... for consecutive blocks, which we // can use to determine which tag mask to use. return 0x5555U \u003c\u003c ((Ptr \u003e\u003e SizeClassMap::getSizeLSBByClassId(ClassId)) \u0026 1); } 这种配置涉及到UAF检测和缓冲区溢出检测之间的权衡。启用UseOddEvenTags时，相邻堆块的tag奇偶性不同，这断绝了随机分配的tag恰好相同的可能性，从而提高了检测缓冲区溢出的可能性。然而，另一方面，这种情况下每次随机分配的tag的奇偶性是固定的，这导致其标记空间减半，使得UAF更加难以被检测出来。\n这一设计凸显出Scudo在实现时的一个关键思考：如何在尽可能减少性能影响的同时，对不同类型内存漏洞的缓解策略进行平衡。这表明了堆管理器在处理内存安全性时的偏好性和取舍。\n对比 声明：此表格仅对比了各个堆分配器中MTE的实现，并不能代表堆分配器整体的安全性。\n带tag的最大堆块大小\nPtmalloc会给任意大小的堆块都打上tag；而出于性能考虑，Scudo和PartitionAlloc分别只能保护小于0x10000和0x400的堆块。\n内存破坏防御能力\nLinear Overflow\nPtmalloc和Scudo的chunk头都使用了0作为tag，因此两个堆块之间一定存在着一块red zone，可以有效缓解线性溢出；而PartitionAlloc的metadata不在堆块头部，因此有一定概率相邻堆块的tag恰好相同。\nNon-linear OOB\n对于非线性的越界访问，Scudo的tag奇偶性可以保证相邻的堆块的tag必定不同，从而可以增加堆块周围的red zone的大小，使小范围的OOB更有可能被检测到。\nUAF\nPartitionAlloc中对于UAF漏洞的潜在风险在上述章节已详细说明，此处需额外注明的是，PartitionAlloc并不（仅）依赖MTE来防御UAF漏洞，其借助MiraclePtr本身已具备了极为强大的UAF防御能力；Scudo在开启tag奇偶性的情况下，tag的分配空间会减半，使得tag碰撞的概率上升。\nUninitialized Memory\nMTE并不能很好地改善内存未初始化的问题，诸如PartitionAlloc和Ptmalloc都不会对内存进行初始化操作。\ntag管理策略\n堆块的分配和释放作为一个整体在此项评估。PartitionAlloc在重用缓存中的堆块时，并不会重新生成新的tag，而是继续沿用旧的tag，而释放时仅将tag加一；而另外两个堆分配器都完成了对tag的重新生成。\n对于metadata的保护\nPtmalloc和Scudo都没有使用tag来保护chunk头等metadata，其默认的tag为0，使其可以作为相邻堆块之间的隔离区域，但同时也可能存在着被恶意破坏的风险；值得一提的是，PartitionAlloc的metadata不会保存在堆块的头部，因此不容易被破坏。\n释放一个带有错误tag的地址\n在释放堆块时，PartitionAlloc和Scudo并不会检查tag的正确性，而是直接进行untag操作，因此可以成功释放一个带有错误tag的地址，但是这样的缺陷导致的攻击场景有限，需要结合其他的攻击手段一起利用，因此我们没有将其定为较高的风险程度；而Ptmalloc会检查tag是否正确，如果检查不符则产生异常。\n/* Quickly check that the freed pointer matches the tag for the memory. This gives a useful double-free detection. */ if (__glibc_unlikely (mtag_enabled)) *(volatile char *)mem; 结论 本文详细分析了三大堆分配器中MTE的落地实现，读者应对他们的安全性都有了直观的了解。MTE对于ARM平台上的内存安全无疑是一次大跨越，可以看出传统堆上的内存破坏问题在开启MTE后，几乎都得到了有效的缓解，有的甚至已再无利用的可能。然而内存安全经历了多年的发展，疑难杂症众多，仍有许多开放问题待解决：\n内存未初始化的防御仍依赖于软件实现。 栈上的变量是否会得到MTE的加固，是否会因为性能原因难以落地。 对mmap出的内存打上tag缺乏kernel层的支持。 对于大块内存buffer，如ring buffer、共享内存等，很难得到MTE的有效保护。 程序的data段数据不受MTE的保护。 攻防演进至此，攻击者从多年前一个栈溢出即可攻破系统，至如今需要环环相扣的漏洞来突破系统防御的层层壁垒，攻守形势逆转。但我们也看到，即使像MTE这样先进的技术也存在盲点，内存安全仍道阻且长，我们期待未来更为精彩的发展。\n","wordCount":"435","inLanguage":"zh","image":"https://www.darknavy.org/images/white_logo.png","datePublished":"2024-01-03T16:14:27+08:00","dateModified":"2024-01-03T16:14:27+08:00","author":{"@type":"Person","name":"DARKNAVY"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.darknavy.org/zh/blog/strengthening_the_shield_mte_in_memory_allocators/"},"publisher":{"@type":"Organization","name":"DARKNAVY","logo":{"@type":"ImageObject","url":"https://www.darknavy.org/images/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://www.darknavy.org/zh/ accesskey=h title="  (Alt + H)"><img src=https://www.darknavy.org/images/darknavy_shenlan_dot.png alt aria-label=logo height=20></a><div class=logo-switches><ul class=lang-switch><li>|</li><li><a href=https://www.darknavy.org/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://www.darknavy.org/zh/ title=Home><span>Home</span></a></li><li><a href=https://www.darknavy.org/zh/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://www.darknavy.org/zh/darknavy_insight/ title=Insight><span>Insight</span></a></li><li><a href=https://www.darknavy.org/zh/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.darknavy.org/zh/>主页</a>&nbsp;»&nbsp;<a href=https://www.darknavy.org/zh/blog/>博客</a></div><h1 class="post-title entry-hint-parent">填补盾牌的裂缝：堆分配器中的MTE</h1><div class=post-meta><span title='2024-01-03 16:14:27 +0800 CST'>一月 3, 2024</span>&nbsp;·&nbsp;435 字&nbsp;·&nbsp;DARKNAVY&nbsp;|&nbsp;语言:<ul class=i18n_list><li><a href=https://www.darknavy.org/blog/strengthening_the_shield_mte_in_memory_allocators/>En</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#mte概述>MTE概述</a></li><li><a href=#allocator>Allocator</a><ul><li><a href=#chrome---partitionalloc>Chrome - PartitionAlloc</a></li><li><a href=#glibc---ptmalloc>Glibc - Ptmalloc</a></li><li><a href=#android---scudo>Android - Scudo</a></li></ul></li><li><a href=#对比>对比</a></li><li><a href=#结论>结论</a></li></ul></nav></div></details></div><div class=post-content><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>2018年，随着ARMv8.5-A的发布，一个全新的芯片安全特性<a href=https://developer.arm.com/-/media/Arm%20Developer%20Community/PDF/Arm_Memory_Tagging_Extension_Whitepaper.pdf>MTE</a>(Memory Tagging Extensions) 横空出世。时隔五年后的2023年，市场上第一款支持此特性的手机发布 —— <a href=https://blog.google/products/pixel/google-pixel-8-pro/>Google Pixel 8</a>，宣告着MTE正式走入了消费者群体。虽然该特性在手机上还未默认启用，但开发者可以<a href=https://googleprojectzero.blogspot.com/2023/11/first-handset-with-mte-on-market.html>自行开启体验</a>。</p><p>MTE作为一个强大的内存破坏防御手段，对于它的防御边界、防御能力，和它对性能的影响，目前网上还未有对其全面的分析。此前，Google Project Zero发表了一系列<a href=https://googleprojectzero.blogspot.com/2023/08/mte-as-implemented-part-1.html>关于MTE的文章</a>，其聚焦于较为底层的MTE安全性。然而MTE对于真实的软件安全性究竟有多大的影响仍是个未解之谜。想要讨论这个话题，各大堆分配器是一个很好的切入点。堆上的内存破坏问题已经逐渐成为二进制漏洞中的主流类型，参考MSRC于CppCon2019的<a href=https://github.com/microsoft/MSRC-Security-Research/blob/master/presentations/2019_09_CppCon/CppCon2019%20-%20Killing%20Uninitialized%20Memory.pdf>议题</a>内容：</p><p><img alt=3 loading=lazy src=/zh/blog/strengthening_the_shield_mte_in_memory_allocators/assets/3.png></p><p>通常普通开发者并不会直接使用MTE相关的汇编指令，而是依靠堆分配器自带的MTE支持间接使用，堆分配器就像盾牌一样，扛起了保护软件的任务。MTE提供了细颗粒管控内存的基础支持，如何基于硬件MTE能力实现高级安全功能的重任，留给了软件开发者。开源社区主流堆分配器积极响应，实现了基于MTE特性的安全增强，提高了堆空间的内存安全性。</p><p>本文将以MTE的三个主要玩家：Chrome中的PartitionAlloc、Glibc中的Ptmalloc、Android中的Scudo为目标，对其中MTE相关的实现分别进行讨论，并对它们进行对比。我们在研究中发现了PartitionAlloc中实现的问题，并将此问题报告给了Google，得到了Chrome团队的确认。</p><h2 id=mte概述>MTE概述<a hidden class=anchor aria-hidden=true href=#mte概述>#</a></h2><blockquote><p>已了解MTE原理的读者可跳过此章节。</p></blockquote><p>MTE利用ARMv8的TBI (Top-Byte Ignore) 特性，使用指针的高4 bits存储tag，在每个进程中有一段专用的内存用于存储tag。当为内存指定了某个tag后，程序必须带上正确的tag访问内存，若tag错误，程序抛出错误信号SIGSEGV，如下图所示：</p><img src=assets/2.png style=display:block;margin-left:auto;margin-right:auto;zoom:50%><p>指令集提供了系列指令来操作tag，此处举例说明MTE的基本用法：</p><pre tabindex=0><code class=language-assembly data-lang=assembly>; x0 is a pointer
irg  x1, x0
stg  x1, [x1]
ldr  x0, [x1]
</code></pre><ol><li>IRG (Insert Random Tag) 指令为指针x0生成一个随机tag，将结果保存至x1中。</li><li>STG (Store Allocation Tag) 指令将tag应用至内存中，生效的长度取决于颗粒度，一般为16字节。</li><li>LDR (Load Register) 使用带有tag的指针读取内存。</li></ol><p>可以看到指令集中提供了底层的支持，但各个指令的使用有很大的自由度，MTE具体如何使用，很大程度上仍然取决于软件开发者。</p><h2 id=allocator>Allocator<a hidden class=anchor aria-hidden=true href=#allocator>#</a></h2><h3 id=chrome---partitionalloc>Chrome - PartitionAlloc<a hidden class=anchor aria-hidden=true href=#chrome---partitionalloc>#</a></h3><h4 id=分配>分配<a hidden class=anchor aria-hidden=true href=#分配>#</a></h4><p>PartitionAlloc中的分配可以大致分为三种情况：</p><ol><li>从ThreadCache中分配，不变动tag直接返回。</li><li>从空闲的SlotSpan中分配，不变动tag直接返回。</li><li>若以上两种情况均不满足，分配一个新的SlotSpan，对其中所有空闲的堆块打上随机的tag</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>PA_LIKELY</span><span class=p>(</span><span class=n>use_tagging</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Ensure the MTE-tag of the memory pointed by other provisioned slot is
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// unguessable. They will be returned to the app as is, and the MTE-tag
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// will only change upon calling Free().
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>next_slot_ptr</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>          <span class=n>TagMemoryRangeRandomly</span><span class=p>(</span><span class=n>next_slot</span><span class=p>,</span> <span class=n>TagSizeForSlot</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>slot_size</span><span class=p>));</span>
</span></span></code></pre></div><h4 id=释放>释放<a hidden class=anchor aria-hidden=true href=#释放>#</a></h4><p>将堆块的tag加一。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>      <span class=kt>void</span><span class=o>*</span> <span class=n>retagged_slot_start</span> <span class=o>=</span> <span class=n>internal</span><span class=o>::</span><span class=n>TagMemoryRangeIncrement</span><span class=p>(</span>
</span></span><span class=line><span class=cl>          <span class=n>ObjectToTaggedSlotStart</span><span class=p>(</span><span class=n>object</span><span class=p>),</span> <span class=n>tag_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Incrementing the MTE-tag in the memory range invalidates the |object|&#39;s
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// tag, so it must be retagged.
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>object</span> <span class=o>=</span> <span class=n>TaggedSlotStartToObject</span><span class=p>(</span><span class=n>retagged_slot_start</span><span class=p>);</span>
</span></span></code></pre></div><h4 id=过去的-潜在威胁>(过去的) 潜在威胁<a hidden class=anchor aria-hidden=true href=#过去的-潜在威胁>#</a></h4><p>我们注意到释放时对tag加一的操作是个确定性的行为，而分配时很有可能不会改动tag，这两点使得PartitionAlloc中的tag管理相当脆弱，给了攻击者可乘之机。</p><p>设想攻击者有一个经典的UAF漏洞，并可以自由地控制触发UAF的时机，那么只需以下流程即可绕过MTE的检查：</p><ol><li>触发漏洞得到一个UAF的对象victim，但此时不触发UAF。</li><li>连续分配并释放一个与victim大小相同的对象15次，此时攻击者控制的对象的tag与victim的tag相同。</li><li>触发UAF。</li></ol><p>在实际的攻击场景中，攻击者很容易获得以下两个漏洞利用原语：</p><ol><li>任意次数地分配任意大小的堆块。</li><li>自由地释放自己分配的对象。</li></ol><p>例如，browser进程中的<a href=https://googleprojectzero.blogspot.com/2019/04/virtually-unlimited-memory-escaping.html>Blob</a>对象和renderer进程中的<a href=https://securitylab.github.com/research/one_day_short_of_a_fullchain_renderer/>AudioArray</a>对象均满足上述两点。</p><p>更为详细的报告内容及示例PoC可于<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1512538">Issue 1512538</a>查看。</p><h4 id=分析>分析<a hidden class=anchor aria-hidden=true href=#分析>#</a></h4><p>PartitionAlloc中的MTE支持并未如同想象般强大，其对tag的管理相对较少，最大程度地兼顾了效率，具体细节性的对比见下一章节。</p><h3 id=glibc---ptmalloc>Glibc - Ptmalloc<a hidden class=anchor aria-hidden=true href=#glibc---ptmalloc>#</a></h3><p>Ptmalloc中的实现最为简单粗暴，其策略简单得用几句话即可概括。</p><h4 id=分配-1>分配<a hidden class=anchor aria-hidden=true href=#分配-1>#</a></h4><p>对于所有的分配，在获取到分配地址后，随机生成一个不为0的tag来标记整个分配出的chunk (代码中的实际逻辑为生成与chunk头不一样的tag值，而在我们所分析的版本2.38中，libc所管理的内存如chunk头tag为固定值0。本文后续不再对此特殊说明)。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>      <span class=n>victim</span> <span class=o>=</span> <span class=nf>tcache_get</span> <span class=p>(</span><span class=n>tc_idx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nf>tag_new_usable</span> <span class=p>(</span><span class=n>victim</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>victim</span> <span class=o>=</span> <span class=nf>_int_malloc</span> <span class=p>(</span><span class=n>ar_ptr</span><span class=p>,</span> <span class=n>bytes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>victim</span> <span class=o>=</span> <span class=nf>tag_new_usable</span> <span class=p>(</span><span class=n>victim</span><span class=p>);</span>
</span></span></code></pre></div><h4 id=释放-1>释放<a hidden class=anchor aria-hidden=true href=#释放-1>#</a></h4><p>将堆块的tag置为0。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>      <span class=cm>/* Mark the chunk as belonging to the library again.  */</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>tag_region</span> <span class=p>(</span><span class=nf>chunk2mem</span> <span class=p>(</span><span class=n>p</span><span class=p>),</span> <span class=nf>memsize</span> <span class=p>(</span><span class=n>p</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=n>ar_ptr</span> <span class=o>=</span> <span class=nf>arena_for_chunk</span> <span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=nf>_int_free</span> <span class=p>(</span><span class=n>ar_ptr</span><span class=p>,</span> <span class=n>p</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span></code></pre></div><h4 id=分析-1>分析<a hidden class=anchor aria-hidden=true href=#分析-1>#</a></h4><p>对于这样的分配策略，大有一种一力降十会的感觉。在性能和安全的权衡之间Glibc选择了安全：无论是任何的分配大小、任何分配的来源 (tcache、fastbin、smallbin&mldr;)，都会被重新打上随机的tag。</p><p>libc中自己所管理的内存，如chunk头、被free的chunk、top chunk等，都使用了0作为tag。固定的tag 0乍一看令人觉得十分不安全，这是攻击者已知的信息，但是仔细重新审视，会发现其实不然，这一机制至少保证了以下两点：</p><ol><li>每两个chunk (tag非0) 之间一定存在着chunk头或free chunk (tag 0) 作为隔阂，扮演了类似Guard Page的存在，可以有效缓解线性溢出。</li><li>free后的chunk (tag 0) 和正在使用的chunk (tag非0) 拥有的tag一定不一样，可以有效缓解UAF。</li></ol><h3 id=android---scudo>Android - Scudo<a hidden class=anchor aria-hidden=true href=#android---scudo>#</a></h3><p>相较而言，Scudo中的实现最为复杂。</p><h4 id=分配-2>分配<a hidden class=anchor aria-hidden=true href=#分配-2>#</a></h4><ol><li>Scudo只会给Primary类型 (大小 &lt; 0x10000) 的堆块打上tag，对于更大的Secondary类型，其通过内存映射的方式分配空间，目前暂不支持给这类空间分配tag。</li><li>Scudo在重用被释放的堆块时，会直接保存并使用其在释放时打上的tag；否则将分配一个随机tag。</li></ol><h4 id=释放-2>释放<a hidden class=anchor aria-hidden=true href=#释放-2>#</a></h4><p>给堆块打上一个与之前不同的随机tag，防止UAF重用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>Header</span><span class=o>-&gt;</span><span class=n>ClassId</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>TSDRegistry</span><span class=p>.</span><span class=n>getDisableMemInit</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>uptr</span> <span class=n>TaggedBegin</span><span class=p>,</span> <span class=n>TaggedEnd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=k>const</span> <span class=n>uptr</span> <span class=n>OddEvenMask</span> <span class=o>=</span> <span class=n>computeOddEvenMaskForPointerMaybe</span><span class=p>(</span>
</span></span><span class=line><span class=cl>              <span class=n>Options</span><span class=p>,</span> <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>uptr</span><span class=o>&gt;</span><span class=p>(</span><span class=n>getBlockBegin</span><span class=p>(</span><span class=n>Ptr</span><span class=p>,</span> <span class=n>Header</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>              <span class=n>Header</span><span class=o>-&gt;</span><span class=n>ClassId</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=c1>// Exclude the previous tag so that immediate use after free is
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=c1>// detected 100% of the time.
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=n>setRandomTag</span><span class=p>(</span><span class=n>Ptr</span><span class=p>,</span> <span class=n>Size</span><span class=p>,</span> <span class=n>OddEvenMask</span> <span class=o>|</span> <span class=p>(</span><span class=mi>1UL</span> <span class=o>&lt;&lt;</span> <span class=n>PrevTag</span><span class=p>),</span> <span class=o>&amp;</span><span class=n>TaggedBegin</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                       <span class=o>&amp;</span><span class=n>TaggedEnd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span></code></pre></div><h4 id=分析-2>分析<a hidden class=anchor aria-hidden=true href=#分析-2>#</a></h4><p>在Scudo的实现中，存在一个独特的配置选项：UseOddEvenTags。当此选项激活时，Scudo在内存分配过程中会特别考虑每个堆块的tag的奇偶性。这意味着，它确保每个相邻的堆块的tag奇偶性是不同的。</p><p>为了实现这一功能，Scudo中的以下函数<code>computeOddEvenMaskForPointerMaybe</code>被用于计算奇偶标签掩码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>  <span class=n>uptr</span> <span class=nf>computeOddEvenMaskForPointerMaybe</span><span class=p>(</span><span class=k>const</span> <span class=n>Options</span> <span class=o>&amp;</span><span class=n>Options</span><span class=p>,</span> <span class=n>uptr</span> <span class=n>Ptr</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                         <span class=n>uptr</span> <span class=n>ClassId</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>Options</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=n>OptionBit</span><span class=o>::</span><span class=n>UseOddEvenTags</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// If a chunk&#39;s tag is odd, we want the tags of the surrounding blocks to be
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// even, and vice versa. Blocks are laid out Size bytes apart, and adding
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Size to Ptr will flip the least significant set bit of Size in Ptr, so
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// that bit will have the pattern 010101... for consecutive blocks, which we
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// can use to determine which tag mask to use.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mh>0x5555U</span> <span class=o>&lt;&lt;</span> <span class=p>((</span><span class=n>Ptr</span> <span class=o>&gt;&gt;</span> <span class=n>SizeClassMap</span><span class=o>::</span><span class=n>getSizeLSBByClassId</span><span class=p>(</span><span class=n>ClassId</span><span class=p>))</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></div><p>这种配置涉及到UAF检测和缓冲区溢出检测之间的权衡。启用UseOddEvenTags时，相邻堆块的tag奇偶性不同，这断绝了随机分配的tag恰好相同的可能性，从而提高了检测缓冲区溢出的可能性。然而，另一方面，这种情况下每次随机分配的tag的奇偶性是固定的，这导致其标记空间减半，使得UAF更加难以被检测出来。</p><p>这一设计凸显出Scudo在实现时的一个关键思考：如何在尽可能减少性能影响的同时，对不同类型内存漏洞的缓解策略进行平衡。这表明了堆管理器在处理内存安全性时的偏好性和取舍。</p><h2 id=对比>对比<a hidden class=anchor aria-hidden=true href=#对比>#</a></h2><p>声明：此表格仅对比了各个堆分配器中MTE的实现，并<strong>不能</strong>代表堆分配器整体的安全性。</p><p><img loading=lazy src=/zh/blog/strengthening_the_shield_mte_in_memory_allocators/assets/1.png></p><ul><li><p><strong>带tag的最大堆块大小</strong></p><p>Ptmalloc会给任意大小的堆块都打上tag；而出于性能考虑，Scudo和PartitionAlloc分别只能保护小于0x10000和0x400的堆块。</p></li><li><p><strong>内存破坏防御能力</strong></p><ul><li><p>Linear Overflow</p><p>Ptmalloc和Scudo的chunk头都使用了0作为tag，因此两个堆块之间一定存在着一块red zone，可以有效缓解线性溢出；而PartitionAlloc的metadata不在堆块头部，因此有一定概率相邻堆块的tag恰好相同。</p></li><li><p>Non-linear OOB</p><p>对于非线性的越界访问，Scudo的tag奇偶性可以保证相邻的堆块的tag必定不同，从而可以增加堆块周围的red zone的大小，使小范围的OOB更有可能被检测到。</p></li><li><p>UAF</p><p>PartitionAlloc中对于UAF漏洞的潜在风险在上述章节已详细说明，此处需额外注明的是，PartitionAlloc并不（仅）依赖MTE来防御UAF漏洞，其借助<a href=https://chromium.googlesource.com/chromium/src/+/main/base/memory/raw_ptr.md>MiraclePtr</a>本身已具备了极为强大的UAF防御能力；Scudo在开启tag奇偶性的情况下，tag的分配空间会减半，使得tag碰撞的概率上升。</p></li><li><p>Uninitialized Memory</p><p>MTE并不能很好地改善内存未初始化的问题，诸如PartitionAlloc和Ptmalloc都不会对内存进行初始化操作。</p></li></ul></li><li><p><strong>tag管理策略</strong></p><p>堆块的分配和释放作为一个整体在此项评估。PartitionAlloc在重用缓存中的堆块时，并不会重新生成新的tag，而是继续沿用旧的tag，而释放时仅将tag加一；而另外两个堆分配器都完成了对tag的重新生成。</p></li><li><p><strong>对于metadata的保护</strong></p><p>Ptmalloc和Scudo都没有使用tag来保护chunk头等metadata，其默认的tag为0，使其可以作为相邻堆块之间的隔离区域，但同时也可能存在着被恶意破坏的风险；值得一提的是，PartitionAlloc的metadata不会保存在堆块的头部，因此不容易被破坏。</p></li><li><p><strong>释放一个带有错误tag的地址</strong></p><p>在释放堆块时，PartitionAlloc和Scudo并不会检查tag的正确性，而是直接进行untag操作，因此可以成功释放一个带有错误tag的地址，但是这样的缺陷导致的攻击场景有限，需要结合其他的攻击手段一起利用，因此我们没有将其定为较高的风险程度；而Ptmalloc会检查tag是否正确，如果检查不符则产生异常。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>  <span class=cm>/* Quickly check that the freed pointer matches the tag for the memory.
</span></span></span><span class=line><span class=cl><span class=cm>     This gives a useful double-free detection.  */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nf>__glibc_unlikely</span> <span class=p>(</span><span class=n>mtag_enabled</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=k>volatile</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>mem</span><span class=p>;</span>
</span></span></code></pre></div></li></ul><h2 id=结论>结论<a hidden class=anchor aria-hidden=true href=#结论>#</a></h2><p>本文详细分析了三大堆分配器中MTE的落地实现，读者应对他们的安全性都有了直观的了解。MTE对于ARM平台上的内存安全无疑是一次大跨越，可以看出传统堆上的内存破坏问题在开启MTE后，几乎都得到了有效的缓解，有的甚至已再无利用的可能。然而内存安全经历了多年的发展，疑难杂症众多，仍有许多开放问题待解决：</p><ul><li>内存未初始化的防御仍依赖于软件实现。</li><li>栈上的变量是否会得到MTE的加固，是否会因为性能原因难以落地。</li><li>对mmap出的内存打上tag缺乏kernel层的支持。</li><li>对于大块内存buffer，如ring buffer、共享内存等，很难得到MTE的有效保护。</li><li>程序的data段数据不受MTE的保护。</li></ul><p>攻防演进至此，攻击者从多年前一个栈溢出即可攻破系统，至如今需要环环相扣的漏洞来突破系统防御的层层壁垒，攻守形势逆转。但我们也看到，即使像MTE这样先进的技术也存在盲点，内存安全仍道阻且长，我们期待未来更为精彩的发展。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.darknavy.org/zh/blog/exploiting_steam_usual_and_unusual_ways_in_the_cef_framework/><span class=title>« 上一页</span><br><span>Steam漏洞利用：CEF框架应用下的常规与非常规利用手段</span>
</a><a class=next href=https://www.darknavy.org/zh/blog/exploiting_the_libwebp_vulnerability_part_2/><span class=title>下一页 »</span><br><span>Exploiting the libwebp Vulnerability, Part 2: Diving into Chrome Blink</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.darknavy.org/zh/>DARKNAVY</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>